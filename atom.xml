<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习生活手账本</title>
  <icon>https://www.gravatar.com/avatar/260de78781b3355b5fcbb52d09a7a2a9</icon>
  
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/"/>
  <updated>2024-02-07T17:21:24.764Z</updated>
  <id>https://github.com/xyy9233/xyy9233.github.io.git/</id>
  
  <author>
    <name>wind_9233</name>
    <email>1768765226@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/06/BeginCTF/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/06/BeginCTF/</id>
    <published>2024-02-06T12:17:37.034Z</published>
    <updated>2024-02-07T17:21:24.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeginCTF-2024冬"><a href="#BeginCTF-2024冬" class="headerlink" title="BeginCTF 2024冬"></a>BeginCTF 2024冬</h1><p>写的题不多，从师傅们写的特别好的wp们学到了很多，</p><p>以下是学习复现后的一些笔记</p><p>参考了很多师傅的文章：</p><p><a href="https://hjug69b9j6.feishu.cn/docx/V02Rd3MyWoRPVxxTTCOcLutNnqe">官方wp</a></p><p><a href="http://t.csdnimg.cn/jCdia">直接写了很多不会的题的题解</a></p><p><a href="https://www.hbailu.top/index.php/archives/131">这哥们思路图非常好，借鉴</a></p><p><a href="https://yurogod.github.io/ctf/events/BeginCTF-2024/">除密码的全能师傅</a></p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><p><a href="https://hw6vk9v66q.feishu.cn/docx/UIm5dwwbzo4O6IxALeZcpXdCnDh">题目附件</a></p><h3 id="real-checkin-xor"><a href="#real-checkin-xor" class="headerlink" title="real checkin xor"></a><strong>real checkin xor</strong></h3><p>这道题是，因为签到逆向题有点难，出题师傅又出的真真签到题，确实不难。</p><p>直接给的就是代码</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206205429012.png" alt="image-20240206205429012"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>]=&#123; <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, </span><br><span class="line"><span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, </span><br><span class="line"><span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, </span><br><span class="line"><span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> key[<span class="number">100</span>]=&#123;<span class="string">&quot;ez_python_xor_reverse&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">42</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]^key[i%<span class="built_in">strlen</span>(key)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//begin&#123;3z_PY7hoN_r3V3rSE_For_TH3_Be9inNEr!&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_func</span>(<span class="params">encrypted, key</span>):</span><br><span class="line">    decrypted = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encrypted)):</span><br><span class="line">        decrypted.append(<span class="built_in">chr</span>(encrypted[i] ^ <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(decrypted)</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;ez_python_xor_reverse&quot;</span></span><br><span class="line">ciper = [<span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, <span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span>]</span><br><span class="line"></span><br><span class="line">decrypted_text = decrypt_func(ciper, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的文本:&quot;</span>, decrypted_text)</span><br></pre></td></tr></table></figure><h3 id="红白机"><a href="#红白机" class="headerlink" title="红白机"></a>红白机</h3><p>要注意下载的文件名呜呜</p><p><a href="https://wusiyu.me/6502-cpu%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4%E9%9B%86/#zhi_ling_ji">指令集</a></p><h4 id="6502汇编码-直接编译运行"><a href="#6502汇编码-直接编译运行" class="headerlink" title="# 6502汇编码   直接编译运行"></a># 6502汇编码   直接编译运行</h4><p><a href="https://codediy.github.io/nes-zh/easy6502/index.html">Easy 6502</a></p><h4 id="或者自己手搓"><a href="#或者自己手搓" class="headerlink" title="或者自己手搓"></a>或者自己手搓</h4><p>偏移为0x200，黑色地方提取画图</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">screen = [[<span class="number">0</span>] * <span class="number">32</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addr_to_coords</span>(<span class="params">addr</span>):</span><br><span class="line">    addr -= <span class="number">0x200</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">divmod</span>(addr, <span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> base <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x200</span>, <span class="number">0x600</span>, <span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span>):</span><br><span class="line">        row, col = addr_to_coords(base + offset)</span><br><span class="line">        screen[row][col] = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">ops = [</span><br><span class="line">    (<span class="number">0x201</span>, <span class="number">0</span>), (<span class="number">0x202</span>, <span class="number">0</span>), (<span class="number">0x221</span>, <span class="number">0</span>), (<span class="number">0x240</span>, <span class="number">0</span>), (<span class="number">0x241</span>, <span class="number">0</span>), (<span class="number">0x242</span>, <span class="number">0</span>), (<span class="number">0x261</span>, <span class="number">0</span>), (<span class="number">0x281</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="number">0x204</span>, <span class="number">0</span>), (<span class="number">0x224</span>, <span class="number">0</span>), (<span class="number">0x244</span>, <span class="number">0</span>), (<span class="number">0x264</span>, <span class="number">0</span>), (<span class="number">0x284</span>, <span class="number">0</span>), (<span class="number">0x246</span>, <span class="number">0</span>), (<span class="number">0x247</span>, <span class="number">0</span>), (<span class="number">0x248</span>, <span class="number">0</span>),</span><br><span class="line">..........................</span><br><span class="line">..........................</span><br><span class="line"> </span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> addr, val <span class="keyword">in</span> ops:</span><br><span class="line">    row, col = addr_to_coords(addr)</span><br><span class="line">    screen[row][col] = val</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> screen:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(<span class="string">&#x27;   &#x27;</span> <span class="keyword">if</span> pixel <span class="keyword">else</span> <span class="string">&#x27; * &#x27;</span> <span class="keyword">for</span> pixel <span class="keyword">in</span> row))</span><br></pre></td></tr></table></figure><h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a><strong>xor</strong></h3><p>upx壳+反调试</p><blockquote><p>rdata段：用于从远程服务器获取当前日期和时间的命令行实用程序，通常用于UNIX类操作系统以将系统时钟与远程时间服务器同步。</p></blockquote><h4 id="走弯路做法：分析加密原理，找静态资源"><a href="#走弯路做法：分析加密原理，找静态资源" class="headerlink" title="走弯路做法：分析加密原理，找静态资源"></a>走弯路做法：分析加密原理，找静态资源</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206224417017.png" alt="image-20240206224417017"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> dec3[<span class="number">33</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> dec4[] = <span class="string">&quot;`agh&#123;^bvuwTooahlYocPtmyiijj|ek&#x27;p&quot;</span>;</span><br><span class="line"><span class="type">char</span> key1[] = <span class="string">&quot;63290794207715587679621386735000&quot;</span>;</span><br><span class="line"><span class="type">char</span> key2[] = <span class="string">&quot;41803873625901363092606632787947&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">char</span> *output,<span class="type">char</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">char</span> dec1[<span class="number">33</span>];</span><br><span class="line">    <span class="type">char</span> dec2[<span class="number">33</span>];</span><br><span class="line">    <span class="type">char</span> key1[<span class="number">33</span>];</span><br><span class="line">    <span class="type">char</span> key2[<span class="number">33</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        key1[i] = key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        key2[i] = key[i + <span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;  </span><br><span class="line">        dec1[i] = output[i + <span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;  </span><br><span class="line">        dec2[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec1[i] ^= key1[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec2[i] ^= key2[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        dec1[i] ^= key2[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec2[i] ^= key1[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec1[i] ^= key1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;  </span><br><span class="line">        dec2[i] ^= key2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec1[i] ^= key2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec2[i] ^= key1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        dec3[i] = dec1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        dec3[i + <span class="number">16</span>] = dec2[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    dec(dec4,key2);</span><br><span class="line">    dec(dec3,key1);</span><br><span class="line">    <span class="built_in">printf</span>(dec3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单粗暴法：异或是可逆的"><a href="#简单粗暴法：异或是可逆的" class="headerlink" title="简单粗暴法：异或是可逆的"></a>简单粗暴法：异或是可逆的</h4><p>但是得考虑反调试，要不然出不来，</p><h3 id="superguesser（动态调试"><a href="#superguesser（动态调试" class="headerlink" title="superguesser（动态调试"></a><strong>superguesser</strong>（动态调试</h3><h4 id="a-静态猜测！牛"><a href="#a-静态猜测！牛" class="headerlink" title="a?静态猜测！牛"></a>a?静态猜测！牛</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206235813820.png" alt="image-20240206235813820"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">bytearray</span>.fromhex(<span class="string">&quot;5151525f59435d5f59495a59562e261d2a371a27291728242a3825213d0f323a3c3d36332a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">37</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(data[i] ^ (i + <span class="number">51</span>)), end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="俄语学习"><a href="#俄语学习" class="headerlink" title="俄语学习"></a>俄语学习</h3><p>IDA后发现答案都是明文，（但是好多题</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207224620727.png" alt="image-20240207224620727"></p><p>最后的求flag才是正菜</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207222416136.png" alt="image-20240207222416136"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207231022742.png" alt="image-20240207231022742"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207231040398.png" alt="image-20240207231040398"></p><p>flag输入后，内容是要去func2中的tmpStr（明文）比较的，所以需要运行并提取tmpStr加密前后的内容，还有两个盒子以及Str2_0</p><p>主要加密是rc4，而且str的加密结果和tmpStr的加密结果是相同的，间接的给出了str的结果</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208010234042.png" alt="image-20240208010234042"></p><h4 id="爆破rc4"><a href="#爆破rc4" class="headerlink" title="爆破rc4"></a>爆破rc4</h4><p>#硬写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> box3[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> box4[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个盒子 box</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> box[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0xF1</span>, <span class="number">0xDA</span>, <span class="number">0x19</span>, <span class="number">0x7A</span>, <span class="number">0xF6</span>, <span class="number">0x31</span>, <span class="number">0x9C</span>, <span class="number">0xD9</span>, <span class="number">0x2C</span>,</span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0xFC</span>, <span class="number">0xE2</span>, <span class="number">0xD8</span>, <span class="number">0x1D</span>, <span class="number">0x8D</span>, <span class="number">0x4F</span>, <span class="number">0x97</span>, <span class="number">0x81</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0xC0</span>, <span class="number">0xB8</span>, <span class="number">0x96</span>, <span class="number">0x27</span>, <span class="number">0xD5</span>, <span class="number">0x5B</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0x85</span>, <span class="number">0xFA</span>,</span><br><span class="line">  <span class="number">0x61</span>, <span class="number">0xE4</span>, <span class="number">0xA1</span>, <span class="number">0xBC</span>, <span class="number">0xF8</span>, <span class="number">0xA4</span>, <span class="number">0x56</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0x58</span>,</span><br><span class="line">  <span class="number">0x2B</span>, <span class="number">0xC9</span>, <span class="number">0x77</span>, <span class="number">0x64</span>, <span class="number">0xCC</span>, <span class="number">0x6B</span>, <span class="number">0x98</span>, <span class="number">0x65</span>, <span class="number">0x75</span>, <span class="number">0x38</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x09</span>, <span class="number">0x11</span>, <span class="number">0x3D</span>, <span class="number">0xD0</span>, <span class="number">0xE6</span>, <span class="number">0x8F</span>, <span class="number">0xA9</span>, <span class="number">0x57</span>, <span class="number">0x99</span>,</span><br><span class="line">  <span class="number">0x06</span>, <span class="number">0x10</span>, <span class="number">0x5D</span>, <span class="number">0xC5</span>, <span class="number">0x69</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x68</span>, <span class="number">0x7E</span>, <span class="number">0xE3</span>,</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0xD1</span>, <span class="number">0xFF</span>, <span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xF5</span>, <span class="number">0x41</span>, <span class="number">0x8C</span>, <span class="number">0xDD</span>, <span class="number">0x21</span>,</span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xA7</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x6D</span>, <span class="number">0xC3</span>, <span class="number">0x2A</span>, <span class="number">0x9A</span>, <span class="number">0x9F</span>, <span class="number">0x20</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0xBB</span>, <span class="number">0x94</span>, <span class="number">0xB9</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0x02</span>, <span class="number">0x74</span>, <span class="number">0x7D</span>, <span class="number">0x1B</span>,</span><br><span class="line">  <span class="number">0x1E</span>, <span class="number">0x5F</span>, <span class="number">0xBA</span>, <span class="number">0x49</span>, <span class="number">0xD6</span>, <span class="number">0xE7</span>, <span class="number">0x53</span>, <span class="number">0x04</span>, <span class="number">0xCB</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xE8</span>, <span class="number">0x33</span>, <span class="number">0x3E</span>, <span class="number">0x00</span>, <span class="number">0x9B</span>, <span class="number">0x6A</span>, <span class="number">0xFD</span>, <span class="number">0xBE</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0xED</span>, <span class="number">0xDF</span>, <span class="number">0x4D</span>, <span class="number">0x25</span>, <span class="number">0x6F</span>, <span class="number">0xB5</span>, <span class="number">0x13</span>, <span class="number">0x70</span>, <span class="number">0x3C</span>,</span><br><span class="line">  <span class="number">0x9E</span>, <span class="number">0x16</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x4A</span>, <span class="number">0x73</span>, <span class="number">0xDE</span>, <span class="number">0xB1</span>, <span class="number">0x8A</span>, <span class="number">0x51</span>,</span><br><span class="line">  <span class="number">0x3B</span>, <span class="number">0x54</span>, <span class="number">0x14</span>, <span class="number">0xE0</span>, <span class="number">0x5A</span>, <span class="number">0xDC</span>, <span class="number">0x91</span>, <span class="number">0x62</span>, <span class="number">0xA3</span>, <span class="number">0x95</span>,</span><br><span class="line">  <span class="number">0xD3</span>, <span class="number">0x3A</span>, <span class="number">0x17</span>, <span class="number">0xEE</span>, <span class="number">0x32</span>, <span class="number">0xF2</span>, <span class="number">0x7C</span>, <span class="number">0xAF</span>, <span class="number">0xB3</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x0E</span>, <span class="number">0xAE</span>, <span class="number">0x9D</span>, <span class="number">0x5C</span>, <span class="number">0x0D</span>, <span class="number">0x55</span>, <span class="number">0x4E</span>, <span class="number">0xFB</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0xBF</span>, <span class="number">0x52</span>, <span class="number">0x12</span>, <span class="number">0x66</span>, <span class="number">0x07</span>, <span class="number">0xD2</span>, <span class="number">0x36</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x6E</span>, <span class="number">0x42</span>, <span class="number">0x1A</span>, <span class="number">0x0F</span>, <span class="number">0xE9</span>, <span class="number">0x60</span>, <span class="number">0xCA</span>, <span class="number">0xB2</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0x83</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>, <span class="number">0x76</span>, <span class="number">0xA8</span>, <span class="number">0x1F</span>, <span class="number">0x63</span>, <span class="number">0xEF</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>,</span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0xAB</span>, <span class="number">0xDB</span>, <span class="number">0xD4</span>, <span class="number">0x7F</span>, <span class="number">0x01</span>, <span class="number">0x34</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x59</span>, <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0xC6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>, <span class="number">0x40</span>, <span class="number">0xC8</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0xC4</span>, <span class="number">0x89</span>, <span class="number">0xC2</span>, <span class="number">0xB6</span>, <span class="number">0x71</span>, <span class="number">0xA0</span>, <span class="number">0xEB</span>, <span class="number">0x2F</span>, <span class="number">0x78</span>, <span class="number">0xF3</span>,</span><br><span class="line">  <span class="number">0xB0</span>, <span class="number">0xFE</span>, <span class="number">0xCE</span>, <span class="number">0xF7</span>, <span class="number">0x84</span>, <span class="number">0x72</span>, <span class="number">0xF4</span>, <span class="number">0xCF</span>, <span class="number">0xC7</span>, <span class="number">0xD7</span>,</span><br><span class="line">  <span class="number">0xB7</span>, <span class="number">0x8E</span>, <span class="number">0x4C</span>, <span class="number">0x82</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x2E</span>, <span class="number">0x24</span>, <span class="number">0x87</span>, <span class="number">0x08</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xE5</span>, <span class="number">0xEA</span>, <span class="number">0xA6</span>, <span class="number">0x8B</span>, <span class="number">0x15</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入进行处理的字符串 Str2_0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Str2_0[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>,</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>,</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>,</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x8E</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理后的 tmpStr</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tmpStr[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理前的 tmpStr</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tmpstr[] = <span class="string">&quot;+i&amp;[@Y:g8[&amp;l$f8S8v$Y&amp;e&gt;&#123;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* box, <span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">unsigned</span> <span class="type">long</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; datalen; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span>;</span><br><span class="line">        tmp = box[i];</span><br><span class="line">        box[i] = box[j];</span><br><span class="line">        box[j] = tmp;</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span>;</span><br><span class="line">        data[k] ^= box[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> flag[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先备份一份 box</span></span><br><span class="line">    <span class="built_in">memcpy</span>(box3,box,<span class="number">256</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v1, v2, v3;</span><br><span class="line">    <span class="type">int</span> v11, v21, v31;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = v2 = v3 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(box3, box, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="type">char</span>*)tmpStr); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i] != <span class="number">0</span>)                           <span class="comment">// 先根据flag的内容来</span></span><br><span class="line">            &#123;</span><br><span class="line">                v1 = (v1 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">                v2 = (v2 + box3[v1]) % <span class="number">256</span>;</span><br><span class="line">                tmp = box3[v1];</span><br><span class="line">                box3[v1] = box3[v2];</span><br><span class="line">                box3[v2] = tmp;</span><br><span class="line">                v3 = (box3[v1] + box3[v2]) % <span class="number">256</span>;</span><br><span class="line">                <span class="comment">//tmpstr[i] ^= box3[v3];</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                        <span class="comment">// 爆破</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//先保存上一次正确的 v1、v2、v3</span></span><br><span class="line">                v11 = v1;</span><br><span class="line">                v21 = v2;</span><br><span class="line">                v31 = v3;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> j = <span class="number">32</span>; j &lt; <span class="number">127</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    k = j + Str2_0[i] - <span class="number">112</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(box4, box3, <span class="number">256</span>);</span><br><span class="line">                    v1 = v11;</span><br><span class="line">                    v2 = v21;</span><br><span class="line">                    v3 = v31;</span><br><span class="line"></span><br><span class="line">                    v1 = (v1 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">                    v2 = (v2 + box4[v1]) % <span class="number">256</span>;</span><br><span class="line">                    tmp = box4[v1];</span><br><span class="line">                    box4[v1] = box4[v2];</span><br><span class="line">                    box4[v2] = tmp;</span><br><span class="line">                    v3 = (box4[v1] + box4[v2]) % <span class="number">256</span>;</span><br><span class="line">                    k ^= box4[v3];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (k == tmpStr[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag[i] = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>((<span class="type">char</span>*)flag) == <span class="built_in">strlen</span>((<span class="type">char</span>*)tmpStr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rc4逆向"><a href="#rc4逆向" class="headerlink" title="rc4逆向"></a>rc4逆向</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="string">b&quot;5m5d5w5d5b5n5m5d5w5d5b5n5m5d5w5d5b5n\x8e&quot;</span></span><br><span class="line"><span class="comment"># tmp[i] = flag[i] + t[i]-112</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher.ARC4 <span class="keyword">import</span> *</span><br><span class="line">enc = <span class="built_in">bytes</span>([<span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>, <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>, <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>])</span><br><span class="line">rc4 = new(t)</span><br><span class="line">p = rc4.decrypt(enc)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">p = <span class="built_in">list</span>(p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">    p[i] = (p[i]+<span class="number">112</span>-t[i])&amp;<span class="number">0xff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(p))</span><br></pre></td></tr></table></figure><h4 id="不经过rc4"><a href="#不经过rc4" class="headerlink" title="不经过rc4"></a>不经过rc4</h4><p>对box进行交叉引用可以发现，box和box2其实是相同的</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208000241839.png" alt="image-20240208000241839"></p><p>那么rc4加密在使用相同box的前提下，想要得到的密文相同，就必须保证明文在进行rc4加密之前就是相同的，即key和temStr在加密前就是相同的。</p><p>这样我们就可以简化成如下步骤：</p><p>key &#x3D; 用户输入 + str2_0 - 112</p><p>temStr &#x3D; +i&amp;[@Y:g8[&amp;l$f8S8v$Y&amp;e&gt;{</p><p>str2_0 &#x3D; unk_6C8E68 - 114</p><p>unk_6C8E68就是俄文单词нечего重复3次</p><blockquote><p>几个问答全都没用，看中间关键的几个加密函数</p><p>中间涉及到rc4，但是最后用于比对的key2和str1经过同一个S盒的RC4加密，等于没加密</p><p>几个长得像key的几个字符串是有用的，排除干扰之后逻辑非常简单</p><p><a href="http://t.csdnimg.cn/QKP71">http://t.csdnimg.cn/QKP71</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> rus[<span class="number">38</span>] = <span class="string">&quot;нечегонечегонечего&quot;</span>;<span class="comment">//37</span></span><br><span class="line">    <span class="type">char</span> key2[<span class="number">26</span>] = <span class="string">&quot;+i&amp;[@Y:g8[&amp;l$f8S8v$Y&amp;e&gt;&#123;&quot;</span>;<span class="comment">//25</span></span><br><span class="line">    <span class="type">char</span> key1[<span class="number">38</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//37</span></span><br><span class="line">    <span class="type">char</span> flag[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(rus); ++i)</span><br><span class="line">        key1[i] = rus[i] - <span class="number">114</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s   %d&quot;</span>, key1, <span class="built_in">strlen</span>(key1));<span class="comment">//5m5d5w5d5b5n5m5d5w5d5b5n5m5d5w5d5b5n 37</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(key2); ++i)</span><br><span class="line">        flag[i] = key2[i] - key1[i] + <span class="number">112</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);<span class="comment">//flag&#123;Russian_is_so_easy&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ezpython"><a href="#Ezpython" class="headerlink" title="Ezpython"></a>Ezpython</h3><h4 id="考点：sm4，python"><a href="#考点：sm4，python" class="headerlink" title="考点：sm4，python"></a>考点：sm4，python</h4><p>pyinstaller打包python生成的exe</p><p>pyinstxtractor工具拆包—ezpython.exe_extracted</p><p>里面找到ezpython.pyc文件，使用uncompyle6 反编译出源码</p><p>uncompyle6.exe .\ezpython.pyc</p><p>SM4加密</p><p>寻找密文和key进行解密</p><p>由于编码问题，使用uncompyle6.exe .\ezpython.pyc &gt; ezpython.py会出现报错</p><p>于是将上述反编译出的源码贴进一个自己新建的ezpython.py文件中，把这个文件放进ezpython.exe_extracted文件里，用vscode打开这个文件夹</p><p>为了得到key和enc</p><p>需要在文件夹里面找到secret.pyc，然后对其进行反编译</p><p>uncompyle6.exe .\secret.pyc &gt; .\secret.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key = &#x27;BeginCTFBeginCTF&#x27;</span><br><span class="line">enc = </span><br><span class="line">b&#x27;JmjJEAJGMT6F9bmC+Vyxy8Z1lpfaJzdEX6BGG/qgqUjUpQaYSON1CnZyX9YXTEClSRYm7PFZtGxmJw6LPuw1ww==&#x27;</span><br></pre></td></tr></table></figure><p>但是赛博厨子求不出，猜测魔改sm4算法</p><p>ezpython.py中导入了sm4库，于是将文件夹内的sm4.pyc进行反编译</p><p>uncompyle6.exe .\sm4.pyc &gt; sm4.py</p><p>根据题目提示，魔改可能与密钥相关，于是直接查找key</p><p>容易发现CryptSM4类下的set_key方法存在魔改</p><p>将原始key值异或了37</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208001132113.png" alt="image-20240208001132113"></p><h3 id="出题人的密码是什么"><a href="#出题人的密码是什么" class="headerlink" title="出题人的密码是什么"></a>出题人的密码是什么</h3><p>#花指令</p><p>恢复main函数逻辑</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208001311389.png" alt="image-20240208001311389"></p><p>主要加密是一个魔改crc64</p><p>通过和零比较，从而进行不同的加密，实际上是比较的最高位</p><p>看密文最低位，根据最低位，判断这个数在加密前最高位是1还是0</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="number">0x33077d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">value, key</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        <span class="keyword">if</span> value &amp; <span class="number">1</span>:</span><br><span class="line">            value = (value ^ key) &gt;&gt; <span class="number">1</span></span><br><span class="line">            value |= <span class="number">0x8000000000000000</span>  <span class="comment">#还原最高位</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = value &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">out = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;B4BBD8EBD06EABCA658E4BE94DD44AF37D29C2F99589A4859DCDDF77FD45CB5D7DFD934BBCF67CF32442F5D2DDE356AE&#x27;</span>)</span><br><span class="line">out = [((i ^ <span class="number">0x25</span>) - <span class="number">5</span>) &amp; <span class="number">0xff</span> <span class="keyword">for</span> i <span class="keyword">in</span> out]</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(out), <span class="number">8</span>):</span><br><span class="line">    v = <span class="built_in">int</span>.from_bytes(out[i: i + <span class="number">8</span>], <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    flag += decrypt(v, key).to_bytes(<span class="number">8</span>, <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag.decode())</span><br></pre></td></tr></table></figure><p>同时这个题目里面还有简单的时间反调试</p><h3 id="Arc（没学过的（会学的"><a href="#Arc（没学过的（会学的" class="headerlink" title="Arc（没学过的（会学的"></a><strong>Arc</strong>（没学过的（会学的</h3><h4 id="z3-考点：单字节爆破，混淆"><a href="#z3-考点：单字节爆破，混淆" class="headerlink" title="z3?考点：单字节爆破，混淆"></a>z3?<strong>考点：单字节爆破，混淆</strong></h4><h3 id="Not-main"><a href="#Not-main" class="headerlink" title="Not main"></a>Not main</h3><h4 id="考点：TEA，XXTEA，VEH异常处理，反调试"><a href="#考点：TEA，XXTEA，VEH异常处理，反调试" class="headerlink" title="考点：TEA，XXTEA，VEH异常处理，反调试"></a>考点：TEA，XXTEA，VEH异常处理，反调试</h4><h4 id="veh反调试，全局变量初始化init（没学，继续"><a href="#veh反调试，全局变量初始化init（没学，继续" class="headerlink" title="veh反调试，全局变量初始化init（没学，继续"></a>veh反调试，全局变量初始化init（没学，继续</h4><h3 id="EZVM（不太会"><a href="#EZVM（不太会" class="headerlink" title="EZVM（不太会"></a>EZVM（不太会</h3><p>vm题 c++</p><h3 id="Goforfun（不会"><a href="#Goforfun（不会" class="headerlink" title="Goforfun（不会"></a>Goforfun（不会</h3><h4 id="考点：go语言，rc4魔改，单字节爆破"><a href="#考点：go语言，rc4魔改，单字节爆破" class="headerlink" title="考点：go语言，rc4魔改，单字节爆破"></a>考点：go语言，rc4魔改，单字节爆破</h4><p>go语言编写的程序，go 1.21</p><p>可以装一个idagolanghelper插件帮助恢复符号表</p><p>恢复之后确定主函数就需要动调</p><h3 id="Babyvm（不太会，留着"><a href="#Babyvm（不太会，留着" class="headerlink" title="Babyvm（不太会，留着"></a>Babyvm（不太会，留着</h3><h4 id="考点：vm，二进制文件读写，z3"><a href="#考点：vm，二进制文件读写，z3" class="headerlink" title="考点：vm，二进制文件读写，z3"></a>考点：vm，二进制文件读写，z3</h4><p>主程序逻辑不难，难点在如何批量处理指令和数据，附上打印汇编语言的脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\opcode.vm&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">  bincode= <span class="built_in">list</span>(file.read())</span><br><span class="line">opcode= <span class="built_in">open</span> (<span class="string">&quot;D:\\opcode.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_to_int</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> a|(b&lt;&lt;<span class="number">8</span>)|(c&lt;&lt;<span class="number">16</span>)|(d&lt;&lt;<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">op_list=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">3643</span>:</span><br><span class="line">    k=byte_to_int(bincode[<span class="number">4</span>*i],bincode[<span class="number">4</span>*i+<span class="number">1</span>],bincode[<span class="number">4</span>*i+<span class="number">2</span>],bincode[<span class="number">4</span>*i+<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">match</span> k:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                add_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(add_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(add_list[<span class="number">1</span>])+<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(add_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            sub_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                sub_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(sub_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(sub_list[<span class="number">1</span>])+<span class="string">&#x27;-&#x27;</span>+<span class="built_in">str</span>(sub_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            mul_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                mul_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(mul_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(mul_list[<span class="number">1</span>])+<span class="string">&#x27;*&#x27;</span>+<span class="built_in">str</span>(mul_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            div_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                div_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(div_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(div_list[<span class="number">1</span>])+<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(div_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            op_list.append(<span class="string">&quot;in_pointer=0&quot;</span>)</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            op_list.append(<span class="string">&quot;out_pointer=0&quot;</span>)</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            popin_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                popin_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;popin &quot;</span>+<span class="built_in">str</span>(popin_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(popin_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            popout_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                popout_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;popout &quot;</span>+<span class="built_in">str</span>(popout_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(popout_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            read_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">2</span>,<span class="number">1</span>):</span><br><span class="line">                read_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            <span class="keyword">if</span>(read_list[<span class="number">0</span>]&lt;=<span class="number">199</span>):</span><br><span class="line">                op_list.append(<span class="string">&quot;read &quot;</span>+<span class="built_in">str</span>(read_list[<span class="number">0</span>]))</span><br><span class="line">            i+=<span class="number">2</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            wri_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">2</span>,<span class="number">1</span>):</span><br><span class="line">                wri_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;write &quot;</span>+<span class="built_in">str</span>(wri_list[<span class="number">0</span>]))</span><br><span class="line">            i+=<span class="number">2</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            jmp_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                jmp_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;jmp &quot;</span>+<span class="built_in">str</span>(jmp_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(jmp_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            njmp_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                njmp_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;njmp &quot;</span>+<span class="built_in">str</span>(njmp_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(njmp_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">            len_list=[]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                len_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;len &quot;</span>+<span class="built_in">str</span>(len_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(len_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:\\opcode.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    [fp.write(<span class="built_in">str</span>(item)+<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">for</span>  item <span class="keyword">in</span> op_list]</span><br><span class="line">    fp.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>汇编有点长主逻辑就只是一个线性方程式，用z3一把梭，这个留给大家自己尝试了</p><h3 id="stick-game"><a href="#stick-game" class="headerlink" title="stick game"></a>stick game</h3><p>修改得分（web题？</p><h4 id="考点：Js，ob混淆"><a href="#考点：Js，ob混淆" class="headerlink" title="考点：Js，ob混淆"></a>考点：Js，ob混淆</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208010936245.png" alt="image-20240208010936245"></p><p>想法：<a href="https://linmur.top/post/beginctf-2024-reverse-writeup/">https://linmur.top/post/beginctf-2024-reverse-writeup/</a></p><h3 id="真龙之力（不会"><a href="#真龙之力（不会" class="headerlink" title="真龙之力（不会"></a>真龙之力（不会</h3><h4 id="java？贴个题解"><a href="#java？贴个题解" class="headerlink" title="java？贴个题解"></a>java？贴个题解</h4><p><a href="https://www.yuque.com/u37581038/mrtw91/be9vb75fxnmah7s5?singleDoc#Fw1my">https://www.yuque.com/u37581038/mrtw91/be9vb75fxnmah7s5?singleDoc#Fw1my</a></p><h4 id="考点：XTEA，Mobile，Mobile调试"><a href="#考点：XTEA，Mobile，Mobile调试" class="headerlink" title="考点：XTEA，Mobile，Mobile调试"></a>考点：XTEA，Mobile，Mobile调试</h4><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="tupper"><a href="#tupper" class="headerlink" title="tupper"></a>tupper</h3><p>用这个网站讲附加拼接的字符串转化为图片，即得到flag <a href="https://tuppers-formula.ovh/">https://tuppers-formula.ovh/</a></p><p>又学到了一种加密方式。。</p><h3 id="devil’s-word"><a href="#devil’s-word" class="headerlink" title="devil’s word"></a>devil’s word</h3><p>看附件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leu lia leu ng leu cai leu jau leu e cai b cai jau sa leng cai ng ng f leu b leu e sa leng cai cai ng f cai cai sa sa leu e cai a leu bo leu f cai ng ng f leu sii leu jau sa sii leu c leu ng leu sa cai sii cai d</span><br></pre></td></tr></table></figure><p>看题目”魔鬼的语言”,搜一下猜想是温州话，其实就是温州话的0-9发音,单个字母就表示单个字母(无语了,当时没想到)。根据温州话的发音，得到这个对应关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leng 0</span><br><span class="line">lia 2</span><br><span class="line">sa 3</span><br><span class="line">sii 4</span><br><span class="line">ng 5</span><br><span class="line">leu 6</span><br><span class="line">cai 7</span><br><span class="line">bo 8</span><br><span class="line">jau 9</span><br></pre></td></tr></table></figure><p>赛博厨子解码得到flag</p><h3 id="你知道中国文化吗1-0"><a href="#你知道中国文化吗1-0" class="headerlink" title="你知道中国文化吗1.0"></a>你知道中国文化吗1.0</h3><p>文本24个字符分一组→base32解码→八卦转8进制→8进制转字符串→字符串转社会主义编码→社会主义解码→字符串栅栏解密得到最后的flag。</p><p>八卦对应数字:</p><p>☰0<br>☱1<br>☲2<br>☳3<br>☴4<br>☵5<br>☶6<br>☷7 </p><p>其中base32解码脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;附件.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = f.readline()</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        a = a.strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            b = base64.b32decode(a)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;八卦.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> m:</span><br><span class="line">            m.write(b.decode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>这题麻烦的地方就是有的分组里面有特殊字符 $ &amp; @,这些特殊字符需要替换成大写英文字母或者数字才能正确编码，这里的一个思路就是找有没有相似的分组，将特殊字符替换成对应位置的字符即可。(一个特殊字符替换成多个字符都有可能正确解码为八卦符，但是这样好像并不影响结果)</p><h3 id="下一站上岸！"><a href="#下一站上岸！" class="headerlink" title="下一站上岸！"></a>下一站上岸！</h3><p>题目描述: 某同学在考公的时候看到这样一道题，发现自己怎么也找不到图形的共同特征或规律你能帮帮他吗？</p><p>给的图片:<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206234443538.png" alt="image-20240206234443538"></p><p>zsteg图片，发现隐写内容:</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206234456075.png" alt="image-20240206234456075"></p><p>即: 5o+Q56S6OuaRqeaWr+WvhueggQ&#x3D;&#x3D;</p><p>base64解密得到(base64编码由a-zA-Z0-9+&#x2F;组成):</p><p>根据每个图形的交点数得到: 221022201122120120111011110222012101<br>将0替换成’ ‘ 1替换成’.’ 2替换成’-‘再解码得到flag<br>(至于为什么这么替换一共6种情况可以fuzz一下)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BeginCTF-2024冬&quot;&gt;&lt;a href=&quot;#BeginCTF-2024冬&quot; class=&quot;headerlink&quot; title=&quot;BeginCTF 2024冬&quot;&gt;&lt;/a&gt;BeginCTF 2024冬&lt;/h1&gt;&lt;p&gt;写的题不多，从师傅们写的特别好的wp们学到了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python逆向</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/04/python%E9%80%86%E5%90%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/04/python%E9%80%86%E5%90%91/</id>
    <published>2024-02-03T16:00:00.000Z</published>
    <updated>2024-02-05T04:54:05.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python逆向"><a href="#Python逆向" class="headerlink" title="Python逆向"></a>Python逆向</h1><h2 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h2><h3 id="创建及使用"><a href="#创建及使用" class="headerlink" title="创建及使用"></a>创建及使用</h3><p>pyc 文件是 python 在编译 *.py 文件过程中出现的<strong>主要中间过程</strong>文件，是一种<strong>二进制</strong>文件，是一种bytecode<strong>。pyc 文件是可以由 <strong>python</strong> <strong>虚拟机</strong>直接执行的程序。因此分析 <strong>pyc</strong> <strong>文件的文件结构</strong>对于实现 pyc 反编译就显得十分重要。另外，</strong>pyc** <strong>的内容，是跟</strong> <strong>python</strong> <strong>的版本相关的</strong>，不同版本编译后的pyc 文件是不同的，3.8 编译的 pyc 文件，3.7 版本的 python 是无法执行的。</p><p>先写个 test.py：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">v1, v2</span>):</span><br><span class="line"><span class="keyword">return</span> v1 + v2</span><br></pre></td></tr></table></figure><p>我们可以通过 py_compile 模块来生成 pyc 文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> py_compile <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">compile</span>(<span class="string">&quot;test.py&quot;</span>)</span><br></pre></td></tr></table></figure><p>或者直接通过命令行 python -m test.py 生成 pyc。</p><p>两种操作都会在当前目录下新建一个 <strong>pycache</strong> 目录，其中存放着 test.cpython-版本号.pyc 。</p><p>如果有一个现成的 pyc 文件，要如何导入它呢？</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> SourcelessFileLoader</span><br><span class="line">test = SourcelessFileLoader(</span><br><span class="line"><span class="string">&quot;test&quot;</span>, <span class="string">&quot;__pycache__/test.cpython-38.pyc&quot;</span></span><br><span class="line">).load_module()</span><br><span class="line"><span class="built_in">print</span>(test.a)</span><br><span class="line"><span class="built_in">print</span>(test.add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a><strong>文件结构</strong></h3><p>pyc 文件在创建的时候都会往里面写入如下内容：</p><p><strong>1. magic number</strong></p><p>这是 Python 定义的一个整数值，不同版本的 Python 会定义不同的 magic number，这个值是为了保证 Python 能够加载正确的 pyc。</p><p>比如 Python3.7 不会加载 3.6 版本的 pyc，因为 Python 在加载 pyc 文件的时候会首先检测该 pyc 的magic number。如果和自身的 magic number 不一致，则拒绝加载。</p><p><strong>2.</strong> <strong>创建时间戳</strong></p><p>这个很好理解，在加载 pyc 之前会先比较源代码的最后修改时间和 pyc 文件的写入时间。如果 pyc 文件的写入时间比源代码的修改时间要早，说明在生成 pyc 之后，源代码被修改了，那么会重新编译并写入pyc，而反之则会直接加载已存在的 pyc。</p><p><strong>3. py</strong> <strong>文件的大小</strong></p><p>py 文件的大小也会被记录在 pyc 文件中。</p><p><strong>4. PyCodeObject</strong> <strong>对象</strong></p><p>编译之后的 PyCodeObject 对象，并且是序列化之后再存储。因此 pyc 文件的结构如下：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204124547436.png" alt="image-20240204124547436"></p><p>以上是 Python 3.7+ 的 pyc 文件结构，如果版本低于 3.7，那么开头没有 4 个 \x00。我们实际验</p><p>证一下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> importlib.util <span class="keyword">import</span> MAGIC_NUMBER</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;__pycache__/test.cpython-38.pyc&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="comment"># 0 ~ 4 字节是 MAGIC NUMBER</span></span><br><span class="line"><span class="built_in">print</span>(data[: <span class="number">4</span>]) <span class="comment"># b&#x27;U\r\r\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(MAGIC_NUMBER) <span class="comment"># b&#x27;U\r\r\n&#x27;</span></span><br><span class="line"><span class="comment"># 4 ~ 8 字节是 4 个 \x00</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">4</span>: <span class="number">8</span>]) <span class="comment"># b&#x27;\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 8 ~ 12 字节是 pyc 的写入时间（小端存储），一个时间戳</span></span><br><span class="line">ts = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[<span class="number">8</span>: <span class="number">12</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(ts) <span class="comment"># 1685686081</span></span><br><span class="line"><span class="built_in">print</span>(datetime.fromtimestamp(ts)) <span class="comment"># 2023-06-02 14:08:01</span></span><br><span class="line"><span class="comment"># 12 ~ 16 字节是 py 文件的大小</span></span><br><span class="line"><span class="built_in">print</span>(struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[<span class="number">12</span>: <span class="number">16</span>])[<span class="number">0</span>]) <span class="comment"># 47</span></span><br></pre></td></tr></table></figure><p>结果和我们分析的一样，因此对于任何一个 pyc 文件来说，前 16 字节是固定的（如果 Python 低于3.7，那么前 12 个字节是固定的）。</p><p>16 个字节往后就是 PyCodeObject 对象，并且是序列化之后的，因为该对象显然无法直接存在文件中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;__pycache__/test.cpython-38.pyc&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="comment"># 通过 marshal.loads 反序列化</span></span><br><span class="line">code = marshal.loads(data[<span class="number">16</span>:]) <span class="comment"># 此时就拿到了 py 文件编译之后的 PyCodeObject</span></span><br><span class="line"><span class="built_in">print</span>(code)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;code object &lt;module&gt; at 0x..., file &quot;test.py&quot;, line 1&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 查看字节码</span></span><br><span class="line"><span class="built_in">print</span>(code.co_code)</span><br><span class="line"><span class="comment"># 查看常量池</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts)</span><br><span class="line"><span class="comment"># 符号表</span></span><br><span class="line"><span class="built_in">print</span>(code.co_names)</span><br></pre></td></tr></table></figure><p>既然我们可以根据 pyc 文件反推出 PyCodeObject，那么能否手动构建 PyCodeObject 然后生成 pyc呢？来试一下。例如我们想实现如下的 py 文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上述代码编译之后的结果，就是我们要构建的 PyCodeObject。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">from</span> opcode <span class="keyword">import</span> opmap</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> CodeType</span><br><span class="line"><span class="keyword">from</span> importlib.util <span class="keyword">import</span> MAGIC_NUMBER</span><br><span class="line">HEADER = MAGIC_NUMBER + <span class="string">b&quot;\x00&quot;</span> * <span class="number">4</span></span><br><span class="line"><span class="comment"># 时间随便写</span></span><br><span class="line">HEADER += struct.pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="built_in">int</span>(time.time()))</span><br><span class="line"><span class="comment"># 大小随便写</span></span><br><span class="line">HEADER += struct.pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="number">47</span>)</span><br><span class="line"><span class="comment"># 构建 PyCodeObject</span></span><br><span class="line">code = CodeType(</span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_argcount</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_posonlyargcount</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_kwonlyargcount</span></span><br><span class="line">    <span class="number">3</span>, <span class="comment"># co_nlocals</span></span><br><span class="line">    <span class="number">1</span>, <span class="comment"># co_stacksize</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_flags</span></span><br><span class="line">    <span class="built_in">bytes</span>([</span><br><span class="line">        <span class="comment"># a = 1 分为两步</span></span><br><span class="line">            <span class="comment"># 第一步：先通过 LOAD_CONST 将常量加载进来</span></span><br><span class="line">            <span class="comment"># 因此指令是 LOAD_CONST，然后参数是 0</span></span><br><span class="line">            <span class="comment"># 表示加载常量池 co_consts 中索引为 0 的常量</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">0</span>,</span><br><span class="line">            <span class="comment"># 第二步：通过 STORE_NAME 将常量和符号绑定起来</span></span><br><span class="line">            <span class="comment"># 参数是 0，表示和符号表中索引为 0 的符号进行绑定</span></span><br><span class="line">            opmap[<span class="string">&quot;STORE_NAME&quot;</span>], <span class="number">0</span>,</span><br><span class="line">            <span class="comment"># b = 2</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">1</span>,</span><br><span class="line">            opmap[<span class="string">&quot;STORE_NAME&quot;</span>], <span class="number">1</span>,</span><br><span class="line">            <span class="comment"># c = 3</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">2</span>,</span><br><span class="line">            opmap[<span class="string">&quot;STORE_NAME&quot;</span>], <span class="number">2</span>,</span><br><span class="line">            <span class="comment"># 结尾要 LOAD 一个 None，然后返回</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">3</span>,</span><br><span class="line">            opmap[<span class="string">&quot;RETURN_VALUE&quot;</span>]</span><br><span class="line">    ]), <span class="comment"># co_code</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">None</span>), <span class="comment"># co_consts</span></span><br><span class="line">    (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>), <span class="comment"># co_names</span></span><br><span class="line">    (), <span class="comment"># co_varnames</span></span><br><span class="line">            <span class="string">&quot;out.py&quot;</span>, <span class="comment"># co_filename</span></span><br><span class="line">            <span class="string">&quot;&lt;module&gt;&quot;</span>, <span class="comment"># co_name</span></span><br><span class="line">            <span class="number">1</span>, <span class="comment"># co_firstlineno</span></span><br><span class="line">            <span class="string">b&quot;&quot;</span>, <span class="comment"># co_lnotab</span></span><br><span class="line">            (), <span class="comment"># freevars</span></span><br><span class="line">            () <span class="comment"># cellvars</span></span><br><span class="line">            )</span><br><span class="line">    <span class="comment"># pyc 文件内容</span></span><br><span class="line">            pyc_content = HEADER + marshal.dumps(code)</span><br><span class="line">            <span class="comment"># 生成 pyc 文件</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;out.pyc&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f :</span><br><span class="line">        f.write(pyc_content)</span><br><span class="line">            <span class="comment"># 然后加载生成的 pyc 文件</span></span><br><span class="line">            <span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> SourcelessFileLoader</span><br><span class="line">            mod = SourcelessFileLoader(</span><br><span class="line">                <span class="string">&quot;out&quot;</span>, <span class="string">&quot;out.pyc&quot;</span></span><br><span class="line">            ).load_module()</span><br><span class="line">            <span class="built_in">print</span>(mod) <span class="comment"># &lt;module &#x27;out&#x27; from &#x27;out.pyc&#x27;&gt;</span></span><br><span class="line">            <span class="built_in">print</span>(mod.a) <span class="comment"># 1</span></span><br><span class="line">            <span class="built_in">print</span>(mod.b) <span class="comment"># 2</span></span><br><span class="line">            <span class="built_in">print</span>(mod.c) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a><strong>逆向工具</strong></h3><p>我们可以通过如下方式来反编译 pyc 文件，拿到源码：</p><p><a href="https://tool.lu/pyc/"><strong>在线工具</strong></a></p><p><strong>pycdc</strong>：编译演示<a href="https://github.com/zrax/pycdc">https://github.com/zrax/pycdc</a></p><p>uncompyle6：安装方式 pip install uncompyle6</p><h2 id="pyc-字节码"><a href="#pyc-字节码" class="headerlink" title="pyc 字节码"></a><strong>pyc</strong> <strong>字节码</strong></h2><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a><strong>反汇编</strong></h3><p>字节码拿过来<strong>反汇编</strong>就得到了针对 Python 虚拟机的<strong>汇编代码</strong>，类似于 x86 汇编，但是比 x86 的好读多了。通过 dis.dis() 就可以将字节码转为可读的伪代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;out.pyc&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">raw = f.read()</span><br><span class="line">code = marshal.loads(raw[<span class="number">16</span>:])</span><br><span class="line">dis.dis(code)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> STORE_NAME <span class="number">0</span> (a)</span><br><span class="line"><span class="number">4</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">6</span> STORE_NAME <span class="number">1</span> (b)</span><br><span class="line"><span class="number">8</span> LOAD_CONST <span class="number">2</span> (<span class="number">3</span>)</span><br><span class="line"><span class="number">10</span> STORE_NAME <span class="number">2</span> (c)</span><br><span class="line"><span class="number">12</span> LOAD_CONST <span class="number">3</span> (<span class="literal">None</span>)</span><br><span class="line"><span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>结构如下：</p><p>源码行号 | 指令在函数中的偏移 | 指令符号 | 指令参数 | 实际参数值</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><p>LOAD_CONST 用于加载常量，比如数值、字符串等等，一般用于传给函数的参数，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span> <span class="number">12</span> LOAD_GLOBAL <span class="number">1</span> (test)</span><br><span class="line"><span class="number">15</span> LOAD_FAST <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">18</span> LOAD_CONST <span class="number">1</span> (<span class="string">&#x27;output&#x27;</span>)</span><br><span class="line"><span class="number">21</span> CALL_FUNCTION <span class="number">2</span></span><br></pre></td></tr></table></figure><p>转为 python 代码就是：</p><p>test(2, “output”)</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><strong>全局变量</strong></h4><p>LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号。</p><p>STORE_GLOBAL 用来给全局变量赋值。</p><p>例如</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">0</span> LOAD_CONST <span class="number">1</span> (<span class="number">101</span>)</span><br><span class="line"><span class="number">2</span> STORE_GLOBAL <span class="number">0</span> (num)</span><br><span class="line"><span class="number">6</span> <span class="number">4</span> LOAD_GLOBAL <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">6</span> LOAD_GLOBAL <span class="number">0</span> (num)</span><br><span class="line"><span class="number">8</span> CALL_FUNCTION <span class="number">1</span></span><br></pre></td></tr></table></figure><p>对应的 python 代</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="keyword">global</span> num</span><br><span class="line">num = <span class="number">101</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><strong>局部变量</strong></h4><p>LOAD_FAST 一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。</p><p>STORE_FAST 一般用于保存值到局部变</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">0</span> LOAD_CONST <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_FAST <span class="number">0</span> (n)</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> LOAD_CONST <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">6</span> STORE_FAST <span class="number">1</span> (p)</span><br><span class="line"><span class="number">4</span> <span class="number">8</span> LOAD_FAST <span class="number">0</span> (n)</span><br><span class="line"><span class="number">10</span> LOAD_FAST <span class="number">1</span> (p)</span><br><span class="line"><span class="number">12</span> BINARY_ADD</span><br><span class="line"><span class="number">14</span> STORE_FAST <span class="number">0</span> (n)</span><br></pre></td></tr></table></figure><p>对应的 python 代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">p = <span class="number">0</span></span><br><span class="line">n = n + p</span><br></pre></td></tr></table></figure><p>函数的参数也算局部变量，如何区分出是函数参数还是其他局部变量呢？</p><p><strong>参数没有初始化语句</strong>，也就是从函数开始到 LOAD_FAST 该变量的位置，如果没有看到 STORE_FAST ，那么该变量就是函数参数。</p><p>而局部变量在使用之前肯定会使用 STORE_FAST 进行初始化。</p><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of &lt;code <span class="built_in">object</span> test at <span class="number">0x1A9F3E62240</span>, file <span class="string">&quot;test.py&quot;</span>, line <span class="number">1</span>&gt;:</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> LOAD_CONST <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_FAST <span class="number">1</span> (local)</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> LOAD_GLOBAL <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">6</span> LOAD_FAST <span class="number">1</span> (local)</span><br><span class="line"><span class="number">8</span> LOAD_FAST <span class="number">0</span> (arg1)</span><br><span class="line"><span class="number">10</span> CALL_FUNCTION <span class="number">2</span></span><br></pre></td></tr></table></figure><p>对应的 python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">arg1</span>):</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(local, arg1)</span><br></pre></td></tr></table></figure><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a><strong>常用数据类型</strong></h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h4><p>BUILD_LIST 用于创建一个 list。</p><p>例如</p><p>1 0 LOAD_CONST 0 (1)</p><p>2 LOAD_CONST 1 (2)</p><p>4 BUILD_LIST 2</p><p>6 STORE_NAME 0 (k)</p><p>对应 k &#x3D; [1, 2] 。</p><p>通过列表推导式（语法糖）构建列表：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (&lt;code <span class="built_in">object</span> &lt;listcomp&gt;&gt;)</span><br><span class="line"><span class="number">2</span> LOAD_CONST <span class="number">1</span> (<span class="string">&#x27;&lt;listcomp&gt;&#x27;</span>)</span><br><span class="line"><span class="number">4</span> MAKE_FUNCTION <span class="number">0</span></span><br><span class="line"><span class="number">6</span> LOAD_NAME <span class="number">0</span> (<span class="built_in">range</span>)</span><br><span class="line"><span class="number">8</span> LOAD_CONST <span class="number">2</span> (<span class="number">32</span>)</span><br><span class="line"><span class="number">10</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">12</span> GET_ITER</span><br><span class="line"><span class="number">14</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">16</span> STORE_NAME <span class="number">1</span> (a)</span><br><span class="line"><span class="number">18</span> LOAD_CONST <span class="number">3</span> (<span class="literal">None</span>)</span><br><span class="line"><span class="number">20</span> RETURN_VALUE</span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> &lt;listcomp&gt;&gt;:</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> BUILD_LIST <span class="number">0</span></span><br><span class="line"><span class="number">2</span> LOAD_FAST <span class="number">0</span> (<span class="number">.0</span>)</span><br><span class="line">&gt;&gt; <span class="number">4</span> FOR_ITER <span class="number">12</span> (to <span class="number">18</span>)</span><br><span class="line"><span class="number">6</span> STORE_FAST <span class="number">1</span> (i)</span><br><span class="line"><span class="number">8</span> LOAD_FAST <span class="number">1</span> (i)</span><br><span class="line"><span class="number">10</span> LOAD_CONST <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">12</span> BINARY_ADD</span><br><span class="line"><span class="number">14</span> LIST_APPEND <span class="number">2</span></span><br><span class="line"><span class="number">16</span> JUMP_ABSOLUTE <span class="number">4</span></span><br><span class="line">&gt;&gt; <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>对应语句 a &#x3D; [i+2 for i in range(32)]</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h4><p>BUILD_MAP 用于创建一个空的 dict。</p><p>STORE_MAP 用于初始化 dict 的内容。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span> BUILD_MAP <span class="number">1</span></span><br><span class="line"><span class="number">6</span> STORE_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">2</span> <span class="number">8</span> LOAD_CONST <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">10</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">12</span> LOAD_CONST <span class="number">0</span> (<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">14</span> STORE_SUBSCR</span><br></pre></td></tr></table></figure><p>分别对应 k &#x3D; {‘a’: 1} 和 k[‘a’] &#x3D; 2 。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a><strong>切片</strong></h4><p>BUILD_SLICE 用于创建切片。对于 list、tuple、字符串都可以使用切片的方式进行访问。</p><p>但是要注意 BUILD_SLICE 用于 [x:y:z] 这种类型的切片，结合 BINARY_SUBSCR 读取切片的值，结合</p><p>STORE_SUBSCR 用于修改切片的值。</p><p>例如</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">4</span> LOAD_CONST <span class="number">2</span> (<span class="number">3</span>)</span><br><span class="line"><span class="number">6</span> BUILD_LIST <span class="number">3</span></span><br><span class="line"><span class="number">8</span> STORE_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">2</span> <span class="number">10</span> LOAD_CONST <span class="number">3</span> (<span class="number">10</span>)</span><br><span class="line"><span class="number">12</span> BUILD_LIST <span class="number">1</span></span><br><span class="line"><span class="number">14</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">16</span> LOAD_CONST <span class="number">4</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">18</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">20</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">22</span> BUILD_SLICE <span class="number">3</span></span><br><span class="line"><span class="number">24</span> STORE_SUBSCR</span><br><span class="line"><span class="number">3</span> <span class="number">26</span> LOAD_CONST <span class="number">5</span> (<span class="number">11</span>)</span><br><span class="line"><span class="number">28</span> BUILD_LIST <span class="number">1</span></span><br><span class="line"><span class="number">30</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">32</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">34</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">36</span> BUILD_SLICE <span class="number">2</span></span><br><span class="line"><span class="number">38</span> STORE_SUBSCR</span><br><span class="line"><span class="number">4</span> <span class="number">40</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">42</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">44</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">46</span> BUILD_SLICE <span class="number">2</span></span><br><span class="line"><span class="number">48</span> BINARY_SUBSCR</span><br><span class="line"><span class="number">50</span> STORE_NAME <span class="number">1</span> (a)</span><br><span class="line"><span class="number">5</span> <span class="number">52</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">54</span> LOAD_CONST <span class="number">4</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">56</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">58</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">60</span> BUILD_SLICE <span class="number">3</span></span><br><span class="line"><span class="number">62</span> BINARY_SUBSCR</span><br><span class="line"><span class="number">64</span> STORE_NAME <span class="number">2</span> (b)</span><br></pre></td></tr></table></figure><p>对应 python 代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">k[<span class="number">0</span>:<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">10</span>]</span><br><span class="line">k[<span class="number">1</span>:<span class="number">2</span>] = [<span class="number">11</span>]</span><br><span class="line">a = k[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">b = k[<span class="number">0</span>:<span class="number">1</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a><strong>条件判断</strong></h3><p>以下指令一般用于分支判断跳转：</p><p>POP_JUMP_IF_FALSE ：表示条件结果为 FALSE 就跳转到目标偏移指令</p><p>JUMP_FORWARD ：直接跳转到目标偏移指令</p><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">6</span> LOAD_CONST <span class="number">1</span> (<span class="number">5</span>)</span><br><span class="line"><span class="number">8</span> COMPARE_OP <span class="number">0</span> (&lt;)</span><br><span class="line"><span class="number">10</span> POP_JUMP_IF_FALSE <span class="number">22</span></span><br><span class="line"><span class="number">3</span> <span class="number">12</span> LOAD_NAME <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">14</span> LOAD_CONST <span class="number">2</span> (<span class="string">&#x27;i &lt; 5&#x27;</span>)</span><br><span class="line"><span class="number">16</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">18</span> POP_TOP</span><br><span class="line"><span class="number">20</span> JUMP_FORWARD <span class="number">26</span> (to <span class="number">48</span>)</span><br><span class="line"><span class="number">4</span> &gt;&gt; <span class="number">22</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">24</span> LOAD_CONST <span class="number">1</span> (<span class="number">5</span>)</span><br><span class="line"><span class="number">26</span> COMPARE_OP <span class="number">4</span> (&gt;)</span><br><span class="line"><span class="number">28</span> POP_JUMP_IF_FALSE <span class="number">40</span></span><br><span class="line"><span class="number">5</span> <span class="number">30</span> LOAD_NAME <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">32</span> LOAD_CONST <span class="number">3</span> (<span class="string">&#x27;i &gt; 5&#x27;</span>)</span><br><span class="line"><span class="number">34</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">36</span> POP_TOP</span><br><span class="line"><span class="number">38</span> JUMP_FORWARD <span class="number">8</span> (to <span class="number">48</span>)</span><br><span class="line"><span class="number">7</span> &gt;&gt; <span class="number">40</span> LOAD_NAME <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">42</span> LOAD_CONST <span class="number">4</span> (<span class="string">&#x27;i = 5&#x27;</span>)</span><br><span class="line"><span class="number">44</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">46</span> POP_TOP</span><br></pre></td></tr></table></figure><p>对应 python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">5</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i &lt; 5&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> i &gt; <span class="number">5</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i &gt; 5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i = 5&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a><strong>循环</strong></h3><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><strong>while</strong> <strong>循环</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">2</span> &gt;&gt; <span class="number">4</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">6</span> LOAD_CONST <span class="number">1</span> (<span class="number">10</span>)</span><br><span class="line"><span class="number">8</span> COMPARE_OP <span class="number">0</span> (&lt;)</span><br><span class="line"><span class="number">10</span> POP_JUMP_IF_FALSE <span class="number">22</span></span><br><span class="line"><span class="number">3</span> <span class="number">12</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">14</span> LOAD_CONST <span class="number">2</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">16</span> INPLACE_ADD</span><br><span class="line"><span class="number">18</span> STORE_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">20</span> JUMP_ABSOLUTE <span class="number">4</span></span><br></pre></td></tr></table></figure><p>对应 python 代码：</p><p>i &#x3D; 0</p><p>while i &lt; 10:</p><p>i +&#x3D; 1</p><h4 id="for…in-结构"><a href="#for…in-结构" class="headerlink" title="for…in 结构"></a><strong>for…in</strong> <strong>结构</strong></h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204125219815.png" alt="image-20240204125219815"></p><p>对应 python 代码：</p><p>for i in range(10):</p><p>print(i ^ 3)</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><h4 id="函数范围"><a href="#函数范围" class="headerlink" title="函数范围"></a><strong>函数范围</strong></h4><p>前面介绍第二列表示指令在函数中的偏移地址，所以看到 0 就是函数开始，下一个 0 前一条指令就是函</p><p>数结束位置，当然也可以通过 RETURN_VALUE 来确定函数结尾。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a><strong>函数调用</strong></h4><p>函数调用类似于 push + call 的汇编结构，压栈参数从左到右依次压入（当然不是 push ，而是读取</p><p>指令 LOAD_xxxx 来指定参数）。</p><p>先指定要调用的函数（ LOAD_NAME 或 LOAD_GLOBAL ），然后压参数，最后通过 CALL_FUNCTION 调</p><p>用。</p><p>CALL_FUNCTION 后面的值表示有几个参数。</p><p>支持嵌套调用</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204125253249.png" alt="image-20240204125253249"></p><p>对应的 python 代码为：</p><p>n &#x3D; 100</p><p>root &#x3D; int(math.sqrt(n))</p><h2 id="pyc-加花混淆"><a href="#pyc-加花混淆" class="headerlink" title="pyc 加花混淆"></a><strong>pyc</strong> <strong>加花混淆</strong></h2><p>由上面的版块我们知道 pyc 是可以反编译的，而且目前也有现成的工具。但这些工具它会将每一个指令</p><p>都解析出来，所以字节码混淆的方式就是往里面插入一些恶意指令（比如加载超出范围的数据），让反</p><p>编译工具在解析的时候报错，从而失去作用。</p><p>但插入的恶意指令还不能影响解释器执行，因此还要插入一些跳转指令，从而让解释器跳过恶意指令。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204125318308.png" alt="image-20240204125318308"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204194442966.png" alt="image-20240204194442966"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204194452686.png" alt="image-20240204194452686"></p><h2 id="pyinstaller-应用"><a href="#pyinstaller-应用" class="headerlink" title="pyinstaller 应用"></a><strong>pyinstaller</strong> <strong>应用</strong></h2><h3 id="普通打包"><a href="#普通打包" class="headerlink" title="普通打包"></a><strong>普通打包</strong></h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200105807.png" alt="image-20240204200105807"></p><h4 id="exe逆向"><a href="#exe逆向" class="headerlink" title="exe逆向"></a>exe逆向</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200135481.png" alt="image-20240204200135481"></p><h4 id="elf逆向"><a href="#elf逆向" class="headerlink" title="elf逆向"></a>elf逆向</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200150021.png" alt="image-20240204200150021"></p><h3 id="使用-key-参数打包"><a href="#使用-key-参数打包" class="headerlink" title="使用 key 参数打包"></a><strong>使用</strong> <strong>key</strong> <strong>参数打包</strong></h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200214641.png" alt="image-20240204200214641"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200221556.png" alt="image-20240204200221556"></p><h4 id="version-lt-4-0"><a href="#version-lt-4-0" class="headerlink" title="version &lt; 4.0"></a><strong>version &lt; 4.0</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For pyinstaller &lt; 4.0</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">CRYPT_BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="comment"># key obtained from pyimod00_crypto_key</span></span><br><span class="line">key = <span class="string">&#x27;this_is_a_secret&#x27;</span></span><br><span class="line">inf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc.encrypted&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="comment"># encrypted file input</span></span><br><span class="line">outf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="comment"># output file</span></span><br><span class="line"><span class="comment"># Initialization vector</span></span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv)</span><br><span class="line"><span class="comment"># Decrypt and decompress</span></span><br><span class="line">plaintext = zlib.decompress(cipher.decrypt(inf.read()))</span><br><span class="line"><span class="comment"># Write pyc header</span></span><br><span class="line"><span class="comment"># The header below is for Python 2.7</span></span><br><span class="line">outf.write(<span class="string">&#x27;\x03\xf3\x0d\x0a\0\0\0\0&#x27;</span>)</span><br><span class="line"><span class="comment"># Write decrypted data</span></span><br><span class="line">outf.write(plaintext)</span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br></pre></td></tr></table></figure><h4 id="version-gt-x3D-4-0"><a href="#version-gt-x3D-4-0" class="headerlink" title="version &gt;&#x3D; 4.0"></a><strong>version &gt;&#x3D; 4.0</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For pyinstaller &gt;= 4.0</span></span><br><span class="line"><span class="keyword">import</span> tinyaes</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">CRYPT_BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="comment"># key obtained from pyimod00_crypto_key</span></span><br><span class="line">key = <span class="built_in">bytes</span>(<span class="string">&#x27;this_is_a_secret&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">inf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc.encrypted&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="comment"># encrypted file input</span></span><br><span class="line">outf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="comment"># output file</span></span><br><span class="line"><span class="comment"># Initialization vector</span></span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line">cipher = tinyaes.AES(key, iv)</span><br><span class="line"><span class="comment"># Decrypt and decompress</span></span><br><span class="line">plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))</span><br><span class="line"><span class="comment"># Write pyc header</span></span><br><span class="line"><span class="comment"># The header below is for Python 3.8</span></span><br><span class="line">outf.write(<span class="string">b&#x27;\x55\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0&#x27;</span>)</span><br><span class="line"><span class="comment"># Write decrypted data</span></span><br><span class="line">outf.write(plaintext)</span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br></pre></td></tr></table></figure><p>反编译 pyimod02_archive.pyc ：</p><p>pyinstaller &lt; 4.0 &#x3D;&gt; pycrypto &amp; CFB</p><p>pyinstaller &gt;&#x3D; 4.0 &#x3D;&gt; tinyaes &amp; CTR</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python逆向&quot;&gt;&lt;a href=&quot;#Python逆向&quot; class=&quot;headerlink&quot; title=&quot;Python逆向&quot;&gt;&lt;/a&gt;Python逆向&lt;/h1&gt;&lt;h2 id=&quot;pyc文件&quot;&gt;&lt;a href=&quot;#pyc文件&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="python 逆向" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/python-%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/03/MFC%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/03/MFC%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</id>
    <published>2024-02-03T03:42:48.110Z</published>
    <updated>2024-02-04T04:24:55.708Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="MFC图形化界面"><a href="#MFC图形化界面" class="headerlink" title="MFC图形化界面"></a>MFC图形化界面</h1><h2 id="windows桌面应用编程"><a href="#windows桌面应用编程" class="headerlink" title="windows桌面应用编程"></a>windows桌面应用编程</h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202804698.png" alt="image-20240203202804698"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202813056.png" alt="image-20240203202813056"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202823482.png" alt="image-20240203202823482"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202851227.png" alt="image-20240203202851227"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202903575.png" alt="image-20240203202903575"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202911473.png" alt="image-20240203202911473"></p><h2 id="MFC-正向开发"><a href="#MFC-正向开发" class="headerlink" title="MFC 正向开发"></a><strong>MFC</strong> <strong>正向开发</strong></h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202925910.png" alt="image-20240203202925910"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202934106.png" alt="image-20240203202934106"></p><h2 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a><strong>逆向思路</strong></h2><ul><li><p>通过 ResourceHacker 可以获取控件的 ID 号、修改控件布局等</p></li><li><p>通过 xspy 可以获取控件消息所对应的处理函数地址</p></li><li><p>通过 GetDlgItem &#x2F; GetDlgItemText &#x2F; GetDlgItemInt &#x2F; GetWindowText 系列 API 找到关键函数</p></li></ul><p>找到关键函数后，即为常规逆向</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MFC图形化界面&quot;&gt;&lt;a href=&quot;#MFC图形化界面&quot; class=&quot;headerlink&quot; title=&quot;MFC图形化界面&quot;&gt;&lt;/a&gt;MFC图形化界面&lt;/h1&gt;&lt;h2 id=&quot;windows桌面应用编程&quot;&gt;&lt;a href=&quot;#window</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IDAPython常用函数</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/01/IDAPython%E4%B8%8Eelf%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/01/IDAPython%E4%B8%8Eelf%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-03T12:27:33.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDAPython常用函数"><a href="#IDAPython常用函数" class="headerlink" title="IDAPython常用函数"></a>IDAPython常用函数</h1><p><a href="https://hex-rays.com/products/ida/support/idapython_docs/">官方文档</a></p><h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><ul><li>here() &#x2F; get_screen_ea()：返回光标当前所在地址</li><li>get_inf_attr(INF_MIN_EA) &#x2F; get_inf_attr(INF_MAX_EA)：获得最小 &#x2F; 最大地址</li><li>generate_disasm_line(ea, GENDSM_FORCE_CODE)：获得 ea 所在处的一条汇编指令</li><li>print_insn_mnem(ea)：获得 ea 所在处的指令助记符</li><li>print_operand(ea, n)：获取 ea 所在处的第 n 个操作数</li></ul><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><ul><li>Segments()：返回段的可遍历对象</li><li>get_segm_name(ea)：获得 ea 所在段名</li><li>get_next_seg(ea)：获取下一个段</li><li>get_segm_start(ea) &#x2F; get_segm_end(ea)：获取段开始 &#x2F; 结束地址</li></ul><p>for seg in Segments():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;&#123;get_segm_name(seg)&#125;, &#123;get_segm_start(seg)&#125;, &#123;get_segm_end(seg)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Functions() &#x2F; Funtions(start_addr, end_addr)：返回函数的可遍历对象</p><p>get_func_name(ea)：返回函数名称</p><p>idaapi.get_func(ea)：获得解析后的函数对象</p><p>get_func_attr(ea, FUNCATTR_START) &#x2F; get_func_attr(ea, FUNCATTR_END)：访问函数边界</p><p>get_next_func(ea) &#x2F; get_prev_func(ea)：获取上 &#x2F; 下一个函数</p><p>prev_head(ea) &#x2F; next_head(ea)：获得上 &#x2F; 下一条指令地址</p><p>FuncItems(ea)：获取 ea 所处函数的所有指令地址</p><p>eg:打印一个函数的反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ea = here()</span><br><span class="line">now = get_func_attr(ea, FUNCATTR_START)</span><br><span class="line">end = get_func_attr(ea, FUNCATTR_END)</span><br><span class="line">while now &lt; end:</span><br><span class="line">print(f&quot;0x&#123;now&#125; &#123;generate_disasm_line(now, 0)&#125;&quot;)</span><br><span class="line">now = next_head(now)</span><br></pre></td></tr></table></figure><p>使用 FuncItems 来完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ea in FuncItems(here()):</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>idaapi.decode_insn(out, ea)：解析指令并填充 out (insn_t 结构体)</p><p>ida_ua.insn_t()：new 一个 insn_t 结构体</p><p>例：找到函数中所有的跳转指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ea in FuncItems(here()):</span><br><span class="line">asm = generate_disasm_line(ea, 0)</span><br><span class="line">if &quot;jmp&quot; in asm:</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><p>另一种实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMPS = [idaapi.NN_jmp, idaapi.NN_jmpfi, idaapi.NN_jmpni]</span><br><span class="line">for ea in FuncItems(here()):</span><br><span class="line">ins = ida_ua.insn_t()</span><br><span class="line">idaapi.decode_insn(ins, ea)</span><br><span class="line">if ins.itype in JMPS:</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a><strong>操作数</strong></h2><p>可以使用 get_operand_type(ea, n) 得到操作数的类型。get_operand_value(ea, n) 来得到操作数的值。ea 是地址，n 是索引。</p><p>这里有 8 中不同类型的操作数类型。</p><p><strong>o_void</strong> 如果一个指令没有任何操作数它将返回 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa09166 retn</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure><p><strong>o_reg</strong> 如果一个操作数是一个普遍的寄存器将返回此类型。这个值在内部表示为 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa09163 pop edi</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure><p><strong>o_mem</strong> 如果一个操作数是直接内存引用它将返回这个类型。这个值在内部表示为 2。这种类型是有用的在 DATA 段查找引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05d86 cmp ds:dword_A152B8, 0</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure><p><strong>o_phrase</strong> 这个操作数被返回则这个操作数包含一个基本的寄存器或一个索引寄存器。这个值在内部表示为 3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0x1000b8c2 mov [edi+ecx], eax</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure><p><strong>o_displ</strong> 这个操作数被返回则操作数包含寄存器和一个位移值，这个为位移值是一个整数，例如 0x18。</p><p>这是常见的当一条指令访问值在一个结构中。在内部，它表示为 4 的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05dc1 mov eax, [edi+18h]</span><br><span class="line">Python&gt;print(get_operand_type(ea,1))</span><br><span class="line">&gt;&gt;&gt; 4</span><br></pre></td></tr></table></figure><p><strong>o_imm</strong> 操作数是这样一个为整数的 0xc 的值的类型。它在内部表示为 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05da1 add esp, 0Ch</span><br><span class="line">Python&gt;print(get_operand_type(ea,1))</span><br><span class="line">&gt;&gt;&gt; 5</span><br></pre></td></tr></table></figure><p><strong>o_far</strong> 是用来寻找操作数的访问立即数远地址的。它在内部表示为 6。</p><p><strong>o_near</strong> 是用来寻找操作数的访问立即数近地址的。它在内部表示为 7。</p><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><ul><li>get_bytes(ea, size)</li><li>ida_bytes.get_byte(ea)</li><li>ida_bytes.get_word(ea)</li><li>ida_bytes.get_dword(ea)</li><li>ida_bytes.get_qword(ea)</li><li>ida_bytes.patch_bytes(ea, buf)</li><li>ida_bytes.patch_byte(ea, val)</li><li>ida_bytes.patch_word(ea, val)</li><li>ida_bytes.patch_dword(ea, val)</li><li>ida_bytes.patch_qword(ea, val)</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>add_bpt(ea)：添加断点</li><li>del_bpt(ea)：删除断点</li><li>start_process(path, args, sdir)：启动调试</li><li>step_into()：步入</li><li>step_over()：步过</li><li>step_until_ret()：执行到返回</li><li>get_reg_value(regname)：获取寄存器值</li><li>set_reg_value(value, regname)：设置寄存器值</li><li>wait_for_next_event(wfne, timeout)：等待调试事件，第一个参数一般取为 WFNE_SUSP</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">addr= <span class="number">0x401198</span></span><br><span class="line">end = get_func_attr(addr,FUNCATTR_END)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> addr&lt;end:</span><br><span class="line">    next_ins=next_head(addr)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;dword_603054&quot;</span> <span class="keyword">in</span> generate_disasm_line(addr,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            addr = next_dead(addr)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;jnz&quot;</span> <span class="keyword">in</span> generate_disasm_line(addr,<span class="number">0</span>):</span><br><span class="line">                dest = get _operand_value(addr,<span class="number">0</span>)</span><br><span class="line">                offset = dest-(addr+<span class="number">5</span>)</span><br><span class="line">                <span class="built_in">print</span>(offset)</span><br><span class="line">                </span><br><span class="line">                ida_bytes.patch_byte(addr,<span class="number">0xE9</span>)</span><br><span class="line">                addr = next_ins</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                addr=next_ins</span><br></pre></td></tr></table></figure><h1 id="ELF-运行流程"><a href="#ELF-运行流程" class="headerlink" title="ELF 运行流程"></a><strong>ELF</strong> 运行流程</h1><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223812328.png" alt="image-20240201223812328"></p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223823579.png" alt="image-20240201223823579"></p><h2 id="基本操作说明"><a href="#基本操作说明" class="headerlink" title="基本操作说明"></a><strong>基本操作说明</strong></h2><h3 id="sys-execve"><a href="#sys-execve" class="headerlink" title="sys_execve"></a><strong>sys_execve</strong></h3><p>该函数主要用于执行一个新的程序，即执行我们想要执行的程序，会检查相应的 argv 以及 envp 等参</p><p>数。</p><h3 id="do-execve"><a href="#do-execve" class="headerlink" title="do_execve"></a><strong>do_execve</strong></h3><p>该函数打开目标映像文件，并从目标文件的开始处读入指定长度的（目前为128）字节来获取相应目标</p><p>文件的基本信息。</p><h3 id="search-binary-handler"><a href="#search-binary-handler" class="headerlink" title="search_binary_handler"></a><strong>search_binary_handler</strong></h3><p>该函数会搜索支持处理当前类型的二进制文件类型队列，以便于让各种可执行程序的处理程序进行相应</p><p>的处理。</p><h3 id="load-elf-binary"><a href="#load-elf-binary" class="headerlink" title="load_elf_binary"></a><strong>load_elf_binary</strong></h3><p>该函数的主要处理流程如下</p><ul><li><p>-检查并获取 elf 文件的头部信息</p></li><li><p>如果目标文件采用动态链接，则使用 .interp 节来确定 loader 的路径。</p></li><li><p>将 program header 中记录的相应的段映射到内存中。program header 中有以下重要信息</p><ul><li>每一个段需要映射到的地址</li><li>每一个段相应的权限</li><li>记录哪些节属于哪些段</li></ul></li></ul><p>具体的映射如下</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223854316.png" alt="image-20240201223854316"></p><p>分情况处理</p><ul><li><p>动态链接情况下，将 sys_execve 的返回地址改为 loader(ld.so) 的 entry point</p></li><li><p>静态链接情况下，将 sys_execve 的返回地址改为程序的入口点</p></li></ul><h3 id="ld-so"><a href="#ld-so" class="headerlink" title="ld.so"></a><strong>ld.so</strong></h3><p>该文件有以下功能</p><ul><li>主要用于载入 ELF 文件中 DT_NEED 中记录的共享库</li><li>初始化工作</li><li>初始化 GOT 表</li><li>将 symbol table 合并到 global symbol table</li></ul><h3 id="start"><a href="#start" class="headerlink" title="_start"></a><strong>_start</strong></h3><ul><li>_start 函数会将以下项目交给 libc_start_main</li><li>环境变量起始地址</li><li>.init</li><li>启动 main 函数前的初始化工作</li><li>.fini</li><li>程序结束前的收尾工作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDAPython常用函数&quot;&gt;&lt;a href=&quot;#IDAPython常用函数&quot; class=&quot;headerlink&quot; title=&quot;IDAPython常用函数&quot;&gt;&lt;/a&gt;IDAPython常用函数&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hex-rays.</summary>
      
    
    
    
    
    <category term="IDA Python" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>最近打的一些比赛</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/31/%E6%9C%80%E8%BF%91%E6%89%93%E6%AF%94%E8%B5%9B%E7%9A%84%E4%B8%80%E4%BA%9Bwriteup/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/31/%E6%9C%80%E8%BF%91%E6%89%93%E6%AF%94%E8%B5%9B%E7%9A%84%E4%B8%80%E4%BA%9Bwriteup/</id>
    <published>2024-01-30T16:00:00.000Z</published>
    <updated>2024-02-04T11:58:25.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HGAME-20240129"><a href="#HGAME-20240129" class="headerlink" title="HGAME 20240129"></a>HGAME 20240129</h1><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>日常关注微信号–flag</p><h3 id="SignIn"><a href="#SignIn" class="headerlink" title="SignIn"></a>SignIn</h3><p>侧着看着图片w（经典</p><h3 id="simple——attack"><a href="#simple——attack" class="headerlink" title="simple——attack"></a>simple——attack</h3><p>明文爆破zip</p><h3 id="来自星尘的问候"><a href="#来自星尘的问候" class="headerlink" title="来自星尘的问候"></a>来自星尘的问候</h3><p>六位弱加密</p><h3 id="希儿希儿希尔"><a href="#希儿希儿希尔" class="headerlink" title="希儿希儿希尔"></a>希儿希儿希尔</h3><p>希尔加密，但是图片怎么修复？</p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="ezIDA"><a href="#ezIDA" class="headerlink" title="ezIDA"></a>ezIDA</h3><p>打开IDA就是</p><h3 id="ezUPX"><a href="#ezUPX" class="headerlink" title="ezUPX"></a>ezUPX</h3><p>UPX脱壳，看伪代码，</p><p>flag xor 0x32 后为一个数组</p><p>写入010editor，转换一下就出来了</p><p>（一定要抄对（（别抄，直接shift e导出（（</p><h3 id="ezASM"><a href="#ezASM" class="headerlink" title="ezASM"></a>ezASM</h3><p>根据汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">    c = [74, 69, 67, 79, 71, 89, 99, 113, 111, 125, 107, 81, 125, 107, 79, 82, 18, 80, 86, 22, 76, 86, 125, 22, 125, 112, 71, 84, 17, 80, 81, 17, 95, 34]</span><br><span class="line">    flag = [0, 0, ..., 0]  # 33 elements initialized to 0</span><br><span class="line">    format = &quot;plz input your flag: &quot;</span><br><span class="line">    success = &quot;Congratulations!&quot;</span><br><span class="line">    failure = &quot;Sry, plz try again&quot;</span><br><span class="line"></span><br><span class="line">text:</span><br><span class="line">    function check_flag():</span><br><span class="line">        esi = 0</span><br><span class="line">        while esi &lt; 33:</span><br><span class="line">            temp = flag[esi] XOR 0x22</span><br><span class="line">            if temp != c[esi]:</span><br><span class="line">                return false</span><br><span class="line">            esi += 1</span><br><span class="line">        return true</span><br><span class="line"></span><br><span class="line">    procedure _start():</span><br><span class="line">        # Print prompt</span><br><span class="line">        system_call(4, 1, format, 20)</span><br><span class="line"></span><br><span class="line">        # Read user input</span><br><span class="line">        system_call(3, 0, flag, 33)</span><br><span class="line"></span><br><span class="line">        # Check flag</span><br><span class="line">        if check_flag():</span><br><span class="line">            # Print success message</span><br><span class="line">            system_call(4, 1, success, 14)</span><br><span class="line">        else:</span><br><span class="line">            # Print failure message</span><br><span class="line">            system_call(4, 1, failure, 18)</span><br><span class="line"></span><br><span class="line">        # Exit</span><br><span class="line">        system_call(1, 0, 0)</span><br><span class="line"></span><br><span class="line">    function system_call(eax, ebx, ecx, edx):</span><br><span class="line">        # Simulate system call</span><br><span class="line">        # This function depends on the specific system&#x27;s calling convention</span><br><span class="line">        # and how system calls are made (e.g., int 0x80 in this case).</span><br><span class="line"></span><br><span class="line">    # Entry point</span><br><span class="line">    _start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写脚本出</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_with_0x22</span>(<span class="params">byte_array</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> byte_array:</span><br><span class="line">       hex_value = <span class="built_in">hex</span>(byte)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">       xor_result = <span class="built_in">hex</span>(byte ^ <span class="number">0x22</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">       result.append((hex_value, xor_result))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">byte_array = [<span class="number">74</span>, <span class="number">69</span>, <span class="number">67</span>, <span class="number">79</span>, <span class="number">71</span>, <span class="number">89</span>, <span class="number">99</span>, <span class="number">113</span>, <span class="number">111</span>, <span class="number">125</span>, <span class="number">107</span>, <span class="number">81</span>, <span class="number">125</span>, <span class="number">107</span>, <span class="number">79</span>, <span class="number">82</span>, <span class="number">18</span>, <span class="number">80</span>, <span class="number">86</span>, <span class="number">22</span>, <span class="number">76</span>, <span class="number">86</span>, <span class="number">125</span>, <span class="number">22</span>, <span class="number">125</span>, <span class="number">112</span>, <span class="number">71</span>, <span class="number">84</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">17</span>, <span class="number">95</span>, <span class="number">34</span>]</span><br><span class="line"></span><br><span class="line">result = xor_with_0x22(byte_array)</span><br><span class="line"><span class="keyword">for</span> hex_value, xor_result <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;hex_value&#125;</span> XOR 0x22 = <span class="subst">&#123;xor_result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ezPYC"><a href="#ezPYC" class="headerlink" title="ezPYC"></a>ezPYC</h3><p>感觉是控制流平坦化后的程序。没做出来</p><p>怀疑是python deflat.py -f ezPYC.exe –addr 0x140008F41 留一下</p><p>哈哈，不是，就是普通pyc</p><p>刚学了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 3.8</span></span><br><span class="line"></span><br><span class="line">flag = [</span><br><span class="line">    <span class="number">87</span>,</span><br><span class="line">    <span class="number">75</span>,</span><br><span class="line">    <span class="number">71</span>,</span><br><span class="line">    <span class="number">69</span>,</span><br><span class="line">    <span class="number">83</span>,</span><br><span class="line">    <span class="number">121</span>,</span><br><span class="line">    <span class="number">83</span>,</span><br><span class="line">    <span class="number">125</span>,</span><br><span class="line">    <span class="number">117</span>,</span><br><span class="line">    <span class="number">106</span>,</span><br><span class="line">    <span class="number">108</span>,</span><br><span class="line">    <span class="number">106</span>,</span><br><span class="line">    <span class="number">94</span>,</span><br><span class="line">    <span class="number">80</span>,</span><br><span class="line">    <span class="number">48</span>,</span><br><span class="line">    <span class="number">114</span>,</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">55</span>,</span><br><span class="line">    <span class="number">94</span>,</span><br><span class="line">    <span class="number">51</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">91</span>,</span><br><span class="line">    <span class="number">48</span>,</span><br><span class="line">    <span class="number">108</span>,</span><br><span class="line">    <span class="number">119</span>,</span><br><span class="line">    <span class="number">97</span>,</span><br><span class="line">    <span class="number">115</span>,</span><br><span class="line">    <span class="number">49</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">48</span>,</span><br><span class="line">    <span class="number">108</span>,</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    <span class="number">37</span>,</span><br><span class="line">    <span class="number">124</span>,</span><br><span class="line">    <span class="number">2</span>]</span><br><span class="line">c = [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>]</span><br><span class="line">input_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">36</span>, <span class="number">1</span>):</span><br><span class="line">    input_str += <span class="built_in">chr</span>(c[i % <span class="number">4</span>] ^ flag[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(input_str)</span><br></pre></td></tr></table></figure><h1 id="BeginCTF-20240131"><a href="#BeginCTF-20240131" class="headerlink" title="BeginCTF 20240131"></a>BeginCTF 20240131</h1><h2 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h2><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MJSWO2LOPNLUKTCDJ5GWKX3UN5PUEM2HNFXEGVCGL4ZDAMRUL5EDAUDFL5MU6VK7O5UUYMK7GEYWWZK7NE3X2===</span><br></pre></td></tr></table></figure><p>base32</p><h3 id="tupper"><a href="#tupper" class="headerlink" title="tupper"></a>tupper</h3><p>脚本把所有文件信息提取</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_text_from_zip</span>(<span class="params">zip_path, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(zip_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> output_txt:</span><br><span class="line">            <span class="keyword">for</span> file_info <span class="keyword">in</span> zip_ref.infolist():</span><br><span class="line">                <span class="keyword">if</span> file_info.filename.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">                    <span class="keyword">with</span> zip_ref.<span class="built_in">open</span>(file_info) <span class="keyword">as</span> file:</span><br><span class="line">                        text = file.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                        output_txt.write(text)</span><br><span class="line">                        <span class="comment">#output_txt.write(&#x27;\n\n&#x27;)  # 可以根据需要增加分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    desktop_path = os.path.join(os.path.expanduser(<span class="string">&quot;~&quot;</span>), <span class="string">&quot;Desktop&quot;</span>)  <span class="comment"># 桌面路径，根据实际情况修改</span></span><br><span class="line">    zip_file_path = os.path.join(desktop_path, <span class="string">&quot;tupper.zip&quot;</span>)  <span class="comment"># 压缩包路径，根据实际情况修改</span></span><br><span class="line">    output_file_path = os.path.join(desktop_path, <span class="string">&quot;output.txt&quot;</span>)  <span class="comment"># 输出文件路径，根据实际情况修改</span></span><br><span class="line"></span><br><span class="line">    extract_text_from_zip(zip_file_path, output_file_path)</span><br></pre></td></tr></table></figure><p>看题目是tupper，说不定是个加密方式，一搜，哈真是</p><p><a href="http://t.csdnimg.cn/OF1OP">代码急转弯——Tupper（塔珀自指公式）</a></p><p><a href="https://tuppers-formula.ovh/">https://tuppers-formula.ovh/</a></p><p>上面output.txt内容–&gt;bese64–&gt;k–&gt;flag</p><h3 id="where-is-crazyman-v1-0"><a href="#where-is-crazyman-v1-0" class="headerlink" title="where is crazyman v1.0"></a>where is crazyman v1.0</h3><p>google识图</p><h3 id="devil’s-word"><a href="#devil’s-word" class="headerlink" title="devil’s word"></a>devil’s word</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leu lia leu ng leu cai leu jau leu e cai b cai jau sa leng cai ng ng f leu b leu e sa leng cai cai ng f cai cai sa sa leu e cai a leu bo leu f cai ng ng f leu sii leu jau sa sii leu c leu ng leu sa cai sii cai d</span><br></pre></td></tr></table></figure><p>我的解密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">leu lia 62 </span><br><span class="line">leu ng 65</span><br><span class="line">leu cai 67</span><br><span class="line">leu jau 69</span><br><span class="line">leu e 61</span><br><span class="line">cai b 78</span><br><span class="line">cai jau 79</span><br><span class="line">sa leng 32</span><br><span class="line">cai ng 75</span><br><span class="line">ng f 58</span><br><span class="line">leu b 68</span><br><span class="line">leu e 65</span><br><span class="line">sa leng 32</span><br><span class="line">cai cai 77</span><br><span class="line">ng f 58</span><br><span class="line">cai cai 77</span><br><span class="line">sa sa 33</span><br><span class="line">leu e 61</span><br><span class="line">cai a 71</span><br><span class="line">leu bo 68</span><br><span class="line">leu f 68</span><br><span class="line">cai ng 75</span><br><span class="line">ng f 58</span><br><span class="line">leu sii 64</span><br><span class="line">leu jau 69</span><br><span class="line">sa sii 34</span><br><span class="line">leu c 67</span><br><span class="line">leu ng 65</span><br><span class="line">leu sa 63</span><br><span class="line">cai sii 74</span><br><span class="line">cai d 76</span><br></pre></td></tr></table></figure><h2 id="RE-1"><a href="#RE-1" class="headerlink" title="RE"></a>RE</h2><h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><p>agh{^bvuwTooahlYocPtmyiijj|ek</p><p>63290794207715587679621386735000</p><p>反调试</p><h3 id="real-checkin-xor"><a href="#real-checkin-xor" class="headerlink" title="real checkin xor"></a>real checkin xor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def decrypt_func(encrypted, key):</span><br><span class="line">    decrypted = []</span><br><span class="line">    for i in range(len(encrypted)):</span><br><span class="line">        decrypted.append(chr(encrypted[i] ^ ord(key[i % len(key)])))</span><br><span class="line">    return &#x27;&#x27;.join(decrypted)</span><br><span class="line"></span><br><span class="line">key = &quot;ez_python_xor_reverse&quot;</span><br><span class="line">ciper = [7, 31, 56, 25, 23, 15, 91, 21, 49, 15, 33, 88, 26, 48, 60, 58, 4, 86, 36, 64, 23, 54, 63, 0, 54, 22, 6, 55, 59, 38, 108, 39, 45, 23, 102, 27, 11, 56, 32, 0, 82, 24]</span><br><span class="line"></span><br><span class="line">decrypted_text = decrypt_func(ciper, key)</span><br><span class="line">print(&quot;解密后的文本:&quot;, decrypted_text)</span><br></pre></td></tr></table></figure><h2 id="Forensics"><a href="#Forensics" class="headerlink" title="Forensics"></a>Forensics</h2><h3 id="逆向工程-reverse-入门指南"><a href="#逆向工程-reverse-入门指南" class="headerlink" title="逆向工程(reverse)入门指南"></a>逆向工程(reverse)入门指南</h3><p>pdf隐写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HGAME-20240129&quot;&gt;&lt;a href=&quot;#HGAME-20240129&quot; class=&quot;headerlink&quot; title=&quot;HGAME 20240129&quot;&gt;&lt;/a&gt;HGAME 20240129&lt;/h1&gt;&lt;h2 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#M</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>OLLVM</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/24/ollvm!/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/24/ollvm!/</id>
    <published>2024-01-23T16:00:00.000Z</published>
    <updated>2024-02-02T12:15:29.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OLLVM"><a href="#OLLVM" class="headerlink" title="OLLVM"></a>OLLVM</h1><p>LLVM 是一个<strong>开源的编译器架构</strong>，利用虚拟技术对源代码提供现代化的、与目标无关的、针对多种 CPU的，代码优化和代码生成功能。</p><p>LLVM 核心库提供了与编译器相关的支持，可以作为多种语言编译器的后台来使用，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。</p><p>LLVM 三段式架构：</p><ul><li><p>前端：解析源代码，由语法分析器和语义分析协同工作，检查语法错误，并构建语言的抽象语法树来表示输入代码， 然后将分析好的代码转化为 LLVM 的中间表示 IR (IntermediateRepresentation) 。</p></li><li><p>优化器：通过一系列的 Pass 对中间代码 IR 进行优化， 改善代码的运行时间使代码更高效。</p></li><li><p>后端：负责将优化器优化后的中间代码 IR 转换为目标机器的代码</p></li></ul><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130149036.png" alt="image-20240124130149036"></p><p><strong>OLLVM(Obfuscator-LLVM)</strong> 是瑞士西部应用科学大学安全小组于 2010 年 6 月发起的一个项目。该项目的目的是提供一套开源的<strong>基于****LLVM</strong>的代码混淆工具，通过代码混淆和防篡改提供更高的软件安全</p><p>性。</p><p>OLLVM 工作在 LLVM IR 中间表示层，通过<strong>编写<strong><strong>Pass</strong></strong>来混淆****IR</strong>， 后端依照 IR 转换的目标机器的代码也就达到了混淆的目的。</p><p>OLLVM 提供了三种混淆模式：</p><ul><li><p>指令替换 (Instructions Substitution)</p></li><li><p>虚假控制流 (BogusControl Flow)</p></li><li><p>控制流平坦化 (Control Flow Flattening)</p></li></ul><h2 id="正向使用"><a href="#正向使用" class="headerlink" title="正向使用"></a><strong>正向使用</strong></h2><h4 id="编译-ollvm"><a href="#编译-ollvm" class="headerlink" title="编译 ollvm"></a><strong>编译</strong> <strong>ollvm</strong></h4><p>编译环境为 ubuntu 20.04，先下载 ollvm 源码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b llvm-<span class="number">4</span>.<span class="number">0</span> https://github.com/obfuscator-llvm/obfuscator.git</span><br></pre></td></tr></table></figure><p>然后修改 <code>obfuscator/include/llvm/ExecutionEngine/Orc/OrcRemoteTargetClient.h</code> 文件第690 行，将 <code>Expected&lt;std::vector&lt;uint8_t&gt;&gt;</code> 改为<code>Expected&lt;std::vector&lt;unsigned char&gt;&gt;</code></p><p>接着降低 gcc 版本，执行如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-<span class="number">8</span> g++-<span class="number">8</span> -y</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-<span class="number">8</span> <span class="number">8</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-<span class="number">8</span> <span class="number">8</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-<span class="number">9</span> <span class="number">9</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-<span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>切换 gcc 与 g++ 的默认版本</p><p>sudo update-alternatives –config gcc</p><p>sudo update-alternatives –config g++</p><p>在 obfuscator 目录下执行如下命令，开始编译：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../</span><br><span class="line">make -j7</span><br></pre></td></tr></table></figure><p>编译完成后，在 obfuscator&#x2F;build&#x2F;bin 目录下会产生很多可执行文件，将这个路径添加到环境变量即可。</p><h3 id="使用-ollvm"><a href="#使用-ollvm" class="headerlink" title="使用 ollvm"></a><strong>使用</strong> <strong>ollvm</strong></h3><h4 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a><strong>指令替换</strong></h4><p>通过功能上等价的但更复杂的指令序列， 替换标准二元运算符（如加法、 减法或布尔运算符）， 当有</p><p>多个可用的等效指令序列时， 随机选择一个。</p><p>编译选项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -sub: 激活指令替代</span><br><span class="line">-mllvm -sub_loop=<span class="number">3</span>: 混淆次数，一个函数会被混淆<span class="number">3</span>次，默认为<span class="number">1</span>次</span><br></pre></td></tr></table></figure><p>混淆前后对比</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130430375.png" alt="image-20240124130430375"></p><h5 id="指令转换："><a href="#指令转换：" class="headerlink" title="指令转换："></a>指令转换：</h5><p>Addition</p><ul><li><p><code>a = b - (-c)</code></p></li><li><pre><code>r = rand (); a = b - r; a = a + b; a = a + r<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  r = rand (); a = b + r; a = a + c; a = a - r</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>a = -(-b + (-c))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Subtraction</span><br><span class="line"></span><br><span class="line">- `a = b + (-c)`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  r = rand (); a = b - r; a = a - c; a = a + r</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>r = rand (); a = b + r; a = a - c; a = a - r</code></pre></li></ul><p>AND</p><ul><li><code>a = b &amp; c</code> &#x3D;&gt; <code>a = (b ^ ~c) &amp; b</code></li></ul><p>OR</p><ul><li><code>a = b | c</code> &#x3D;&gt; <code>a = (b &amp; c) | (b ^ c)</code></li></ul><p>XOR</p><ul><li><code>a = a ^ b</code> &#x3D;&gt; <code>a = (~a &amp; b) | (a &amp; ~b)</code></li></ul><h4 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a><strong>虚假控制流</strong></h4><p>通过在当前基本块之前添加基本块来修改程序的控制流图，原始的基本块也会被克隆，并插入随机的垃圾指令。</p><p>编译选项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -bcf: 激活虚假控制流</span><br><span class="line">-mllvm -bcf_loop=<span class="number">3</span>: 混淆次数，一个函数会被混淆<span class="number">3</span>次，默认为<span class="number">1</span></span><br><span class="line">-mllvm -bcf_prob=<span class="number">40</span>: 每个基本块被混淆的概率，当前每个基本块被混淆的概率为<span class="number">40</span><span class="variable">%，默认为30%</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130457258.png" alt="image-20240124130457258"></p><h4 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a><strong>控制流平坦化</strong></h4><p>消除正常程序控制流中基本块的相互关联，使用一个集中的主分发块来调度基本块的执行顺序，得到一</p><p>个循环嵌套Switch的执行逻辑。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130521676.png" alt="image-20240124130521676"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130535132.png" alt="image-20240124130535132"></p><p>序言：函数的第一个执行的基本块主(子)分发器：控制程序跳转到下一个待执行的基本块</p><p>retn块：函数出口</p><p>真实块：混淆前的基本块，程序真正执行工作的版块</p><p>预处理器：跳转到主分发器</p><p>编译选项：</p><p><a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening">https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -fla: 激活控制流平坦化</span><br><span class="line">-mllvm -split: 激活基本块分割</span><br><span class="line">-mllvm -split_num=<span class="number">3</span>: 指定基本块分割的数目</span><br></pre></td></tr></table></figure><p><a href="http://t.csdnimg.cn/FaGnP">angr安装</a></p><p>关于angr的一些题目：<a href="https://www.cnblogs.com/level5uiharu/p/16925991.html">https://www.cnblogs.com/level5uiharu/p/16925991.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OLLVM&quot;&gt;&lt;a href=&quot;#OLLVM&quot; class=&quot;headerlink&quot; title=&quot;OLLVM&quot;&gt;&lt;/a&gt;OLLVM&lt;/h1&gt;&lt;p&gt;LLVM 是一个&lt;strong&gt;开源的编译器架构&lt;/strong&gt;，利用虚拟技术对源代码提供现代化的、与目标无关的、</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>指令虚拟化</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2024-01-22T16:00:00.000Z</published>
    <updated>2024-02-02T12:18:45.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令虚拟化"><a href="#指令虚拟化" class="headerlink" title="指令虚拟化"></a>指令虚拟化</h1><p>虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数和结构来解析自定义的指令并执行相应的功能。</p><p>虚拟化是一种基于虚拟机的代码保护技术。他将硬件支持的机器码转化为字节码指令系统，来达到不被轻易篡改和逆向的目的。</p><p>简单来说就是出题人通过实现一个小型的虚拟机，自定义一些操作码（opcode），然后在程序执行时通过解释操作码，执行对应的函数，从而实现程序原有的功能。</p><p>下图是常见的虚拟机结构：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123191130428.png" alt="image-20240123191130428"></p><p>虚拟机的主程序其实就是一个循环，这个循环不断的去读取指令（伪机器码 opcode），然后执行指令opcode 所对应的一些函数，这样下来就可以与真实的程序执行相差无几。</p><h2 id="正向实现"><a href="#正向实现" class="headerlink" title="正向实现"></a><strong>正向实现</strong></h2><p>想要对抗虚拟化，首先要搞清楚用于保护的虚拟机是如何实现的要想实现虚拟机，需要完成两个目标：</p><ol><li><p>定义一套指令集</p></li><li><p>实现对应的解释器</p></li></ol><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h3><p>真实赛题中的 VM 通常会实现一个类似如下的结构体，用于保存虚拟机状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r1; <span class="comment">// 虚拟寄存器 r1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r2; <span class="comment">// 虚拟寄存器 r2</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> eip; <span class="comment">// 指向正在解释的 opcode 地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mem[<span class="number">256</span>]; <span class="comment">// 虚拟内存</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[<span class="number">1024</span>]; <span class="comment">// 存放自定义机器码</span></span><br><span class="line">&#125; VM;</span><br></pre></td></tr></table></figure><h3 id="opcode-定义"><a href="#opcode-定义" class="headerlink" title="opcode 定义"></a><strong>opcode</strong> <strong>定义</strong></h3><p>接着自定义一些指令，需要决定该指令集是<strong>定长</strong>的还是<strong>变长</strong>的。</p><p>这里以变长指令集为例，先列出一个表来：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123194824707.png" alt="image-20240123194824707"></p><h3 id="书写机器码"><a href="#书写机器码" class="headerlink" title="书写机器码"></a><strong>书写机器码</strong></h3><p>假定希望实现的语义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> input[<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> target[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, input);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">input[i] ^= <span class="number">0x21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(input, target, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们定义的指令对其进行拆分和重构，可以得到如下机器码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[] = &#123;</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="comment">// mem[0x10] = &#x27;H&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="comment">// mem[0x11] = &#x27;e&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x12] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x13] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="comment">// mem[0x14] = &#x27;o&#x27;</span></span><br><span class="line"><span class="number">0x40</span>, <span class="comment">// scanf(&quot;%5s&quot;, &amp;mem[0]);</span></span><br><span class="line"><span class="number">0x11</span>, <span class="number">0x21</span>, <span class="comment">// r2 = 0x21</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x0</span>, <span class="comment">// r1 = 0</span></span><br><span class="line"><span class="number">0x30</span>, <span class="comment">// mem[r1] ^= r2</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x1</span>, <span class="comment">// r1 = 1</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x2</span>, <span class="comment">// r1 = 2</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x3</span>, <span class="comment">// r1 = 3</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x4</span>, <span class="comment">// r1 = 4</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span> <span class="comment">// return memcmp(&amp;mem[0], &amp;mem[0x10], 5);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化虚拟机"><a href="#初始化虚拟机" class="headerlink" title="初始化虚拟机"></a><strong>初始化虚拟机</strong></h3><p>在实际运行虚拟机之前，需要先对 VM 结构体进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM* <span class="title function_">vm_new</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = (VM*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(VM)); <span class="comment">// 申请内存</span></span><br><span class="line"><span class="built_in">memset</span>(vm, <span class="number">0</span>, <span class="keyword">sizeof</span>(VM)); <span class="comment">// 清空结构体字段</span></span><br><span class="line"><span class="built_in">memcpy</span>(vm-&gt;code, code, <span class="keyword">sizeof</span>(code)); <span class="comment">// 拷贝机器码</span></span><br><span class="line"><span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释器编写"><a href="#解释器编写" class="headerlink" title="解释器编写"></a><strong>解释器编写</strong></h3><p>现在就可以来实现每条指令的 handle 以及 dispatcher 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vm_run</span><span class="params">(VM* vm)</span> &#123;</span><br><span class="line"><span class="type">char</span> opcode;</span><br><span class="line"><span class="type">char</span> operand_1, operand_2;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">opcode = vm-&gt;code[vm-&gt;eip];</span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r1 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r2 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line">vm-&gt;mem[operand_1] = operand_2;</span><br><span class="line">vm-&gt;eip += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2;</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, &amp;vm-&gt;mem[<span class="number">0</span>]);</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">memcmp</span>(&amp;vm-&gt;mem[<span class="number">0</span>], &amp;vm-&gt;mem[operand_1], operand_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><p>于是 main 函数可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = vm_new();</span><br><span class="line"><span class="keyword">if</span> (!vm_run(vm))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a><strong>解题步骤</strong></h2><p>遇到 VM 类的赛题，我们一般按照如下的步骤来解题：</p><ul><li><p>分析 VM 结构</p><ul><li>结构体大小</li><li>有哪些字段（内存、寄存器）</li></ul></li><li><p>分析指令集</p><ul><li>指令长度是否可变</li><li>每种指令的构成</li><li>每种指令的含义（伪汇编）</li><li>VM 的退出条件</li></ul></li><li><p>编写 Python 版解释器，输出伪汇编代码</p></li><li><p>阅读伪代码，分析程序流程，写出去虚拟化的原始代码</p></li><li><p>书写解题脚本</p></li></ul><p>本例中的 Python 版解释器如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>,</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="number">0x40</span>, <span class="number">0x11</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0x0</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x1</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x2</span>,</span><br><span class="line"><span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x3</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x4</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span>]</span><br><span class="line">ip = <span class="number">0</span></span><br><span class="line">r1 = r2 = <span class="number">0</span></span><br><span class="line">mem = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">opcode = code[ip]</span><br><span class="line"><span class="keyword">if</span> opcode == <span class="number">0x10</span> :</span><br><span class="line">r1 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r1, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x11</span> :</span><br><span class="line">r2 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r2, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x20</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">mem[op1] = op2</span><br><span class="line">print(f<span class="string">&quot;mov [&#123;hex(op1)&#125;], &#123;hex(op2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">3</span></span><br><span class="line">elif opcode == <span class="number">0x30</span> :</span><br><span class="line">mem[r1] ^= r2</span><br><span class="line">print(f<span class="string">&quot;xor [&#123;hex(r1)&#125;], &#123;hex(r2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x40</span> :</span><br><span class="line"><span class="meta"># flag = input().encode()</span></span><br><span class="line">flag = b<span class="string">&quot;iDMMN&quot;</span></span><br><span class="line"><span class="keyword">for</span> i in range(len(flag)) :</span><br><span class="line">mem[i] = flag[i]</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x50</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">print(mem[<span class="number">0</span>:op2] == mem[op1:op1 + op2])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">raise ValueError(<span class="string">&quot;unknown opcode&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指令虚拟化&quot;&gt;&lt;a href=&quot;#指令虚拟化&quot; class=&quot;headerlink&quot; title=&quot;指令虚拟化&quot;&gt;&lt;/a&gt;指令虚拟化&lt;/h1&gt;&lt;p&gt;虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数</summary>
      
    
    
    
    
    <category term="指令虚拟化 VM" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96-VM/"/>
    
  </entry>
  
  <entry>
    <title>自修改代码</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/</id>
    <published>2024-01-21T16:00:00.000Z</published>
    <updated>2024-01-22T16:06:59.822Z</updated>
    
    <content type="html"><![CDATA[<p>PE文件结构&#x2F;&#x2F;</p><h1 id="自修改代码"><a href="#自修改代码" class="headerlink" title="自修改代码"></a>自修改代码</h1><p>Self-Modifying Code</p><p>自修改代码（Self-Modifying Code），指在一段代码执行前对它进行修改。把代码以加密的形式保存在可执行文件中（或静态资源中），然后在程序执行的时候进行动态解密。这样我们在采用静态分析时，看到的都是加密的内容，从而减缓甚至阻止静态分析。</p><h2 id="原理与示例"><a href="#原理与示例" class="headerlink" title="原理与示例"></a>原理与示例</h2><p>SMC思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (运行条件满足) &#123;</span><br><span class="line">DecryptProc(Address of Check) <span class="comment">// 对 Check 代码解密</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">Check(); <span class="comment">// 调用 Check</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">EncryptProc(Address of Check) <span class="comment">// 再对代码进行加密，防止程序被 dump</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SMC静态分析对抗示例：</p><p>正常程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS 中 Release 32 位下编译（关闭随机基址），放入 IDA 中查看：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122225317272.png" alt="image-20240122225317272"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> _check__YAHH_Z[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x51</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xEB</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x8B</span>, <span class="number">0xE5</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们想把 check 函数保护起来，先把其机器码摘出来进行加密：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> check[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x33</span>, <span class="number">0xC0</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x94</span>, <span class="number">0xC0</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(check); i++)</span><br><span class="line">&#123;</span><br><span class="line">check[i] ^= <span class="number">0x90</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, check[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c5 1b 7c c1 11 ed 98 a9 a0 90 90 e5 99 57 d5 6c 91 90 90 90 7b 97 57 d5 6c 90 90 90 90 1b d5 6c 1b 75 cd 53</span><br></pre></td></tr></table></figure><p>修改初始代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line">DWORD old;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, PAGE_EXECUTE_READWRITE, &amp;old); <span class="comment">// 修改内存页权限</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, old, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt(); <span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译后，在 16 进制编辑器中找到并修改 check 函数的机器码为加密后的数据</p><p>一个具备 SMC 属性的可执行文件已经构造完成了，现在再用 IDA 进行分析：</p><p>发现原始逻辑已经被很好地隐藏了。</p><p>另一种常见的实现方法是通过新增一个具备 RWX 属性的程序段，将需要保护的代码书写在其中，这样就可以避免调用 VirtualAlloc &#x2F; VirtualProtect &#x2F; mprotect 这类 API 来暴露 SMC 的意图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg(<span class="string">&quot;.qaq&quot;</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:.qaq,ERW&quot;</span>)</span></span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt();</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 IDA 中看到新增了一个段：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122235013392.png" alt="image-20240122235013392"></p><h2 id="对抗思路"><a href="#对抗思路" class="headerlink" title="对抗思路"></a>对抗思路</h2><p>能动态调试最好直接动态调试，因为在程序运行的某一时刻，它一定是解密完成的，这时也就暴露了，使用<strong>动态分析运行到这一时刻即可过掉保护</strong>。</p><p>其次是根据静态分析获得解密算法，写出解密脚本提前解密这段代码。</p><p>解密得到的机器码可以通过 IDAPython 的 patch_byte 接口很方便地写回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PE文件结构&amp;#x2F;&amp;#x2F;&lt;/p&gt;
&lt;h1 id=&quot;自修改代码&quot;&gt;&lt;a href=&quot;#自修改代码&quot; class=&quot;headerlink&quot; title=&quot;自修改代码&quot;&gt;&lt;/a&gt;自修改代码&lt;/h1&gt;&lt;p&gt;Self-Modifying Code&lt;/p&gt;
&lt;p&gt;自修改代码</summary>
      
    
    
    
    
    <category term="逆向 子修改代码" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91-%E5%AD%90%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>花指令&amp;反调试</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/</id>
    <published>2024-01-18T16:00:00.000Z</published>
    <updated>2024-01-22T17:09:44.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="花指令-amp-反调试"><a href="#花指令-amp-反调试" class="headerlink" title="花指令&amp;反调试"></a>花指令&amp;反调试</h1><p>2024&#x2F;01&#x2F;17</p><p>好，做道upx练手，把sublime搞崩了。后来才知道是文件没有保存用不了。<br>现在还有个问题，就是文件git不上去。。。听天由命吧</p><p>2024&#x2F;01&#x2F;18</p><p>git上去了！</p><p>方法：更改了C:\Windows\System32\drivers\etc的hosts，加了IP表，好用！（呜呜呜）</p><p>2024&#x2F;01&#x2F;19</p><p>听伯尼学长说，修改系统配置的http_proxy和https_proxy为梯子的ip，这样就可以在ping的时候走梯子了</p><p>或者直接在cmd里<code>set http_proxy=http://127.0.0.1:7890 &amp; set https_proxy=http://127.0.0.1:7890</code></p><p>欸嘿，昨天玩儿了一天，今天继续学</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>解析失败，一般可能是花指令</p><h3 id="会被执行"><a href="#会被执行" class="headerlink" title="会被执行"></a>会被执行</h3><p>干扰静态分析*</p><h4 id="改变堆栈操作"><a href="#改变堆栈操作" class="headerlink" title="改变堆栈操作"></a>改变堆栈操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">add esp, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用call指令或jmp指令增加执行流程复杂度"><a href="#利用call指令或jmp指令增加执行流程复杂度" class="headerlink" title="利用call指令或jmp指令增加执行流程复杂度"></a>利用call指令或jmp指令增加执行流程复杂度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">call xxx</span><br><span class="line">xxx :</span><br><span class="line">add[esp], <span class="number">0x7</span></span><br><span class="line">retn</span><br><span class="line">_emit <span class="number">0x12</span></span><br><span class="line">_emit <span class="number">0x34</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wwwwww&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有0x12,0x34，push没识别出来，printf后没法执行。</p><p>call–&gt;结束</p><p>找到栈变化的地方（esp转向）按C重编译</p><h3 id="不会被执行"><a href="#不会被执行" class="headerlink" title="不会被执行"></a>不会被执行</h3><h4 id="插入机器码"><a href="#插入机器码" class="headerlink" title="插入机器码"></a>插入机器码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="keyword">xor</span> eax, eax;</span><br><span class="line">jz xxx;</span><br><span class="line">_emit <span class="number">0x11</span>;</span><br><span class="line">_emit <span class="number">0x22</span>;</span><br><span class="line">_emit <span class="number">0x33</span>; <span class="comment">// 0x33是 xor 指令的操作码，会导致后面正常的 push 指令被错误解析</span></span><br><span class="line">xxx:</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改变堆栈平衡"><a href="#改变堆栈平衡" class="headerlink" title="改变堆栈平衡"></a>改变堆栈平衡</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        <span class="keyword">xor</span> eax,eax;</span><br><span class="line">        jz s;</span><br><span class="line">        add esp,<span class="number">0x11</span>;</span><br><span class="line">    s:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA反编译报错，好像可以F5重编译。。。或者发现花指令地方nop！</p><p>xor eax，eax后有jz命令后有一个+1</p><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>检测调试的陷阱w~</p><h3 id="函数检测："><a href="#函数检测：" class="headerlink" title="函数检测："></a>函数检测：</h3><p>函数检测就是通过 Windows 自带的公开或未公开的函数直接检测程序是否处于调试状态。</p><h4 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a><strong>IsDebuggerPresent</strong></h4><p>最简单的调试器检测函数是 IsDebuggerPresent() ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">IsDebuggerPresent</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数查询进程环境块（PEB）中的 BeingDebugged 标志，如果进程处在调试上下文中，则返回一个非零值，否则返回零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> IsDebuggerPresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a><strong>CheckRemoteDebuggerPresent</strong></h4><p>CheckRemoteDebuggerPresent() 用于检测一个远程进程是否处于调试状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">CheckRemoteDebuggerPresent</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE hProcess,</span></span><br><span class="line"><span class="params">_Inout_ PBOOL pbDebuggerPresent</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>如果 hProcess 句柄表示的进程处于调试上下文，则设置 pbDebuggerPresent 变量被设置为TRUE ，否则被设置为 FALSE 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BOOL ret;</span><br><span class="line">CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a><strong>NtQueryInformationProcess</strong></h4><p>NtQueryInformationProcess 用于获取给定进程的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI <span class="title function_">NtQueryInformationProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">_In_ PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class="line"><span class="params">_Out_ PVOID ProcessInformation,</span></span><br><span class="line"><span class="params">_In_ ULONG ProcessInformationLength,</span></span><br><span class="line"><span class="params">_Out_opt_ PULONG ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>第二个参数 ProcessInformationClass 给定了需要查询的进程信息类型。当给定值为0 （ ProcessBasicInformation ）或 7 （ProcessDebugPort ）时，就能得到相关调试信息，返回信息会写到第三个参数 ProcessInformation 指向的缓冲区中。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dbgport = <span class="number">0</span>;</span><br><span class="line">HMODULE hModule = LoadLibrary(<span class="string">&quot;Ntdll.dll&quot;</span>);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess =(NtQueryInformationProcessPtr)GetProcAddress(hModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), <span class="number">7</span>, &amp;dbgPort,<span class="keyword">sizeof</span>(dbgPort),<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> dbgPort != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetLastError"><a href="#GetLastError" class="headerlink" title="GetLastError"></a><strong>GetLastError</strong></h4><p>编写应用程序时，经常需要涉及到错误处理问题。许多函数调用只用 TRUE 和 FALSE 来表明函数的运行结果。一旦出现错误，MSDN 中往往会指出请用 GetLastError 函数来获得错误原因。</p><p>恶意代码可以使用异常来破坏或者探测调试器。调试器捕获异常后，并不会立即将处理权返回被调试进程处理，大多数利用异常的反调试技术往往据此来检测调试器。</p><p>多数调试器默认的设置是捕获异常后不将异常传递给应用程序。如果调试器不能将异常结果正确返回到被调试进程，那么这种异常失效可以被进程内部的异常处理机制探测。</p><p>对于 OutputDebugString 函数，它的作用是在调试器中显示一个字符串，同时它也可以用来探测调试器的存在。使用 SetLastError 函数，将当前的错误码设置为一个任意值。</p><p>如果进程没有被调试器附加，调用 OutputDebugString 函数会失败，错误码会重新设置，因此GetLastError 获取的错误码应该不是我们设置的任意值。</p><p>但如果进程被调试器附加，调用 OutputDebugString 函数会成功，这时 GetLastError 获取的错误码应该没改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD errorValue = <span class="number">12345</span>;</span><br><span class="line"><span class="built_in">SetLastError</span>(errorValue);</span><br><span class="line"><span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Test for debugger!&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == errorValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 DeleteFiber 函数，如果给它传递一个无效的参数的话会抛出ERROR_INVALID_PARAMETER 异常。如果进程正在被调试的话，异常会被调试器捕获。所以，同样可以通过验证 LastError 值来检测调试器的存在。如代码所示，0x57 就是指 ERROR_INVALID_PARAMETER 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> fib[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">DeleteFiber</span>(fib);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">GetLastError</span>() != <span class="number">0x57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样还可以使用 CloseHandle 、 CloseWindow 产生异常，使得错误码改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseHandle((HANDLE)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseWindow((HWND)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_WINDOW_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据检测"><a href="#数据检测" class="headerlink" title="数据检测"></a><strong>数据检测</strong></h3><h4 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a><strong>BeingDebugged</strong></h4><p>数据检测是指程序通过测试一些与调试相关的关键位置的数据来判断是否处于调试状态。比如 PEB 中的 BeingDebugged 参数。数据检测就是直接定位到这些数据地址并测试其中的数据，从而避免调用函数，使程序的行为更加隐蔽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDebug = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h] ; 指向 PEB 基地址</span><br><span class="line">movzx eax, byte ptr [eax+<span class="number">2</span>]</span><br><span class="line">mov BeingDebug, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDebug != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fs:[30h]</strong></p><h4 id="NTGlobalFlag"><a href="#NTGlobalFlag" class="headerlink" title="NTGlobalFlag"></a><strong>NTGlobalFlag</strong></h4><p>由于调试器中启动的进程与正常启动的进程创建堆的方式有些不同，系统使用 PEB 结构偏移量 0x68 处的一个未公开的位置 NTGlobalFlag ，来决定如何创建堆结构。如果这个位置上的值为 0x70 ，则进程处于调试器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h]</span><br><span class="line">mov eax, dword ptr [eax + <span class="number">68</span>h]</span><br><span class="line">and eax, <span class="number">0x70</span></span><br><span class="line">mov BeingDbg, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDbg != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程检测"><a href="#进程检测" class="headerlink" title="进程检测"></a><strong>进程检测</strong></h3><p>进程检测通过检测当前桌面中是否存在特定的调试进程来判断是否存在调试器，但不能判断该调试器是否正在调试该程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FindWindowA(<span class="string">&quot;x32dbg&quot;</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD ID;</span><br><span class="line">    DWORD ret = <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;OllyDBG.EXE&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;OllyICE.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;x64_dbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;windbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;ImmunityDebugger.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特征码检测"><a href="#特征码检测" class="headerlink" title="特征码检测"></a><strong>特征码检测</strong></h3><p>特征码检测枚举当前正在运行的进程，并在进程的内存空间中搜索特定调试器的代码片段。</p><p>例如 OllyDbg 有这样一段特征码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x41, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00,</span><br><span class="line">0x20, 0x00, 0x4f, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x79, 0x00,</span><br><span class="line">0x44, 0x00, 0x62, 0x00, 0x67, 0x00, 0x00, 0x00, 0x4f, 0x00,</span><br><span class="line">0x4b, 0x00, 0x00, 0x00</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;BYTE sign[] = &#123; <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x6f</span>, <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x79</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x44</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x4b</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>; &#125;</span><br><span class="line">    PROCESSENTRY32 sentry32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">    HANDLE phsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    Process32First(phsnap, &amp;sentry32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HANDLE hps = OpenProcess(MAXIMUM_ALLOWED, FALSE,</span><br><span class="line">            sentry32.th32ProcessID);</span><br><span class="line">        <span class="keyword">if</span> (hps != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD szReaded = <span class="number">0</span>;</span><br><span class="line">            BYTE signRemote[<span class="keyword">sizeof</span>(sign)];</span><br><span class="line">            ReadProcessMemory(hps, (LPCVOID)<span class="number">0x4f632a</span>, signRemote,</span><br><span class="line">                <span class="keyword">sizeof</span>(signRemote), &amp;szReaded);</span><br><span class="line">            <span class="keyword">if</span> (szReaded &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span>(sign, signRemote, <span class="keyword">sizeof</span>(sign)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    CloseHandle(phsnap);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">&#125;<span class="keyword">while</span> (Process32Next(phsnap, &amp;sentry32));</span><br></pre></td></tr></table></figure><h3 id="时间检测"><a href="#时间检测" class="headerlink" title="时间检测"></a><strong>时间检测</strong></h3><p>时间检测是指在程序中通过代码感知程序处于调试时与未处于调试时的各种运行时间差异来判断程序是否处于调试状态。</p><p>例如我们在调试时步过两条指令所花费的时间远远超过 CPU 正常执行花费的时间，于是就可以通过rdtsc 指令或 GetTickCount 函数来进行测试。</p><p>注： rdtsc 指令用于将时间标签计数器读入 EDX:EAX 寄存器。 GetTickCount 返回从操作系统动</p><p>所经过的毫秒数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        rdtsc</span><br><span class="line">        mov ecx, edx</span><br><span class="line">        rdtsc</span><br><span class="line">        sub edx, ecx</span><br><span class="line">        mov BeingDbg, edx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BeingDbg &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD time1 = GetTickCount();</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">        mov edx, <span class="number">6</span></span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD time2 = GetTickCount();</span><br><span class="line">    <span class="keyword">if</span> (time2 - time1 &gt; <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断点检测"><a href="#断点检测" class="headerlink" title="断点检测"></a><strong>断点检测</strong></h3><p>断点检测是根据调试器设置断点的原理来检测软件代码中是否设置了断点。调试器一般使用两者方法设置代码断点：</p><ul><li><p>通过修改代码指令为 INT3（机器码为0xCC）触发软件异常</p></li><li><p>通过硬件调试寄存器设置硬件断点</p></li></ul><p>针对软件断点，检测系统会扫描比较重要的代码区域，看是否存在多余的 INT3 指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS32 pNtHeaders;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">DWORD dwBaseImage = (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;</span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader -</span><br><span class="line">&gt; e_lfanew);</span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders +</span><br><span class="line"><span class="keyword">sizeof</span>(pNtHeaders-&gt;Signature) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +</span><br><span class="line">(WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;</span><br><span class="line">DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">BOOL Found = FALSE;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">cld</span><br><span class="line">mov edi, dwAddr</span><br><span class="line">mov ecx, dwCodeSize</span><br><span class="line">mov al, <span class="number">0</span>CCH</span><br><span class="line">repne scasb; 在EDI指向大小为ECX的缓冲区中搜索AL包含的字节</span><br><span class="line">jnz NotFound</span><br><span class="line">mov Found, <span class="number">1</span></span><br><span class="line">NotFound:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于硬件断点，由于程序工作在保护模式下，无法访问硬件调试断点，所以一般需要构建异常程序来获取 DR 寄存器的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">CONTEXT context;</span><br><span class="line">HANDLE hThread = GetCurrentThread();</span><br><span class="line">context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">GetThreadContext(hThread, &amp;context);</span><br><span class="line"><span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> ||</span><br><span class="line">context.Dr3 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他检测"><a href="#其他检测" class="headerlink" title="其他检测"></a><strong>其他检测</strong></h3><h4 id="判断父进程是否为-explorer-exe"><a href="#判断父进程是否为-explorer-exe" class="headerlink" title="判断父进程是否为 explorer.exe"></a><strong>判断父进程是否为</strong> <strong>explorer.exe</strong></h4><p>一般双击运行的进程的父进程都是 explorer.exe，但是如果进程被调试父进程则是调试器进程。也就是说如果父进程不是 explorer.exe 则可以认为程序正在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LONG status;</span><br><span class="line">    DWORD dwParentPID = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    PROCESS_BASIC_INFORMATION pbi;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PNTQUERYINFORMATIONPROCESS NtQueryInformationProcess =</span><br><span class="line">        (PNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandleA(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtQueryInf</span></span><br><span class="line"><span class="string">            ormationProcess&quot;</span>);</span><br><span class="line">            status = NtQueryInformationProcess(hProcess, SystemBasicInformation,</span><br><span class="line">                (PVOID)&amp;pbi, <span class="keyword">sizeof</span>(PROCESS_BASIC_INFORMATION), <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pbi.InheritedFromUniqueProcessId == pe32.th32ProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;explorer.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-STARTUPINFO"><a href="#测试-STARTUPINFO" class="headerlink" title="测试 STARTUPINFO"></a><strong>测试</strong> <strong>STARTUPINFO</strong></h4><p>在使用 CreateProcess 创建进程时,需要传递 STARTUPINFO 的结构体指针，而常常我们并不会一个一个设置其结构的值，连把其他不用的值清 0 都会忽略。</p><p>故可以使用 GetStartupInfo 检查启动信息，如果很多值不为 0，那么就说明自己的父进程不是explorer（explorer.exe 使用 shell32 中 ShellExecute 来运行程序， ShellExecute 会清掉不用的值）</p><p>所以可以利用 STARTUPINFO 结构体中不用的字段来判断程序是否在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">STARTUPINFO si;</span><br><span class="line">GetStartupInfo(&amp;si);</span><br><span class="line"><span class="keyword">if</span> (si.dwX != <span class="number">0</span> || si.dwY != <span class="number">0</span> || si.dwFillAttribute != <span class="number">0</span> || si.dwXSize != <span class="number">0</span> ||</span><br><span class="line">si.dwYSize != <span class="number">0</span> || si.dwXCountChars != <span class="number">0</span> || si.dwYCountChars != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于异常的反调试"><a href="#基于异常的反调试" class="headerlink" title="基于异常的反调试"></a><strong>基于异常的反调试</strong></h4><p>进程中发生异常时若 SEH 未处理或注册的 SEH 不存在，会调用 UnhandledExceptionFilter ，它会运行系统最后的异常处理器。 UnhandledExceptionFilter 内部调用了前面提到过的NtQueryInformationProcess 以判断进程是否正在被调试。</p><p>若进程未被调试，则运行最后的异常处理器。若进程处于调试状态，则将异常派送给调试器。</p><p>SetUnhandledExceptionFilter 函数可以修改系统最后的异常处理器。</p><h4 id="Debug-Block"><a href="#Debug-Block" class="headerlink" title="Debug Block"></a><strong>Debug Block</strong></h4><p>Debug Block 是指在需要保护的程序中，程序自身将一些只能同时有 1 个实例的功能占为己用。比如一般情况下，一个进程只能同时被 1 个调试器调试，那么就可以设计一种模式，将程序以调试方式启动，然后利用系统的调试机制防止被其他调试器调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;花指令-amp-反调试&quot;&gt;&lt;a href=&quot;#花指令-amp-反调试&quot; class=&quot;headerlink&quot; title=&quot;花指令&amp;amp;反调试&quot;&gt;&lt;/a&gt;花指令&amp;amp;反调试&lt;/h1&gt;&lt;p&gt;2024&amp;#x2F;01&amp;#x2F;17&lt;/p&gt;
&lt;p&gt;好，做道up</summary>
      
    
    
    
    
    <category term="花指令 逆向学习 反调试" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4-%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>寄网</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/18/%E7%AE%80%E5%8D%95%E5%AF%84%E7%BD%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/18/%E7%AE%80%E5%8D%95%E5%AF%84%E7%BD%91/</id>
    <published>2024-01-17T16:00:00.000Z</published>
    <updated>2024-01-19T09:06:48.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker网络模式Linux-Bridge-Host-None"><a href="#Docker网络模式Linux-Bridge-Host-None" class="headerlink" title="Docker网络模式Linux-Bridge|Host|None"></a>Docker网络模式Linux-Bridge|Host|None</h2><p> 如果假设Linux是宿主，有一个enp0s3的以太网接口，当有了docker后，会多一个docker0接口，这个docker0是默认Brigade网络的网关，容器的数据要出去需要经过docker0。</p><p>如果创建新的模式（eth0），会默认加入这个docker0网络里，此时docker0下面会多了一个附属的接口，并且通过veth的方式和容器的eth0接口进行连接，如果有新的容器也是会发生同样的事情，这个网络模式叫做Bridge；而“桥”就是docker0，veth可以想象为容器各自通往桥的路，正因为有docker0这座桥，容器里的数据才可以抵达宿主的enp0s3接口，也就是说容器是可以访问外部网络的。</p><p>在Bridge网络中，可以进行容器间、容器与宿主间，容器向互联网的访问，但是互联网-&gt;容器需要端口关联</p><table><thead><tr><th></th><th>默认Bridge</th><th>自定义Bridge</th><th>Host</th><th>None</th></tr></thead><tbody><tr><td>优点</td><td>自动加入</td><td>自动DNS隔离</td><td>网络性能佳</td><td>隔离</td></tr><tr><td>缺点</td><td>无自动DNS</td><td>NAT</td><td>安全问题<br />仅Linux</td><td>不能联网</td></tr><tr><td>场景</td><td>不建议</td><td>单宿主多容器</td><td>单容器多端口</td><td>备份<br />一次性操作</td></tr></tbody></table><h2 id="【虚拟机网络模式】NAT-NAT网络-桥接Bridged-内部网络Internal-仅主机-Host-Only"><a href="#【虚拟机网络模式】NAT-NAT网络-桥接Bridged-内部网络Internal-仅主机-Host-Only" class="headerlink" title="【虚拟机网络模式】NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)"></a>【虚拟机网络模式】NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)</h2><p>ping 的实质：发送一个icmp回显请求报文给目的的主机，并等待回显的icmp应答。然后打印出回显报文。</p><p>回显的结果包括：字节数  、 反应时间、TTL（生存时间）</p><p>Tracert 的实质：利用ICMP数据报和IP数据报头部中的TTL值。TTL（Time To Live）是一个IP数据报的生存时间，当每个IP数据报经过路由器的时候都回把TTL值减去1或者减去在路由器中停留的时间，但是大多数数据报在路由器中停留的时间都小于1秒种，因此实际上就是在TTL值减去了1。这样，TTL值就相当于一个路由器的计数器。<br>当路由器接收到一个TTL为0或者1的IP数据报的时候，路由器就不再转发这个数据了，而直接丢弃，并且发送一个ICMP“超时”信息给源主机。Tracert程序的关键就是这个回显的ICMP报文的IP报头的信源地址就是这个路由器的IP地址。同时，如果到达了目的主机，我们并不能知道，于是，Tracert还同时发送一个UDP信息给目的主机，并且选择一个很大的值作为UDP的端口，使主机的任何一个应用程序都不使用这个端口。所以，当达到目的主机的时候，UDP模块就产生一个“端口不可到达”的错误，这样就能判断是否是到达目的地了。</p><p>原文链接：<a href="https://blog.csdn.net/u013078669/article/details/48437559">https://blog.csdn.net/u013078669/article/details/48437559</a></p><p><a href="http://t.csdnimg.cn/tx3ql">http://t.csdnimg.cn/tx3ql</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker网络模式Linux-Bridge-Host-None&quot;&gt;&lt;a href=&quot;#Docker网络模式Linux-Bridge-Host-None&quot; class=&quot;headerlink&quot; title=&quot;Docker网络模式Linux-Bridge|Host|</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>常用命令/快捷方式</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/16/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/16/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</id>
    <published>2024-01-15T16:00:00.000Z</published>
    <updated>2024-01-30T12:18:23.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令-x2F-快捷方式"><a href="#常用命令-x2F-快捷方式" class="headerlink" title="常用命令&#x2F;快捷方式"></a>常用命令&#x2F;快捷方式</h1><h2 id="IDA："><a href="#IDA：" class="headerlink" title="IDA："></a>IDA：</h2><h3 id="静态调试"><a href="#静态调试" class="headerlink" title="静态调试"></a>静态调试</h3><p>交叉引用：X</p><p>地址跳转：G</p><p>书写注释：&#x2F;（伪代码） ；（反编译窗口）</p><p>修改符号名：N</p><p>数据类型操作：Y</p><p>修改数据长度：D</p><p>函数操作：  </p><ul><li>定义函数：P</li><li>删除函数：Delete&#x2F;U</li><li>修改函数范围：Ctrl+E（函数窗口） Alt+P（反汇编）</li></ul><p>代码与数据转换：</p><ul><li>U取消已有数据</li><li>D变成数据</li><li>C变成指令</li><li>A以该位置为起点定义一个以\0结尾的字符串类型</li><li>O将此处定义为一个地址偏移</li></ul><p>创建数组：* </p><p>创建结构体：Shift+f1–local types–insert</p><p>提取数据：shift+E</p><p>函数调用图：View–Graphs–Function calls</p><p>常数搜索：Alt+I</p><p>Patch：Edit -&gt; Patch program -&gt; Change byte</p><p>要永久 Patch， Edit -&gt; Patch program -&gt; Apply patches to input file</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>选择 Debugger -&gt; Select debugger，选择合适的调试器：</p><p>如果是 exe，可以使用 Local Windows Debugger</p><p>如果是 ELF， 则选择 Remote Linux Debugger</p><p>选择 Debuugger -&gt; Start Process 或者按 F9 开始调试。</p><ul><li>继续运行：F9</li><li>单步步入：F7</li><li>单步步过：F8</li><li>执行到返回：Ctrl +F7</li><li>执行到光标处：F4</li><li>添加、删除断点：F2</li></ul><p>Ctrl+Alt+B 打开断点列表</p><p>Ctrl+E 进行编辑</p><p>F2改内存数据</p><p>选择了调试器之后，打开 Debugger -&gt; Process options，在 Parameters 一栏写入命令行参数即可。</p><h2 id="x96dbg"><a href="#x96dbg" class="headerlink" title="x96dbg"></a>x96dbg</h2><h3 id="常用调试快捷键："><a href="#常用调试快捷键：" class="headerlink" title="常用调试快捷键："></a>常用调试快捷键：</h3><ul><li>F4：运行到光标</li><li>F7：单步步入</li><li>F8：单步步过</li><li>F9：运行程序</li><li>Ctrl+F9：执行到函数返回处</li></ul><h2 id="UPX工具壳"><a href="#UPX工具壳" class="headerlink" title="UPX工具壳"></a>UPX工具壳</h2><p>加壳upx -o packed.exe xxx.exe</p><p>脱壳upx -d xxx.exe</p><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>现在，你知道如何在 <em>Insert</em> 和 <em>Normal</em> 模式下切换了。下面是一些命令，可以让你在 <em>Normal</em> 模式下幸存下来：</p><blockquote><ul><li><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li><li><code>x</code> → 删当前光标所在的一个字符。</li><li><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)  （陈皓注：:w 后可以跟文件名）</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li></ul><p><strong>推荐</strong>:</p><ul><li><code>hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</li><li><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（陈皓注：退出帮助需要输入:q）</li></ul></blockquote><p>sudo su 炒鸡</p><p>reboot 重启</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令-x2F-快捷方式&quot;&gt;&lt;a href=&quot;#常用命令-x2F-快捷方式&quot; class=&quot;headerlink&quot; title=&quot;常用命令&amp;#x2F;快捷方式&quot;&gt;&lt;/a&gt;常用命令&amp;#x2F;快捷方式&lt;/h1&gt;&lt;h2 id=&quot;IDA：&quot;&gt;&lt;a href=&quot;#IDA</summary>
      
    
    
    
    
    <category term="命令 快捷" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E5%91%BD%E4%BB%A4-%E5%BF%AB%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>2024寒假MISC小记录_更0130</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/2024%E5%AF%92%E5%81%87MISC%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/2024%E5%AF%92%E5%81%87MISC%E5%B0%8F%E8%AE%B0%E5%BD%95/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-01-30T14:29:26.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MISCMISC！"><a href="#MISCMISC！" class="headerlink" title="MISCMISC！"></a>MISCMISC！</h1><h2 id="2024-x2F-01-x2F-14"><a href="#2024-x2F-01-x2F-14" class="headerlink" title="2024&#x2F;01&#x2F;14"></a>2024&#x2F;01&#x2F;14</h2><h3 id="签到喵："><a href="#签到喵：" class="headerlink" title="签到喵："></a>签到喵：</h3><p>python库函数，喵语</p><h3 id="加密-A-宽宽-S-00-E："><a href="#加密-A-宽宽-S-00-E：" class="headerlink" title="加密 A 宽宽 S 00 E："></a>加密 A 宽宽 S 00 E：</h3><p>零宽字节，ASE加密 </p><h3 id="是uu吗："><a href="#是uu吗：" class="headerlink" title="是uu吗："></a>是uu吗：</h3><p>uuencode，steghide （感觉这几个隐写工具都得筛一次啊（悲</p><h3 id="机密："><a href="#机密：" class="headerlink" title="机密："></a>机密：</h3><p>文件隐藏，爆破 </p><h3 id="EZ签到："><a href="#EZ签到：" class="headerlink" title="EZ签到："></a>EZ签到：</h3><p>伪加密，imagemagick，gaps，f5加密，base家族 （ez））</p><h3 id="社会主义好："><a href="#社会主义好：" class="headerlink" title="社会主义好："></a>社会主义好：</h3><p>核心价值观解码，rabbit解码</p><h2 id="2024-x2F-01-x2F-15"><a href="#2024-x2F-01-x2F-15" class="headerlink" title="2024&#x2F;01&#x2F;15"></a>2024&#x2F;01&#x2F;15</h2><h3 id="签到（web混入）"><a href="#签到（web混入）" class="headerlink" title="签到（web混入）"></a>签到（web混入）</h3><p><strong>元素反应</strong></p><p>看到提交按钮不能用，先把元素里的disabled变成abled点击试试，弹框：</p><blockquote><p>小火汁提交“ilovejljcxy”就能的到flag了啊</p></blockquote><p>输入框只能输入9位，改成11位，提交”ilovejljcxy“，得到flag</p><h3 id="签到题（web再混入）"><a href="#签到题（web再混入）" class="headerlink" title="签到题（web再混入）"></a>签到题（web再混入）</h3><p><strong>cookie 绕过</strong></p><p>看cookie，didi&#x3D;no，用Editthiscookie插件改一下yes，刷新得</p><p>Li9kYXRhL2luZGV4LnBocA（补全&#x3D;&#x3D;后）解密.&#x2F;data&#x2F;index.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    $file = $_GET[&#x27;file&#x27;];</span><br><span class="line">    if(!isset($file))</span><br><span class="line">        $file = &#x27;1&#x27;;</span><br><span class="line">    $file = str_replace(&#x27;../&#x27;, &#x27;&#x27;, $file);</span><br><span class="line">    include_once($file.&quot;.php&quot;);</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>绕过-&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=..././..././..././..././flag</span><br></pre></td></tr></table></figure><p>PD9waHANCiAgICAkZmxhZyA9ICJmbGFnezkyZWI1ZmZlZTZhZTJmZWMzYWQ3MWM3Nzc1MzE1NzhmfSI7DQo&#x2F;Pg&#x3D;&#x3D;（base64）解密：</p><p>flag{92eb5ffee6ae2fec3ad71c777531578f}</p><h3 id="0和255"><a href="#0和255" class="headerlink" title="0和255"></a>0和255</h3><p><strong>程序逆向</strong> </p><p>小小的程序逆向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding = utf-8 -*-</span><br><span class="line"># @software:PyCharm</span><br><span class="line">from PIL import Image</span><br><span class="line">image = Image.open(&#x27;flag.png&#x27;)   #flag.png分辨率为33*33</span><br><span class="line">width = image.width</span><br><span class="line">height = image.height</span><br><span class="line">image_list = []</span><br><span class="line">for x in range(height):</span><br><span class="line">    scanline_list = []</span><br><span class="line">    for y in range(width):</span><br><span class="line">        pixel = image.getpixel((y, x))</span><br><span class="line">        scanline_list.append(pixel)</span><br><span class="line">    image_list.append(scanline_list)</span><br><span class="line">print(image_list)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding = utf-8 -*-</span><br><span class="line"># @software:PyCharm</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image_list =[...]</span><br><span class="line">width = len(image_list[0])</span><br><span class="line">height = len(image_list)</span><br><span class="line">new_image = Image.new(&#x27;RGB&#x27;, (width, height))</span><br><span class="line">for x in range(height):</span><br><span class="line">    for y in range(width):</span><br><span class="line">        pixel = image_list[x][y]</span><br><span class="line">        new_image.putpixel((y, x), pixel)</span><br><span class="line"></span><br><span class="line">new_image.save(&#x27;flag.png&#x27;)</span><br></pre></td></tr></table></figure><p>扫出来：Polar_Night</p><p>得到字符串MD5加密套上flag</p><h2 id="2024-x2F-01-x2F-16"><a href="#2024-x2F-01-x2F-16" class="headerlink" title="2024&#x2F;01&#x2F;16"></a>2024&#x2F;01&#x2F;16</h2><h3 id="docx隐写"><a href="#docx隐写" class="headerlink" title="docx隐写"></a>docx隐写</h3><p><strong>docx 隐写</strong></p><blockquote><p><code>docx</code>隐写的主要考察方式有：</p><p>​1.docx文件的本质是压缩包，其内可存储文件。</p><p>​2.docx内将文字颜色改透明实现隐藏。</p><p>​3.<code>office</code>和<code>wps</code>均支持<code>docx</code>文件的隐藏文字功能，通过设置可以看到隐藏的文字。</p></blockquote><p>猜到了1、2，但是没找到3</p><p>蛮好玩的。</p><h3 id="超级简单的流量"><a href="#超级简单的流量" class="headerlink" title="超级简单的流量"></a>超级简单的流量</h3><p>确实简单—追踪tcp流–<code>tcp.stream eq 2</code></p><h3 id="100RGB"><a href="#100RGB" class="headerlink" title="100RGB"></a>100RGB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">🐯🐩🐣🐮🐨🐣🐭🐭</span><br><span class="line">🐨🐧🐩🐣🐨🐧🐯🐣🐰🐮</span><br><span class="line">🐨🐧🐪🐣🐨🐩🐪🐣🐭🐬</span><br><span class="line">🐨🐨🐧🐣🐫🐰🐣🐨🐧🐰</span><br><span class="line">🐰🐮🐣🐫🐰🐣🐨🐨🐬</span><br><span class="line">🐪🐩🐣🐰🐬🐣🐰🐮</span><br><span class="line"> 🐨🐨🐫🐣🐬🐨🐣🐰🐬</span><br><span class="line">🐰🐰🐣🐨🐨🐮🐣🐫🐪</span><br><span class="line">🐨🐧🐨🐣🐨🐩🐬🐣🐧</span><br></pre></td></tr></table></figure><p>..我懂了，base100啊。base100是emoji加密</p><p>记得删除换行。</p><p>然后就是ascii解密（16进制</p><p>……</p><p>后面写了几道蚌埠住了，去画画了嘿嘿</p><h2 id="2024-x2F-01-x2F-17"><a href="#2024-x2F-01-x2F-17" class="headerlink" title="2024&#x2F;01&#x2F;17"></a>2024&#x2F;01&#x2F;17</h2><p>ctfshow做了几道（突然发现的小题库（好玩（（欸嘿</p><h3 id="杂项签到"><a href="#杂项签到" class="headerlink" title="杂项签到"></a>杂项签到</h3><p>直接拖winhex</p><h3 id="损坏的压缩包"><a href="#损坏的压缩包" class="headerlink" title="损坏的压缩包"></a>损坏的压缩包</h3><p>拖winhex–png–改了后缀–flag</p><h2 id="2024-x2F-01-x2F-19"><a href="#2024-x2F-01-x2F-19" class="headerlink" title="2024&#x2F;01&#x2F;19"></a>2024&#x2F;01&#x2F;19</h2><p>?做的题又没记录？</p><p>好像是什么。</p><h3 id="迷之栅栏"><a href="#迷之栅栏" class="headerlink" title="迷之栅栏"></a>迷之栅栏</h3><p><a href="http://t.csdnimg.cn/BtcMt">这里放个破解010的过程，有时间读读</a></p><p>使用010editor的文件比较功能找到两张图片的十六进制不同点，按顺序互相取一位数或者栅栏2位解得flag</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121000329395.png" alt="image-20240121000329395"></p><h3 id="你会数数吗"><a href="#你会数数吗" class="headerlink" title="你会数数吗"></a>你会数数吗</h3><p>使用010editor的 工具→直方图 统计计数解得flag，或者复制出来词频统计</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121000544233.png" alt="image-20240121000544233"></p><h2 id="2024-x2F-01-x2F-20"><a href="#2024-x2F-01-x2F-20" class="headerlink" title="2024&#x2F;01&#x2F;20"></a>2024&#x2F;01&#x2F;20</h2><h3 id="你会异或吗"><a href="#你会异或吗" class="headerlink" title="你会异或吗"></a>你会异或吗</h3><p>图片16进制0x50异或</p><h3 id="flag一分为二"><a href="#flag一分为二" class="headerlink" title="flag一分为二"></a>flag一分为二</h3><p>前半watermark，后半改高度</p><h3 id="打不开的图"><a href="#打不开的图" class="headerlink" title="打不开的图"></a>打不开的图</h3><p>png文件开头应该是89 50 4E 47，观察下题目给的png的开头是77 B0 B2 B9，会发现0x89+0x77&#x3D;0x100, 0x50+0xB0&#x3D;0x100, 0x4E+0xB2&#x3D;0x100, 0x47+0xB9&#x3D;0x100, 所以，只要用0x100减去现在png文件中的每个字节的16进制数即可恢复出可以预览的png图片。<br>但是要注意这里还有一个小坑，就是0x100是十进制数的256，而bytes格式最大只能表示到255，出现256会报错，所以题目原png文件中是0的位置，还是0，不能用0x100去减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ff=<span class="built_in">open</span>(<span class="string">&#x27;./misc5.5.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data=ff.read()</span><br><span class="line">l=[]</span><br><span class="line"><span class="keyword">for</span> dd <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> dd==<span class="number">0</span>:</span><br><span class="line">        l.append(dd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l.append(<span class="number">0x100</span>-dd) </span><br><span class="line">ff=<span class="built_in">open</span>(<span class="string">&#x27;./1234.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="comment">#会新建一个可写入的新文件1234.png</span></span><br><span class="line">ff.write(<span class="built_in">bytes</span>(l))</span><br><span class="line">ff.close()</span><br></pre></td></tr></table></figure><h2 id="2024-x2F-01-x2F-21"><a href="#2024-x2F-01-x2F-21" class="headerlink" title="2024&#x2F;01&#x2F;21"></a>2024&#x2F;01&#x2F;21</h2><h3 id="黑丝白丝还有什么丝？"><a href="#黑丝白丝还有什么丝？" class="headerlink" title="黑丝白丝还有什么丝？"></a>黑丝白丝还有什么丝？</h3><p>莫斯密码，白丝·，黑丝_，转场是空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.-- ....- -. - - ----- -... ...-- -- --- .-. . -.-. ..- - .</span><br></pre></td></tr></table></figure><h3 id="我吐了你随意"><a href="#我吐了你随意" class="headerlink" title="我吐了你随意"></a>我吐了你随意</h3><p>好题目。<a href="http://330k.github.io/misc_tools/unicode_steganography.html">零宽解密</a></p><h3 id="迅疾响应"><a href="#迅疾响应" class="headerlink" title="迅疾响应"></a>迅疾响应</h3><p>一道二维码题目，得学学了。。—&gt;<a href="http://t.csdnimg.cn/hNYjT">http://t.csdnimg.cn/hNYjT</a></p><p><a href="https://www.cnblogs.com/SanCai-Newbie/p/16979691.html">他写的好好。</a></p><p><a href="https://merri.cx/qrazybox/">QRazyBox</a></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121223704858.png" alt="image-20240121223704858"></p><h3 id="You-and-me"><a href="#You-and-me" class="headerlink" title="You and me"></a>You and me</h3><p>盲水印，使用工具 BlindWaterMark-master</p><p>python3 bwmforpy3.py decode you.png you_and_me.png wm2.png</p><p><a href="https://ctf-show.feishu.cn/docx/UpC6dtDqgo7VuoxXlcvcLwzKnqh">https://ctf-show.feishu.cn/docx/UpC6dtDqgo7VuoxXlcvcLwzKnqh</a></p><h2 id="20240122"><a href="#20240122" class="headerlink" title="20240122"></a>20240122</h2><p>两个图片题，好像直接扔识图里就ok</p><p>还有一个re</p><p>简单rc4加密，密钥是DH<del>mqqvqxB^||zll@Jq</del>jkwpmvez{</p><p>密文：Ã‚£%öL6;YÌÄéñµ2±–®¿5</p><p>不想写了，chatpy</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_with_0x1F</span>(<span class="params">input_str</span>):</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> input_str:</span><br><span class="line">        <span class="comment"># 将每个字符与0x1F进行异或操作</span></span><br><span class="line">        xored_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="number">0x1F</span>)</span><br><span class="line">        result += xored_char</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">input_string = <span class="string">&quot;DH~mqqvqxB^||zll@Jq~jkwpmvez&#123;&quot;</span></span><br><span class="line">output_string = xor_with_0x1F(input_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入字符串:&quot;</span>, input_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异或操作后的字符串:&quot;</span>, output_string)</span><br></pre></td></tr></table></figure><h2 id="20240123"><a href="#20240123" class="headerlink" title="20240123"></a>20240123</h2><h3 id="crypto签到"><a href="#crypto签到" class="headerlink" title="crypto签到"></a>crypto签到</h3><p>63746673686f777b77656c636f6d655f325f636169676f755f6375707d</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;63746673686f777b77656c636f6d655f325f636169676f755f6375707d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.decode())</span><br></pre></td></tr></table></figure><p>16进制是ascii</p><h3 id="crypto签到2"><a href="#crypto签到2" class="headerlink" title="crypto签到2"></a>crypto签到2</h3><p>Ao(mgHX^E)AN2PSBOu3qI0o</p><p>wp：</p><p><strong>Ao(mg</strong>就是flag用base85编码之后的表示形式<br> base85还有各式各样的编码表。。这是ASCII</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">a=<span class="string">&quot;Ao(mgHX^E)AN2PSBOu3qI0o&quot;</span></span><br><span class="line">a=base64.a85decode(a).decode()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h3 id="Caesar"><a href="#Caesar" class="headerlink" title="Caesar"></a>Caesar</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Zhofrph wr FWIvkrz yhjhwdeoh grj fxs!</span><br></pre></td></tr></table></figure><p>#3 Welcome to CTFshow vegetable dog cup!</p><h3 id="0x36d"><a href="#0x36d" class="headerlink" title="0x36d"></a>0x36d</h3><p>密文： 😫🙄👰😰👣🙋😱👧👌👷👯👩😴👖👫👚🙃👹👏👏😶👳😫👕🙂🙊👵👶👨👰👮🙉👶👵👸👲👺👮👑😶👴😫🙊👫😴👬👹👤👑😱👗🙃👐😶 提示： 有没有一种可能，标题就是密码？</p><p>wp：熟悉的emoji解密，但是，，0x36d不行，换成877</p><h3 id="类型-7"><a href="#类型-7" class="headerlink" title="类型-7"></a>类型-7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">094F5A0F0A0D1805103B0B3D143117183B720438350A45550967674D1E064F2969784440455A460F1A1B</span><br></pre></td></tr></table></figure><p>ctfshow{Wow_u_Kn0w_Ci$c0_Type7_P@ssword!}</p><h3 id="base47"><a href="#base47" class="headerlink" title="base47"></a>base47</h3><p><a href="https://www.cnblogs.com/Guanz/p/17909958.html">写的很好</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"> </span><br><span class="line">ciper = <span class="string">&#x27;E9CV^T+HT5#X36RF4@LAU703+F$E-0N$@68LMXCVDRJJD5@MP#7MUZDTE?WWLG1S#L@+^66H@59KTWYK8TW0RV&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;0123456789ABCDEFGHJKLMNPQRSTUVWXYZ?!@#$%^&amp;*-+&#x27;</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">0</span>  <span class="comment"># 密文转十进制数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciper)):</span><br><span class="line">    p = key.index(ciper[i])  <span class="comment"># 找到每个密文字符对应字典的下标</span></span><br><span class="line">    num += p * (<span class="built_in">len</span>(key) ** (<span class="built_in">len</span>(ciper) - i - <span class="number">1</span>))  <span class="comment"># 45进制转十进制后求和</span></span><br><span class="line"> </span><br><span class="line">s = libnum.n2s(num)  <span class="comment"># 十进制数转字符串 ascii码表 256进制</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="PWN签到题"><a href="#PWN签到题" class="headerlink" title="PWN签到题"></a>PWN签到题</h3><p>欸嘿 nc过去就是</p><h3 id="PWN02"><a href="#PWN02" class="headerlink" title="PWN02"></a>PWN02</h3><p><a href="http://t.csdnimg.cn/GMR5G">http://t.csdnimg.cn/GMR5G</a></p><h2 id="20240124"><a href="#20240124" class="headerlink" title="20240124"></a>20240124</h2><h3 id="flag白给"><a href="#flag白给" class="headerlink" title="flag白给"></a>flag白给</h3><p>嗯…看出套壳upx，然后找flag</p><p>想了半天，不知道这个序列号啥意思，启动程序才知道，</p><p>输入错了，按着这个串找</p><p>嗯……HackAv</p><h3 id="数学不及格"><a href="#数学不及格" class="headerlink" title="数学不及格"></a>数学不及格</h3><p>嗯……数学题，<a href="https://www.cnblogs.com/ethan269/p/ctfshow_re8.html">好题解</a></p><p>源程序不困难，逻辑清晰</p><p>先预定几个参数（注意strtol），再参数运算判断，逆向求解</p><h3 id="签退"><a href="#签退" class="headerlink" title="签退"></a>签退</h3><p><a href="http://t.csdnimg.cn/9c7WX">pyc逆向</a></p><p>在线工具反编译</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 2.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">c_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + <span class="string">&#x27;()&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;BozjB3vlZ3ThBn9bZ2jhOH93ZaH9&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">origin_bytes</span>):</span><br><span class="line">    c_bytes = [ <span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(b)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> origin_bytes ]</span><br><span class="line">    resp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    nums = <span class="built_in">len</span>(c_bytes) // <span class="number">3</span></span><br><span class="line">    remain = <span class="built_in">len</span>(c_bytes) % <span class="number">3</span></span><br><span class="line">    integral_part = c_bytes[<span class="number">0</span>:<span class="number">3</span> * nums]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> [</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">6</span>,</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">18</span>]:</span><br><span class="line">        tmp_unit = [][<span class="built_in">int</span>(tmp_unit[x:x + <span class="number">6</span>], <span class="number">2</span>)]</span><br><span class="line">        resp += <span class="string">&#x27;&#x27;</span>.join([ c_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit ])</span><br><span class="line">        integral_part = integral_part[<span class="number">3</span>:]</span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">        remain_part = <span class="string">&#x27;&#x27;</span>.join(c_bytes[<span class="number">3</span> * nums:]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;0&#x27;</span> * <span class="number">8</span></span><br><span class="line">        tmp_unit = [ <span class="built_in">int</span>(remain_part[x:x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">6</span>,</span><br><span class="line">            <span class="number">12</span>,</span><br><span class="line">            <span class="number">18</span>] ][:remain + <span class="number">1</span>]</span><br><span class="line">        resp += <span class="string">&#x27;&#x27;</span>.join([ c_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit ]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> rend(resp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rend</span>(<span class="params">s</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encodeCh</span>(<span class="params">ch</span>):</span><br><span class="line">        </span><br><span class="line">        f = <span class="keyword">lambda</span> x: <span class="built_in">chr</span>(((<span class="built_in">ord</span>(ch) - x) + <span class="number">2</span>) % <span class="number">26</span> + x)</span><br><span class="line">        <span class="keyword">if</span> ch.islower():</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">97</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">None</span>,).isupper():</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&#x27;&#x27;</span>.join,)((<span class="keyword">lambda</span> <span class="number">.0</span>: <span class="keyword">pass</span>)(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#补充一个，ZmxhZw常见flagbase64头，</p><p>明文+base64+凯撒3—-&gt;密文</p><h2 id="20240125"><a href="#20240125" class="headerlink" title="20240125"></a>20240125</h2><h3 id="misc2"><a href="#misc2" class="headerlink" title="misc2"></a>misc2</h3><p>1、打开misc2压缩包，里面只有misc1是未加密的。</p><p>2、打开misc1压缩包，里面png文件未加密，打开是2020，尝试输入加密文件music的密码。</p><p>3、打开music，得到 ♭‖♭‖‖♯♭♭♬‖♩♫‖♬∮♭♭¶♭‖♯‖¶♭♭‖∮‖‖♭‖§♭‖♬♪♭♯§‖‖♯‖‖♬‖‖♪‖‖♪‖¶§‖‖♬♭♯‖♭♯♪‖‖∮‖♬§♭‖‖‖♩♪‖‖♬♭♭♬‖♩♪‖♩¶‖♩♪‖♩♬‖¶§‖‖♩‖¶♫♭♭♩‖♬♯‖♬§♭‖♭‖♩¶‖‖∮♭♭♬‖‖♭‖♫§‖¶♫‖♩∮♭♭§‖♭§‖♭§§&#x3D;</p><p>4、音符解码得到 U2FsdGVkX1&#x2F;eK2855m8HM4cTq8Fquqtm6QDbcUu4F1yQpA&#x3D;&#x3D;</p><p>5、考虑rabbit解码，key为2020，得到：welcome_to_payhelp</p><p>6、将5、得到的考虑为hint.txt的密码，得到： VmpKMFUxTXhXWGxVV0dob1RUSjRVVll3V2t0aFJscDBZMGhLYTAxWGVIaFZiRkpUWWtaYVZWSnJXbFpOVjJoeVZYcEdZVkpzVG5KVWJHaHBWa1ZWZDFkV1ZtRmtNRFZYVjJ4c2FWSlVWbFJVVnpWdVRXeFZlV1ZHVGxSaVZrWTBXVlJPYzFWR1pFZFRiVGxYWW01Q1dGcEdXbE5UUjBZMlVXMTBWMWRGU2xkV1ZtUXdVekpGZUZOWWJHaFRSVFZWV1d0YVMxTXhjRVZUYTFwc1ZteHdlRlp0ZERCV01VcFlaRE53V0Zac2NIWldSekZMVW1zeFdWSnNTbWxXUjNodlZtMXdUMkl5Vm5OaVNGWnBVbXh3YzFac1VrZFNiRlY0WVVkMFZXSlZXbmxWYlRWUFZsWlplbEZyWkZSaVJrcFFWV3hGYkUwd1VXeE5NRkVsTTBRJTNE</p><p>7、将6、base64解码6次，得到 welcome_to_2020%0Aflag%20is%20coming…%0Athe%20key%20is%20hello%202020%21Ü0</p><p>8、对7、中的url解码进行替换得到 welcome_to_2020 flag is coming…%0Athe key is hello 2020!Ü0</p><p>9、猜测hello 2020!为flag.txt密码</p><p>10、得到flag：flag{g00d_f0r_y0u}</p><h3 id="misc50"><a href="#misc50" class="headerlink" title="misc50"></a>misc50</h3><p>嗯……蛮复杂的</p><p><a href="http://t.csdnimg.cn/Y9SyV">http://t.csdnimg.cn/Y9SyV</a></p><h2 id="20240129"><a href="#20240129" class="headerlink" title="20240129"></a>20240129</h2><p>忘记录了呜呜</p><p>一个是word隐写（因为打开查看隐藏功能，所以一打开就是flag（有点无语</p><p>一个是图片隐写，winhex打开有字符，base85</p><h2 id="20240130"><a href="#20240130" class="headerlink" title="20240130"></a>20240130</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MISCMISC！&quot;&gt;&lt;a href=&quot;#MISCMISC！&quot; class=&quot;headerlink&quot; title=&quot;MISCMISC！&quot;&gt;&lt;/a&gt;MISCMISC！&lt;/h1&gt;&lt;h2 id=&quot;2024-x2F-01-x2F-14&quot;&gt;&lt;a href=&quot;#2024-x2</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>修电脑杂记</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/%E4%BF%AE%E7%94%B5%E8%84%91%E6%9D%82%E8%AE%B0(win/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/%E4%BF%AE%E7%94%B5%E8%84%91%E6%9D%82%E8%AE%B0(win/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-01-25T14:16:21.459Z</updated>
    
    <content type="html"><![CDATA[<p>2024&#x2F;1&#x2F;14</p><h2 id="嘿嘿早上把家里的电脑修好了"><a href="#嘿嘿早上把家里的电脑修好了" class="headerlink" title="嘿嘿早上把家里的电脑修好了"></a>嘿嘿早上把家里的电脑修好了</h2><p>问题：ntfs.sys丢失或损坏蓝屏<br>原因：U盘在开机前启动，导致win7系统没起来，系统文件被修改了<br>解决：命令行：<code>chkdsk C: /f /r</code> ,然后<code>Y</code>，重启后修复就ok了</p><p>修改磁盘大小</p><p><a href="https://support.microsoft.com/zh-cn/topic/microsoft-%E6%94%AF%E6%8C%81-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%94%80%E6%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%8D%E6%96%B0%E5%88%86%E5%8C%BA-c3d64de0-4672-b21f-de4e-b4908fb35ae3">官方win7修改磁盘分区方法</a><br>差不多，还好要删除的F盘在C盘右侧，直接删除F盘，C盘扩展就ok了</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>Domain Name System</p><p>DNS服务器</p><p>2.4GHz频段具备强大的穿墙能力和广阔的覆盖范围，而5GHz频段则更注重速度和稳定性。</p><p>2024&#x2F;01&#x2F;20</p><h2 id="win7系统ip地址冲突"><a href="#win7系统ip地址冲突" class="headerlink" title="win7系统ip地址冲突"></a>win7系统ip地址冲突</h2><p>当同一网络上的两台或多台设备分配了相同的IP地址时，就会发生IP地址冲突</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">ipconfig</span>/release</span><br><span class="line">&gt;<span class="built_in">ipconfig</span>/renew</span><br></pre></td></tr></table></figure><h2 id="win7防火墙0x80070422问题"><a href="#win7防火墙0x80070422问题" class="headerlink" title="win7防火墙0x80070422问题"></a>win7防火墙0x80070422问题</h2><p>win+r–services.msc–windows firewall–启动类型为手动，应用后服务状态改启动，ok了</p><h2 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h2><p>df：查看系统整体空间剩余情况</p><p>du:查看每个文件夹占用情况，或查看当前目录下磁盘用量</p><h3 id="dev-x2F-sha1满了"><a href="#dev-x2F-sha1满了" class="headerlink" title="dev&#x2F;sha1满了"></a>dev&#x2F;sha1满了</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoclean   //清理旧版本软件缓存</span><br><span class="line"></span><br><span class="line">sudo apt-get clean      //清理所有软件缓存</span><br><span class="line"></span><br><span class="line">sudo apt-get autoremove  //删除系统不再使用的孤立软件</span><br></pre></td></tr></table></figure><h2 id="VM-ubuntu没网"><a href="#VM-ubuntu没网" class="headerlink" title="VM-ubuntu没网"></a>VM-ubuntu没网</h2><p>折腾了两天，重装解决一切问题。</p><p>伤心。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2024&amp;#x2F;1&amp;#x2F;14&lt;/p&gt;
&lt;h2 id=&quot;嘿嘿早上把家里的电脑修好了&quot;&gt;&lt;a href=&quot;#嘿嘿早上把家里的电脑修好了&quot; class=&quot;headerlink&quot; title=&quot;嘿嘿早上把家里的电脑修好了&quot;&gt;&lt;/a&gt;嘿嘿早上把家里的电脑修好了&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>x32/64dbg</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/14/20240114-15-16_%E5%A3%B3/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/14/20240114-15-16_%E5%A3%B3/</id>
    <published>2024-01-13T16:00:00.000Z</published>
    <updated>2024-01-24T17:05:05.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习x32dbg，x64dbg使用方法"><a href="#学习x32dbg，x64dbg使用方法" class="headerlink" title="学习x32dbg，x64dbg使用方法"></a>学习x32dbg，x64dbg使用方法</h1><h2 id="x64dbg工具使用"><a href="#x64dbg工具使用" class="headerlink" title="x64dbg工具使用"></a>x64dbg工具使用</h2><h3 id="常用调试快捷键："><a href="#常用调试快捷键：" class="headerlink" title="常用调试快捷键："></a>常用调试快捷键：</h3><ul><li>F4：运行到光标</li><li>F7：单步步入</li><li>F8：单步步过</li><li>F9：运行程序</li><li>Ctrl+F9：执行到函数返回处</li></ul><h2 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h2><p>常见压缩壳：upx，ASpack，PECompat<br>常见加密壳：ASProtector，Armadillo，EXECryptor，Themida，VMProtect</p><p>保存入口参数，通常用pushed&#x2F;popad、pushfd&#x2F;popfd指令对来保存喝回复现场环境</p><h3 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a><strong>壳的加载过程</strong></h3><h5 id="保存入口参数"><a href="#保存入口参数" class="headerlink" title="保存入口参数"></a><strong>保存入口参数</strong></h5><ol><li><p>加壳程序初始化时保存各寄存器的值</p></li><li><p>外壳执行完毕，恢复各寄存器值</p></li><li><p>最后再跳到原程序执行</p></li></ol><p>通常用 pushad &#x2F; popad 、 pushfd &#x2F; popfd 指令对来保存和恢复现场环境</p><h5 id="获取所需函数-API"><a href="#获取所需函数-API" class="headerlink" title="获取所需函数 API"></a><strong>获取所需函数</strong> <strong>API</strong></h5><ol><li><p>一般壳的输入表中只有 GetProcAddress 、 GetModuleHandle 和 LoadLibrary 这几个 API 函数</p></li><li><p>如果需要其他 API 函数，则通过 LoadLibraryA(W) 或 LoadLibraryExA(W) 将 DLL 文件映射到调用进程的地址空间中</p></li><li><p>如果 DLL 文件已被映射到调用进程的地址空间里，就可以调用 GetModuleHandleA(W) 函数获得DLL 模块句柄 </p></li><li><p>一旦 DLL 模块被加载，就可以调用 GetProcAddress 函数获取输入函数的地址</p></li></ol><h5 id="解密各区块数据"><a href="#解密各区块数据" class="headerlink" title="解密各区块数据"></a><strong>解密各区块数据</strong></h5><ol><li><p>处于保护源程序代码和数据的目的，一般会加密源程序文件的各个区块。在程序执行时外壳将这些区块数据解密，以让程序正常运行</p></li><li><p>外壳一般按区块加密，按区块解密，并将解密的数据放回在合适的内存位置</p></li></ol><h5 id="跳转回原程序入口点"><a href="#跳转回原程序入口点" class="headerlink" title="跳转回原程序入口点"></a><strong>跳转回原程序入口点</strong></h5><ol><li><p>在跳转回入口点之前，一般会恢复填写原 PE 文件输入表（IAT），并处理好重定位项（主要是DLL 文件）</p></li><li><p>因为加壳时外壳自己构造了一个输入表，因此在这里需要重新对每一个 DLL 引入的所有函数重新获取地址，并填写到 IAT 表中3. 做完上述工作后，会将控制权移交原程序，并继续执行</p></li></ol><p>*《程序员的自我修养》</p><h3 id="脱壳方法论"><a href="#脱壳方法论" class="headerlink" title="脱壳方法论"></a><strong>脱壳方法论</strong></h3><p>如今脱壳主要分为两种方式，第一种方式是：</p><h4 id="工具脱壳"><a href="#工具脱壳" class="headerlink" title="工具脱壳"></a><strong>工具脱壳</strong></h4><p>所谓脱壳机是针对特定的一种或一类壳开发出来的脱壳软件，它们是由他人在逆向完壳的相关原理后编写的一类自动化工具，具有一定的局限性。</p><p>对于无法使用工具成功脱壳的情况，便需要用到第二种方式：</p><h4 id="手动脱壳（手脱）"><a href="#手动脱壳（手脱）" class="headerlink" title="手动脱壳（手脱）"></a><strong>手动脱壳（手脱）</strong></h4><p>也就是通过一步步分析程序加壳原理，手动还原原始程序的过程，通过手动脱壳，我们可以加深对 PE 格式的理解，增长自己的脱壳水平。在手脱的过程中，我们一般会涉及如下几个概念：</p><ol><li><strong>查壳</strong>。遇到一个加壳程序，第一步应该去分析这是一个什么壳保护的程序，之后我们才能更加有针对性地进行分析与跟踪，遇到难以处理的问题也可以更方便地利用搜索引擎检索同类壳的技术贴。</li></ol><p>常用的查壳工具有 PEiD、Exeinfo PE、DIE 等。</p><ol start="2"><li><p><strong>寻找程序的原入口点（OEP）</strong>。通过单步跟踪、ESP 定律、内存断点等方法找到 OEP。</p></li><li><p><strong>Dump</strong> <strong>内存</strong>。所谓 Dump 内存，指的是将一个进程的内存镜像通过某种方式抓取下来，保存至本地磁盘中，之所以需要 Dump 内存，是因为<strong>在程序执行到</strong> <strong>OEP</strong> <strong>时，内存的状态往往就与未加壳前****的程序相同</strong>（因为壳段代码已经帮我们完成了解密、解压等工作），此时我们将这个状态保存出去，再加上一些后期的修复，就能完成整个脱壳操作了。</p></li><li><p><strong>输入表（IAT）重建</strong>。在 Dump 操作结束之后，程序并不能直接运行，很大程度上是因为输入表并没有被修复好。IAT 可以根据 PE 结构手动修复，也可以通过工具完成。</p></li><li><p><strong>关闭程序重定位</strong>。</p></li></ol><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h4><ul><li>查壳</li><li>识别函数少</li><li>Ctrl-s 段名UPX*</li></ul><h3 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h3><p>手工脱壳:hw1.exe</p><h4 id="寻找OEP-ESP定律-（好用）"><a href="#寻找OEP-ESP定律-（好用）" class="headerlink" title="寻找OEP(ESP定律)（好用）"></a>寻找OEP(ESP定律)（好用）</h4><p>原理利用程序中堆栈平衡来快速寻找OEP</p><h4 id="去重定位"><a href="#去重定位" class="headerlink" title="去重定位"></a>去重定位</h4><p>用CFF小辣椒或者010都可以</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习x32dbg，x64dbg使用方法&quot;&gt;&lt;a href=&quot;#学习x32dbg，x64dbg使用方法&quot; class=&quot;headerlink&quot; title=&quot;学习x32dbg，x64dbg使用方法&quot;&gt;&lt;/a&gt;学习x32dbg，x64dbg使用方法&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="逆向学习 UPX壳" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-UPX%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>操作系统_文件管理专题</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T16:00:00.000Z</published>
    <updated>2024-01-14T14:47:01.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件管理习题"><a href="#文件管理习题" class="headerlink" title="文件管理习题"></a><strong>文件管理习题</strong></h1><p><strong>共三个习题：</strong><br>进程管理、内存管理、文件管理</p><h2 id="一、-单项选择题"><a href="#一、-单项选择题" class="headerlink" title="一、 单项选择题"></a>一、 单项选择题</h2><p>1、下列选项中，用于提高RAID可靠性的措施有 <strong>B</strong></p><p>I.磁盘镜像 II.条带化 III. 奇偶校验 IV.增加Cache机制</p><p>A.仅I、II B.仅I、IIIC.仅I、III和IV D.仅II、III和IV</p><p><strong>&#x2F;&#x2F;提高RAID可靠性措施：eg：RAID0磁盘镜像，RAID5奇偶校验</strong></p><p><a href="http://t.csdnimg.cn/Y2JQw">RAID（磁盘阵列）学习参考</a></p><p>顺便学一下：（可用容量）<br><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227232806438.png" alt="image-20231227232806438"></p><p>2、某磁盘的转速为10000转&#x2F;分，平均寻道时间是6 ms，磁盘传输速率是20 MB&#x2F;s，磁盘控制器延迟为0.2 ms，读取一个4 KB的扇区所需的平均时间约为 <strong>B</strong></p><p>A. 9 ms B. 9.4 ms C. 12 ms D. 12.4 ms</p><p><strong>&#x2F;&#x2F; 平均时间为 9.4ms。</strong></p><p><strong>第一部分 找到磁道的时间 &#x3D; 平均寻道时间&#x3D; 6ms</strong></p><p><strong>第二部分 找到扇区的时间 &#x3D; 磁盘转一圈的时间÷2（平均）&#x3D;（60 秒）&#x2F;（2*10000 转&#x2F;分）&#x3D;3ms</strong></p><p><strong>第三部分 磁盘控制器延迟时间 &#x3D; 0.2ms</strong></p><p><strong>第四部分 数据传输时间 &#x3D; 传输字节数 &#x2F; 磁盘传输速度 &#x3D; 4K &#x2F; 20M &#x3D; 0.2ms（1K≈10 的 3 次方）</strong></p><p><strong>综上 6ms+3ms+0.2ms+0.2ms&#x3D;9.4ms。</strong></p><p>3、用户在删除某文件的过程中，操作系统不可能执行的操作是  <strong>A</strong></p><p>A.删除此文件所在的目录 B.删除与此文件关联的目录项</p><p>C.删除与此文件对应的文件控制块 D.释放与此文件关联的内存缓冲区</p><p><strong>&#x2F;&#x2F;删除此文件所在的目录</strong>（要是我删文件，连该文件目录也删了那太过分了吧啊喂！！！</p><p>4、为支持CD-ROM中视频文件的快速随机播放，播放性能最好的文件数据块组织方式是 <strong>A</strong></p><p>A.连续结构 B.链式结构 </p><p>C.直接索引结构 D.多级索引结构</p><p><strong>&#x2F;&#x2F;虽然是随机播放，但毕竟还是读取文件，播放性能好-&gt;内存离得近-&gt;连续结构</strong></p><p>5、若某文件系统索引结点（inode）中有直接地址项和间接地址项，则下列选项中，与单个文件长度无关的因素是 <strong>A</strong></p><p>A.索引结点的总数 B.间接地址索引的级数 C.地址项的个数 D.文件块大小</p><p><strong>&#x2F;&#x2F;与文件长度无关-&gt;索引结点的总数，怎么索引与文件无关</strong></p><p>6、设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是  <strong>C</strong></p><p>A. 3 B. 75 C. 80 D. 63</p><p><strong>&#x2F;&#x2F;文件大小512B，第1569字节在第1569&#x2F;512&#x3D;3.06-&gt;第四页，顺序在题目上，为80</strong></p><p>7、文件系统采用两级索引分配方式。如果每个磁盘块的大小为 1KB，每个盘块号占 4B，则该系统中单个文件的最大长度是 <strong>B</strong></p><p>A. 32MB B. 64MB C. 128MB D. 256MB</p><p>**&#x2F;&#x2F;单个文件最大长度：被两级索引：[(1KB&#x2F;4B)^2]<em>4B&#x3D;64MB</em>*</p><p>8、一个磁盘的转速为 7200 转&#x2F;分，每个磁道有 160 个扇区，每个扇区为 512B，那么理想情况下，其数据传输率为  <strong>C</strong></p><p>A. 576000KB&#x2F;s B. 7200KB&#x2F;s C. 9600KB&#x2F;s D. 19200KB&#x2F;s</p><p><strong>&#x2F;&#x2F;的转速为 7200r&#x2F;min&#x3D;120r&#x2F;s，转一圈经过 160 个扇区，每个扇区有 512B 所以数据传输率为 120×160×512&#x2F;1024&#x3D;9600KB&#x2F;s。</strong>  </p><p>9、现有容量为10GB的磁盘分区，磁盘空间以簇（cluster）为单位进行分配，簇的大小为4KB。若采用位图法管理该分区的空闲空间，即用一位（bit）标识一个簇是否被分配，则存放该位图所需要簇的个数为： <strong>A</strong></p><p>A. 80 B. 320 C. 80K D. 320K </p><p><strong>&#x2F;&#x2F;10GB&#x2F;4KB&#x3D;2.5M，共有2.5M个可分配的簇， 2.5M&#x2F;8&#x3D;320KB，需要320K的字节来标记可分配的簇， 320KB&#x2F;4KB&#x3D;80个，这320KB同样是按4KB一簇在硬盘上存储，所以需要除4K，得80个簇</strong></p><p>10、 某磁盘阵列中包含 15 块 SAS 硬盘，单一硬盘的容量为 1TB。采用 RAID技术提供具备高可靠性和高可用性的数据存储方案。使用 4 块硬盘组成一个RAID10 硬盘组，8 块硬盘组成一个 RAID 5 硬盘组，3 块硬盘作为热备份硬盘。此磁盘阵列的总可用空间约为 <strong>B</strong></p><p> A. 8TB B. 9TB C. 10TB D.11TB</p><p><strong>&#x2F;&#x2F;1题要记得那个表的最后一行，一一对应，RAID10-一半，2TB；RAID5一个-8-1&#x3D;7TB，3个热备份不算，共9TB</strong></p><p>11、 设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是 <strong>C</strong></p><p>A. 3 B. 75 C. 80 D. 63</p><p><strong>&#x2F;&#x2F;怎么重复了</strong></p><p>12、 若磁盘转速为7200转&#x2F;分，平均寻道时间为8ms,每个磁道包含1000个扇区，则访问一个扇区的平均存取时间大约是 <strong>B</strong></p><p>A．8.1ms B．12.2ms C．16.3ms D．20.5ms</p><p>**&#x2F;&#x2F;磁盘的平均寻址时间包括平均寻道时间和平均等待时间。平均寻道时间为8ms，平均等待时间与磁盘转速有关，为[60s&#x2F;7200]<em>0.5  ≈4.165ms。磁盘的存取一个扇区的时间为60s&#x2F;(7200 * 1000) ≈ 0.0083ms。因此总的时间为：8   4.165    0.0083 &#x3D; 12.1733ms</em>*</p><p>13、 在文件的索引节点中存放直接索引指针10个，一级二级索引指针各1个，磁盘块大小为1KB。每个索引指针占4个字节。若某个文件的索引节点已在内存中，到把该文件的偏移量（按字节编址）为1234和307400处所在的磁盘块读入内存。需访问的磁盘块个数分别是（）</p><p>A．1，2 B．1，3 C．2，3 D．2，4</p><p><strong>&#x2F;&#x2F;直接索引指针所在位置大小 10*1KB ；一级 (1KB&#x2F;4B) *1KB&#x3D;256KB; 二级 [(1KB&#x2F;4B)^2] *1KB</strong></p><p><strong>1234B-&gt;小于10KB，磁盘块1</strong></p><p><strong>307400B-&gt;大于10KB+256KB-&gt;磁盘块3</strong></p><p>14、 假设磁头当前位于第 100 道,正在向磁道序号增加的方向移动。现有一3个磁道访问请求序列为 35,68,110,180,采用 SSTF （最近寻道优先）调度算法得到的磁道访问序列是 ______。<strong>D</strong></p><p>A. 35,68,110,180 B. 110,180,35,68 C. 110,180,68,35 D. 110,68,35,180</p><p><strong>&#x2F;&#x2F;学会（看大题2，3题），学最近寻道优先，很简单</strong></p><p>在某UNIX操作系统中，文件系统给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含13个直接块指针、1个一级间接块指针和1个二级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小一致，均为1KB，地址指针所占空间为4B。</p><p>15、 若某inode共有2个硬链接（hard link），分别为a和b，另有1个符号链接（symbolic link）x-&gt;a，则该inode的link counter为______。 <strong>C</strong></p><p>A．0 B．1 C．2 D．3</p><p><strong>&#x2F;&#x2F;不算符号链接，所以link counter 为 2</strong> </p><p><a href="http://t.csdnimg.cn/ZLrNn">硬链接和符号链接详解</a></p><p>16、 将a删除后，访问x，结果为______。 <strong>A</strong></p><p>A．提示文件不存在 B．打开文件b C．打开一个空文件 D．x已被删除</p><p><strong>&#x2F;&#x2F;提示文件不存在，实践经历（</strong></p><p>17、 假设该索引节点已经被加载进内存中，则若要读取文件的第1MB的内容，需要访问磁盘___3____次。</p><p>A．1 B．2 C．3 D．4 </p><p><strong>&#x2F;&#x2F;直接块指针13个：13KB</strong></p><p>*<em>一级1个，(1KB&#x2F;4B)<em>1KB&#x3D;256KB</em></em></p><p>*<em>二级1个，[(1KB&#x2F;4B)^2]<em>1KB&#x3D;64MB</em></em></p><p><strong>所以需要3次访问磁盘，需要访问二个索引块和一个数据块</strong></p><p>18、 该文件系统能支持的文件最大容量约为_______<strong>B</strong></p><p>A．64KB B．64MB C．4GB ．16GB</p><p><strong>&#x2F;&#x2F;根据上题，最大为64MB</strong></p><p>19、 若将数据块的大小修改为4KB，则该文件系统能支持的文件最大容量约为________。 <strong>C</strong></p><p>A．64KB B．64MB C．4GB ．16GB</p><p>**&#x2F;&#x2F; [(4KB&#x2F;4B)^2]<em>4KB&#x3D;4GB</em>*</p><p>20、 若保持数据块大小1KB不变，在不增加inode中的指针个数的前提下，取</p><p>消一个直接块指针，增加一个三级间接块指针，则能支持的文件最大容量约</p><p>为________。 <strong>D</strong></p><p>A．64KB B．64MB C．4GB D．16GB</p><p>**&#x2F;&#x2F; [(1KB&#x2F;4B)^3]<em>1KB&#x3D;16GB</em>*</p><h2 id="二、-计算问答题"><a href="#二、-计算问答题" class="headerlink" title="二、 计算问答题"></a>二、 计算问答题</h2><p>1、某操作系统中，给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含 12 个直接块指针和 1 个一级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小均为一个扇区，即 512B，地址指针所占空间为 4B。</p><p>1） 该文件系统能支持的文件最大容量是____(1)____。</p><p>2） 为了支持更大的文件，在不增加 inode 中的指针个数的前提下，取消一4个直接块指针，增加一个二级间接块指针，则能支持的文件最大容量是____(2)____。</p><p>3） 在上一问的基础上，若将数据块的大小修改为 1KB，则该文件系统能支持的文件最大容量是____(3)____。</p><p>4） 在上一问的基础上，假设该索引节点已经被加载进内存中，则若要读取文件的第 10MB 的内容，需要访问磁盘____(4)____次。</p><p>*<em>答：（1）(12+(512&#x2F;4))<em>512B&#x3D;71680B&#x3D;70KB</em></em></p><p>*<em>（2）(11+(512&#x2F;4)+ (512&#x2F;4)^2)<em>512B&#x3D;8459776B&#x3D;8261.5KB&#x3D;8.068MB</em></em></p><p>*<em>（3）(11+(1024&#x2F;4)+(1024&#x2F;4)^2)<em>1024B&#x3D;65803KB&#x3D;64.261MB</em></em></p><p><strong>（4）3 次．由上一问知，10MB 需要通过二级间接索引访问，故需要访问二个索引块和一个数据块。</strong></p><p>2、在 inode 的多级索引指针中，为什么保留了直接指向数据块的指针，而不是设计成只使用一个指向多级间接索引块的指针，就可以访问到所有的数据块？数据块的大小可以影响文件系统能支持的最大文件的大小，但是数据块的大小对文件系统的性能和空间利用率之间有什么关系？为什么？</p><p><strong>答：直接指针访问速度快，适合小文件。</strong></p><p><strong>数据块增大，传输数据的单位容量增大，传输效率提升，性能上升。</strong></p><p><strong>数据块增大，则文件存储分配单位变大，内部剩余增加，空间利用率下降。</strong></p><p><strong>数据块减小则情况相反。</strong></p><p>3、若干个等待访问磁盘者依次要访问的柱面为 20,44,40,4,80,12,76，假设每移动一个柱面需要 3ms 时间，移动臂当前位于 40 号柱面，磁头正向磁道号增加的方向移动，请按 FCFS, SSTF, SCAN 算法分别计算为完成上述访问总共花费的寻找时间。</p><p><em><em>FCFS：（|20-40| + |44-20| + |40-44| + |4-40| + |80-4| + |12-80| + |76-12|）</em> 3 &#x3D;</em>* </p><p>**(20+24+4+36+76+68+64)<em>3 &#x3D; 876ms</em>* </p><p><strong>SSTF： 40 - 44 - 20 - 12 – 4 - 76 – 80</strong> </p><p><em><em>（4+24+8+8+72+4）</em> 3 &#x3D; 360 ms</em>*</p><p><strong>SCAN：40 – 44 – 76 – 80 – 20 – 12 - 4</strong> </p><p><em><em>（4+32+4+60+8+8）</em> 3 &#x3D; 348 ms</em>*</p><p>4、假设计算机系统采用 CSCAN(循环扫描)磁盘调度策略,使用 2KB 的内存空间记录 16384 个磁盘块的空闲状态。</p><p>(1) 请说明在上述条件下如何进行磁盘块空闲状态的管理。</p><p>(2) 设某单面磁盘旋转速度为每分钟6000 转,每个磁道有100 个扇区,相邻磁道间的平均移动时间为1ms。若在某时刻,磁头位于100 号磁道处,并沿着磁道号增大的方向移动(如下图所示),磁道号请求队列为50,90,30,120,对请求队列中的每个磁道需读取1 个随机分布的扇区,则读完这4 个扇区点共需要多少时间?要求给出计算过程。</p><p>(3) 如果将磁盘替换为随机访问的Flash 半导体存储器(如U 盘、SSD 等),是否有比CSCAN 更高效的磁盘调度策略?若有,给出磁盘调度策略的名称并说明理由;若无,说明理由。</p><p><strong>(1) 位图法</strong></p><blockquote><p>在CSCAN磁盘调度策略下，管理磁盘块的空闲状态可以采用位图的方式进行。位图是一种数据结构，用于表示磁盘块的分配状态，每个磁盘块用一个比特位来表示其状态（已分配或空闲）。</p><p>给定16384个磁盘块，每个块用一个比特位来表示其状态，所需的比特数可以通过以下方式计算：</p><p>16384个块 ÷ 8位&#x2F;字节 &#x3D; 2048字节 ÷ 1024字节&#x2F;KB &#x3D; 2KB</p><p>因此，需要2KB的内存空间来记录这些磁盘块的空闲状态。</p><p>管理这个位图时，通过初始化所有比特位为“0”来表示所有磁盘块都是空闲的状态。当磁盘块被分配时，相应的比特位被设置为“1”表示已被占用。当磁盘块被释放时，相应的比特位重新设置为“0”以表示它变为空闲状态。</p><p>CSCAN调度算法将磁盘的访问方向限制在一个特定的范围内移动，这使得磁盘空间的管理可以更加高效地实现。</p></blockquote><p><strong>(2) CSCAN：190.4 ms</strong></p><p><strong>寻道时间：|120-100| + |30-120| + |50-30| + |90-50| &#x3D; 170ms</strong></p><p><strong>旋转时间：10ms&#x2F;2*4 &#x3D; 20ms</strong></p><p><strong>读数据：10ms&#x2F;100 * 4 &#x3D; 0.4ms</strong></p><p><strong>(3) FCFS</strong></p><p>ps：</p><blockquote><p><strong>当参加天津大学智算学部“操作系统原理”课程期末考试时</strong></p><p>1．SCAN 算法，磁臂从磁盘的一端向另一端移动，当磁头移过每一个</p><p>柱面时，处理位于该柱面上的请求服务。当到达另一端时，改变方向</p><p>继续处理。（每次都运动到顶端）</p><p>2．C-SCAN 算法，C-SCAN 也是将磁头从磁盘一端移到另一端，随着</p><p>移动不断的处理请求。但是，当磁头移到另一端时，会马上返回到磁</p><p>盘开始，返回时不处理请求.（每次都运动到顶端）</p><p>3．LOOK 算法：是改进的 SCAN 算法，处理过程与 SCAN 相似，只是</p><p>每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。</p><p>4．C-LOOK 算法：是改进的 C-SCAN 算法，处理过程与 C-SCAN 相似，</p><p>只是每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。 </p><p><strong>非期末考试时（如阅读其他教参时、做作业时等）</strong></p><p>SCAN 算法＝LOOK 算法&#x3D;上面第 3 条描述（两头不到顶）</p><p>C-SCAN 算法＝C-LOOK 算法&#x3D;上面第 4 条描述（两头不到顶）</p></blockquote><p>整理自：<a href="https://blog.csdn.net/m0_73495245?type=blog">Wind_9233</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件管理习题&quot;&gt;&lt;a href=&quot;#文件管理习题&quot; class=&quot;headerlink&quot; title=&quot;文件管理习题&quot;&gt;&lt;/a&gt;&lt;strong&gt;文件管理习题&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;共三个习题：&lt;/strong&gt;&lt;br&gt;进程管理、内存管理、</summary>
      
    
    
    
    
    <category term="操作系统_文件管理专题" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T15:12:41.862Z</published>
    <updated>2023-12-27T15:12:42.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理习题！"><a href="#进程管理习题！" class="headerlink" title="进程管理习题！"></a>进程管理习题！</h1><h2 id="一、-单项选择题"><a href="#一、-单项选择题" class="headerlink" title="一、 单项选择题"></a>一、 单项选择题</h2><p>1、设与某资源关联的记录型信号量初值为 1,当前值为 -3。则当前因等待使用该资源而处于阻塞态的进程个数为______。</p><p> A.1 B.0 C.3 D.4</p><p>2、当一个进程处于（ ）状态时，称其为等待（或阻塞）状态。 </p><p>A. 它正等待中央处理机 B. 它正等待合作进程的一个消息 </p><p>C. 它正等待分给它一个时间片 D. 它正等待进入内存</p><p>3、下面关于线程的叙述中，正确的是（ ）。</p><p> A.不论是系统支持线程还是用户级线程，其切换都需要内核的支持。</p><p> B.线程是资源的分配单位，进程是调度和分配的单位。</p><p> C.不管系统中是否有线程，进程都是拥有资源的独立单位。</p><p> D.在引入线程的系统中，进程仍是资源分配和调度分派的基本单位。</p><p>4、资源的按序分配策略可以破坏______条件。</p><p>A. 互斥使用资源 B. 占有且等待资源 C. 非抢夺资源 D. 循环等待资源</p><p>5、下列选项中，会导致用户进程从用户态切换到内核态的操作是</p><p>I.整数除以零 II. sin()函数调用 III. read系统调用</p><p>A.仅I、II B.仅I、III C.仅II、III D. I、II和III</p><p>6、下列关于银行家算法的叙述中，正确的是</p><p>A. 银行家算法可以预防死锁 </p><p>B. 当系统处于安全状态时，系统中一定无死锁进程</p><p>C. 当系统处于不安全状态时，系统中一定会出现死锁进程</p><p>D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件2</p><p>7、有 5 个批处理任务 A、B、C、D、E 几乎同时到达一个计算中心。它们预计运行的时间分别是 10min、6min、2min、4min 和 8min。其优先级（由外部设定）分别为 3、5、2、1 和</p><p>4，这里 5 为最高优先级。下列各种调度算法中，其平均进程周转时间为 14min 的是</p><p>A. 时间片轮转调度算法 B. 优先级调度算法</p><p>C. 先来先服务调度算法 D. 最短作业优先算法</p><p>8、可以被多个进程在任意时刻共享的代码必须是________。</p><p>A. 顺序代码 B. 机器语言代码 C.不能自身修改的代码 D. 无转移指令代码</p><p>9、设m为同类资源数，n为系统中并发线程数。当n个进程共享m个互斥资源时，每个进程的最大需求是w；则下列情况会出现系统死锁的是：</p><p>A. m&#x3D;2,n&#x3D;1,w&#x3D;2 B. m&#x3D;2,n&#x3D;2,w&#x3D;1 C. m&#x3D;4,n&#x3D;3,w&#x3D;2 D. m&#x3D;4,n&#x3D;2,w&#x3D;3</p><p>10、 下列调度算法中，不可能导致饥饿现象的是：</p><p>A.时间片轮转 B.静态优先级调度 </p><p>C.非抢占式作业优先 D.抢占式短作业优先</p><p>11、 某系统有n台互斥使用的同类设备，3个并发进程，最多分别需要3,4,5台设备，可确保系统不会发生死锁的设备数n最少为：</p><p>A. 9 B. 10 C. 11 D. 12</p><p>12、 下列指令中，不能在用户态执行的是：</p><p>A.trap 指令 B.跳转指令 C. 压栈指令 D.关中断指令</p><p>13、 一个进程调用了阻塞式系统调用read()进行读磁盘操作，操作完成后，操作系统针对该进程必须做的是：</p><p>A.修改进程状态为就绪态 B.降低进程优先级</p><p>C.进程分配用户内存空间 D.增加进程的时间片大小</p><p>设系统中有三种类型的资源（A、B、C），它们的资源数量分别是 17、5、20，五个进程（P1，</p><p>P2，P3，P4，P5）。在 T0 时刻系统状态如下表所示，系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230517556.png" alt="image-20231227230517556"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230525378.png" alt="image-20231227230525378"></p><p>14、 在T0时刻若进程P2请求资源（0,3,4），是否能实施分配？为什么？</p><p>A. 不可以，因为无足够资源完成分配。</p><p>B. 不可以，因为分配后进入不安全状态。</p><p>C. 可以，分配后存在安全序列 P4-&gt;P2-&gt;P5-&gt;P3-&gt;P1。</p><p>D. 可以，分配后存在安全序列 P2-&gt;P5-&gt;P4-&gt;P1-&gt;P3。</p><p>假定在单道批处理环境下有5个作业，各作业进入系统的时间和估计运行时间如下表所示：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230539993.png" alt="image-20231227230539993"></p><p>15、 如果应用最短作业优先的作业调度算法，则作业的平均周转时间为______分钟。</p><p> A. 50.3 B. 77.4 C. 37.2 D. 43.4</p><p>16、 某系统正在执行三个进程 P1、P2 和 P3，各进程的计算（CPU）时间和 I&#x2F;O 时间比</p><p>例如下表所示。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230555000.png" alt="image-20231227230555000"></p><p>为提高系统资源利用率，合理的进程优先级设置应为</p><p>A. P1&gt;P2&gt;P3 B. P3&gt;P2&gt;P1 C. P2&gt;P1&#x3D;P3 D. P1&gt;P2&#x3D;P3</p><p>17、 中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调4用不需要保存的是</p><p>A. 程序计数器 B. 程序状态字寄存器C. 通用数据寄存器 D. 通用地址寄存器</p><p>18、 有 5 个批处理任务 A、B、C、D、E 几乎同时到达一个计算中心。它们预计运行的时间分别是 10min、6min、2min、4min 和 8min。其优先级（由外部设定）分别为 3、5、2、1 和 4，这里 5 为最高优先级。下列各种调度算法中，其平均进程周转时间为 14min 的</p><p>是</p><p>A. 时间片轮转调度算法 B. 优先级调度算法</p><p>C. 先来先服务调度算法 D. 最短作业优先算法</p><p>19、 </p><p>一个多道批处理系统中仅有P1和P2两个作业，P2比P1晚5 ms到达。它们的计算和I&#x2F;O操作顺序如下：</p><p>P1：计算 60 ms，I&#x2F;O 80 ms，计算 20 ms</p><p>P2：计算 120 ms，I&#x2F;O 40 ms，计算 40 ms</p><p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是</p><p>A. 240 ms B. 260 ms C. 340 ms D. 360ms</p><p>20、 若某单处理器多进程系统中有多个就绪态进程，则下列关于处理机调度的叙述中错误的是</p><p>A. 在进程结束时能进行处理机调度 B. 创建新进程后能进行处理机调度</p><p>C. 在进程处于临界区时不能进行处理机调度</p><p>D. 在系统调用完成并返回用户态时能进行处理机调度</p><p>21、 下列关于进程和线程的叙述中，正确的是</p><p>A. 不管系统是否支持线程，进程都是资源分配的基本单位</p><p>B. 线程是资源分配的基本单位，进程是调度的基本单位</p><p>C. 系统级线程和用户级线程的切换都需要内核的支持</p><p>D. 同一进程中的各个线程拥有各自不同的地址空间</p><p>22、 下列关于银行家算法的叙述中，正确的是</p><p>A. 银行家算法可以预防死锁</p><p>B. 当系统处于安全状态时，系统中一定无死锁进程5</p><p>C. 当系统处于不安全状态时，系统中一定会出现死锁进程</p><p>D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件</p><p>23、 若一个用户过程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过</p><p>程的叙述中，正确的是</p><p>Ⅰ. 若该文件的数据不在内存，则该进程进入睡眠等待状态</p><p>Ⅱ. 请求 read 系统调用会导致 CPU 从用户态切换到核心态</p><p>Ⅲ. read 系统调用的参数应包含文件的名称</p><p>A. 仅Ⅰ、Ⅱ </p><p>B. 仅Ⅰ、Ⅲ </p><p>C. 仅Ⅱ、Ⅲ </p><p>D. Ⅰ、Ⅱ和Ⅲ</p><p>24、 假设5个进程P0、P1、P2、P3、P4的共享3类资源R1、R2、R3，这些资源总数分别</p><p>为18、6、22。T0时刻的资源分配情况如下表所示，此时存在的一个安全序列是</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230612035.png" alt="image-20231227230612035"></p><p>A. P0，P2，P4，P1，P3 </p><p>B. P1，P0，P3，P4，P2</p><p>C. P2，P1，P0，P3，P4 </p><p>D. P3，P4，P2，P1，P0</p><p>25、 设有3个进程共享一个互斥段，如果最多允许有2个进程同时进入互斥段，则所采用的信号量的初值应是（ ）：</p><p>A．2 B．3 C．1 D．0</p><p>26、 两个进程合作完成一个任务。在并发执行中，一个进程要等待其合作伙伴发来消息，或者建立某个条件后再向前执行，这种制约性合作关系被称为进程的（ ）。</p><p>A．同步 B．互斥 C．调度 D．执行</p><p>27、 设备分配问题中，算法实现时，同样要考虑安全性问题，防止在多个进程进行设备请求时，因相互等待对方释放所占设备所造成的（ ）现象。6</p><p>A．瓶颈 B．碎片 C．系统抖动 D．死锁</p><p>28、 下列进程状态的转换中，哪一个是不正确的（ ）。</p><p>A．就绪-&gt;运行 B．运行-&gt;就绪 C．就绪-&gt;阻塞 D．阻塞-&gt;就绪</p><p>29、 在多进程的系统中，为了保证公共变量的完整性，各进程应互斥进入临界区。所</p><p>谓临界区是指______。</p><p>A．一个缓冲区 B．一段数据区 C．同步机制 D．一段程序</p><p>假设系统中有 4 个进程和 4 个可分配资源，当前分配和最大需求如下表所示，已知资源的最大拥有量为 E&#x3D;（12，9，5，4）。系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230628809.png" alt="image-20231227230628809"></p><p>30、 在当前时刻若进程2请求资源（0,1,0,0），是否能实施分配？若能，给出安全序列。</p><p>A．不能分配，因为分配后不存在安全序列。</p><p>B．不能分配，因为资源不足。</p><p>C．能分配，分配后存在安全序列 3-&gt;4-&gt;2-&gt;1</p><p>D．能分配，分配后存在安全序列 3-&gt;4-&gt;1-&gt;2</p><p>有 6 个 CPU 密集型批处理作业 A、B、C、D、E 和 F，几乎同时被提交。预计运行时间分别为 12，6，2，4，8 和 2 分钟。对于下列每种调度算法，忽略进程切换的开销，计算其平均进程周转时间。</p><p>31、 设进程A-F的优先级分别为4，6，3，2，5和1，其中1为最高优先级。则采用优先级调度算法，平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟</p><p>32、 采用先来先服务调度算法，按照A、B、C、D、E和F的顺序运行。则平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟7</p><p>33、 采用最短作业优先调度算法，平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟</p><p>34、 某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的输入、计算和输出时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执行，则执行完3个作业需要的时间最少是______。</p><p>A. 15ms B. 17ms C. 22ms D.27ms</p><p>35、 系统中有3个不同的临界资源R1、R2和R3，被4个进程P1、P2、P3和P4共享。各进程对资源的需求为：P1申请R1和R2，P2申请R2和R3，P3申请R1和R3，P4申请R2。若系统出现死锁，则处于死锁状态的进程数至少是______。</p><p>A. 1 B. 2 C. 3 D.4</p><p>36、 进程P1和P2均包含并发执行的线程，部分伪代码描述如下所示：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230643549.png" alt="image-20231227230643549"></p><p>下列选项中，需要互斥执行的操作是______。</p><p>A. a&#x3D;1 与 a&#x3D;2 B. a&#x3D;x 和 b&#x3D;x C. x+&#x3D;1 与 x+&#x3D;2 D. x+&#x3D;1 与 x+&#x3D;3</p><p>假设系统中有 4 个进程和 1 个可分配资源，当前分配和最大需求如下表所示，已知资源的总量为 100。系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230701803.png" alt="image-20231227230701803"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230708036.png" alt="image-20231227230708036"></p><p>37、 在当前时刻若进程2请求该资源数量为10，是否能实施分配？若能，给出安全序列。</p><p>A．不能分配，因为分配后不存在安全序列。</p><p>B．不能分配，因为资源不足。</p><p>C．能分配，分配后存在安全序列 3-&gt;4-&gt;2-&gt;1</p><p>D．能分配，分配后存在安全序列 3-&gt;4-&gt;1-&gt;2</p><h2 id="二、-简答题"><a href="#二、-简答题" class="headerlink" title="二、 简答题"></a>二、 简答题</h2><p>1、你需要在一个很古老的 UNIX 上编写支持多线程的程序，它的内核不支持线程，内核代码也未公开，所以很难改造内核。请问如何解决这个问题？</p><p>2、在 UNIX 中父进程通过 fork()产生与自己一模一样的子进程，请问执行什么系统调用后，子进程才拥有自己独立的新代码段。这个系统调用的返回值是如何规定的？</p><p>3、当检测到死锁发生时，如果必须杀死一个进程以解除死锁，请问以什么标准来选择被杀死的进程比较合理？</p><p>4、在一单道批处理系统中，一组作业的提交时刻和运行时间如下表所示。试计算一下三种作业调度算法的平均周转时间 T 和平均带权周转时间 W。 (1) 先来先服务; (2) 短作业优先 (3) 高响应比优先。作业提交时刻和运行时间如下表</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230719689.png" alt="image-20231227230719689"></p><p>5、设系统中有 3 种类型的资源(A，B，C)和 5 个进程(P1，P2，P3，P4，P5)，A 资源的数量为 17，B 资源的数量为 5，C 资源的数量为 20。在 T0 时刻系统状态表如下表所示。<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230729750.png" alt="image-20231227230729750"></p><p>系统采用银行家算法试试死锁避免策略。</p><p>(1) T0 时刻是否为安全状态?若是，请给出安全序列。</p><p>(2) 在 T0 时刻若进程 P2 请求资源(0,3,4)，是否能实施资源分配?为什么?</p><p>(3) 在(2)的基础上，若进程 P4 请求资源(2,0,1)，是否能实施资源分配?为什么?</p><p>(4) 在(3)的基础上，若进程 P1 请求资源(0,2,0)，是否能实施资源分配?为什么?</p><p>6、某系统有 R1,R2,R3 共 3 类资源，在 T0 时刻 P1,P2,P3 和 P4 这 4 个进程对资源的占用和 需求情况见下表，此刻系统可用资源向量为(2,1,2）</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230747261.png" alt="image-20231227230747261"></p><p>问题:</p><p> (1)将系统中各种资源总量和此刻各进程对各资源的需求数目用向量或矩阵表示出来</p><p>(2)如果此时 P1,P2 均发出资源请求向量 Request(1,0,1),为了保持系统的安全性应该如 何分配资源?说明你所采用策略的原因。</p><p>(3)如果(2)中两个请求立刻得到满足后，系统此刻是否处于死锁状态?</p><p>7、设有 3 个进程 P、Q、R，它们共享 10 个同类资源，P、Q、R 进程的资源最大需求量依次为 4、7 和 8。现假定它们对资源的请示序列如下表所示:</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230759306.png" alt="image-20231227230759306"></p><p>为了避免死锁，系统分配资源时采用银行家算法。如果申请资源得不到满足，进程就转入阻塞态。根据上述信息，试描述各步骤结束时，申请资源的进程是得到满足，还是转入阻塞状 态，为什么?(起始状态:各进程均不拥有资源，无进程处于阻塞态)</p><p>8、分时操作系统中进程调度算法中对普通进程常常采用的是优先级轮转法，请问如何保证不会有进程因为优先级太低而饥饿？</p><p>9、死锁是一种对操作系统正常运行危害很大的现象，但是大多数死锁的解决方法只停留在理论探讨中，无法应用于实际的操作系统系统。请列举中哪些方法是实际操作系统中采用的应对死锁的可行方法。如果操作系统发现死锁已经发生，应如何应对使造成的损失较小？</p><p>10、 假定下面的 C 语言程序在 UNIX 系统上运行，并且所有系统调用都能成功完成。其中“pthread_create(&amp;t, NULL, bar, NULL);”的功能是创建一个新线程来执行函数bar，并返回线程对象标识 t。“pthread_join(t,NULL);”的功能是等待线程 t 结束。试问此程序在运行过程中会打印出多少个“hello”？需要说明分析过程。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230857634.png" alt="image-20231227230857634"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230904055.png" alt="image-20231227230904055"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程管理习题！&quot;&gt;&lt;a href=&quot;#进程管理习题！&quot; class=&quot;headerlink&quot; title=&quot;进程管理习题！&quot;&gt;&lt;/a&gt;进程管理习题！&lt;/h1&gt;&lt;h2 id=&quot;一、-单项选择题&quot;&gt;&lt;a href=&quot;#一、-单项选择题&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T15:04:10.874Z</published>
    <updated>2023-12-27T15:04:11.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理习题"><a href="#内存管理习题" class="headerlink" title="内存管理习题"></a>内存管理习题</h1><h2 id="⼀、-选择题"><a href="#⼀、-选择题" class="headerlink" title="⼀、 选择题"></a>⼀、 选择题</h2><p>1、设备分配问题中，算法实现时，同样要考虑安全性问题，防⽌在多个进程进⾏设备请求时，因相互等待对⽅释放所占设备所造成的（ D）现象。</p><p>A．瓶颈 B．碎⽚ C．系统抖动 D．死锁</p><p>&#x2F;&#x2F;概念题</p><p>2、主存与辅存间频繁的页⾯置换现象被称为（C ）。</p><p>A．请求调页 B．碎⽚整理 C．系统抖动 D．输⼊输出</p><p>&#x2F;&#x2F;概念题</p><p>3、在可变分区存储管理中，最差适应分配算法要求对空闲区表项按（C ）进⾏排列。</p><p>A．地址从⼤到⼩ B．地址从⼩到⼤ C．尺⼨从⼤到⼩ D．尺⼨从⼩到⼤</p><p>&#x2F;&#x2F;概念题</p><p>4、段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管</p><p>理的基本思想，即（B）。</p><p> A、⽤分段⽅法来分配和管理物理存储空间，⽤分页⽅法来管理⽤户地址空间。 </p><p> B、⽤分段⽅法来分配和管理⽤户地址空间，⽤分页⽅法来管理物理存储空间。 </p><p> C、⽤分段⽅法来分配和管理主存空间，⽤分页⽅法来管理辅存空间。 </p><p>D、⽤分段⽅法来分配和管理辅存空间，⽤分页⽅法来管理主存空间。</p><p>&#x2F;&#x2F;概念题：先分段再分页</p><p>5、下列措施中，能加快虚实地址转换的是：（C）</p><p>I. 增⼤快表（TLB） II. 让页表常驻内存 III. 增加交换区</p><p>A. 仅 I B. 仅 II C. 仅 I,II D. 仅 II,III</p><p>6、在页式存储管理系统中，采⽤某些页⾯置换算法，会出现Belady异常现象，即进程的缺页次数会随着分配给该进程的页框个数的增加⽽增加。下列算法中，可能出现Belady异常现象的是：</p><p>I. LRU 算法 II. FIFO 算法 III. OPT 算法</p><p>A. 仅 II B.仅 I,II C. 仅 I,III D. 仅 II,III2</p><p>7、下列选项中，属于多级页表优点的是：</p><p>A.加快地址变换速度 </p><p>B.减少缺页中断次数</p><p>C. 减少⼀个页表项所占字节数 </p><p>D.减少页表所占的内存空间</p><p>8、下列关于虚拟存储器的叙述中，正确的是</p><p>A. 虚拟存储器只能基于连续分配技术 B. 虚拟存储器只能基于⾮连续分配技术</p><p>C. 虚拟存储器只受外存容量的限制 D. 虚拟存储器只受内存容量的限制</p><p>9、在⼀个请求分页系统中，采⽤ LRU 页⾯转换算法时，加⼊⼀个作业的页⾯⾛向为：</p><p>1，3，2，1，1，3，5，1，3，2，1，5.当分配给该作业的物理块数分别为 3 和 4 时，在</p><p>访问过程中所发⽣的缺页率为</p><p>A. 25%，33% B. 50%，25% C.50%,33% D. 50%，75%</p><p>10、 设有 8 页的逻辑空间，每页有 1024B,它们被映射到 32 块的物理存储区中。那么，</p><p>逻辑地址的有效位是_______位，物理地址⾄少是________位。</p><p>A. 10、11 </p><p>B. 12、14 </p><p>C. 13、15 </p><p>D. 14、16</p><p>11、 某作业的逻辑地址空间为4页，页⾯⼤⼩为2048，已知页表如下所⽰，则逻辑地址</p><p>4865（⼗进制）对应的物理地址为（ ）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227224908008.png" alt="image-20231227224908008"></p><p>A、4865 B、8961 C、13057 D、6865</p><p>12、 若⽤户进程访问内存时产⽣缺页，则下列选项中，操作系统可能执⾏的操作是</p><p>I.处理越界错 </p><p>II.置换页 </p><p>III.分配内存</p><p>A.仅I、II B.仅II、III C. 仅I、III D. I、II和III</p><p>13、 可以被多个进程在任意时刻共享的代码必须是________。</p><p>A. 顺序代码 B. 机器语⾔代码 C.不能⾃⾝修改的代码 D. ⽆转移指令代码</p><p>14、 假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000 H；地址 1000H 中</p><p>的内容为 2000H，地址 2000H 中的内容为 3000H，地址 3000 H 中的内容为 4000H，则变3</p><p>址寻址⽅式下访问到的操作数是： </p><p>A. 1000H B. 2000H C. 3000H D. 4000 H</p><p>15、 有⼀个整数矩阵为 100 ⾏*200 列，即 a[100][200]。在⼀个虚拟系统中，采⽤ LRU 算</p><p>法，系统分给该进程 5 个页⾯来存储数据（不包含程序），设每页可存放 200 个整数，该</p><p>程序要对整个数组初始化，数组存储时是按⾏存放的。试计算下列两个程序各⾃的缺页</p><p>次数（假定所有页都以请求⽅式调⼊）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225029374.png" alt="image-20231227225029374"></p><p>A. 100,200 B. 100,20000 C. 200,100 D. 20000,100</p><p>16、 考虑页⾯置换算法，系统有 m 个物理块供调度，初始时全空，页⾯引⽤串长度为</p><p>p，包含了 n 个不同的页号，⽆论⽤什么算法，缺页次数不会少于（ ）</p><p>A、m B、p C、n D、min(m,n)</p><p>17、 总体上说，“按需调页”（Demand-Paging）是个很好的虚拟内存管理策略。但是，</p><p>有些程序设计技术并不适合于这适种环境。例如（ ）</p><p>A、堆栈 B、线性搜索 C、⽮量运算 D、⼆分法搜索</p><p>18、 把进程地址空间中使⽤的逻辑地址变成内存中物理地址的过程称为：</p><p>A、重定位 B、物理化 C、逻辑化 D、加载</p><p>19、 在可变分区存储管理中，最佳适应分配算法要求对空闲区表项按（ ）进⾏排列。</p><p>A、地址从⼤到⼩ B、地址从⼩到⼤ C、尺⼨从⼤到⼩ D、尺⼨从⼩到⼤</p><p>20、 主存与辅存间频繁的页⾯置换现象被称为（ ）。</p><p>A、请求调页 B、碎⽚整理 C、系统抖动 D、输⼊输出</p><p>21、 某作业的逻辑地址空间为 4 页，页⾯⼤⼩为 2048，已知页表如下所⽰，则逻辑地址4865（⼗进制）对应的物理地址为（ ）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225202115.png" alt="image-20231227225202115"></p><p>A、4865 B、8961 C、13057 D、6865</p><h2 id="⼆、-计算题（选择）"><a href="#⼆、-计算题（选择）" class="headerlink" title="⼆、 计算题（选择）"></a>⼆、 计算题（选择）</h2><p>某操作系统中，进程的逻辑地址空间和系统的物理地址空间均为 64KB，按字节编址。某进程最多需要 8 页（Page）数据存储空间，页的⼤⼩为 2KB，操作系统采⽤固定分配局部置换策略为此进程分配 6 个页框（Page Frame），采⽤⽼化算法（aging）进⾏页⾯置换，每个页⾯使⽤ 8bits 记录使⽤情况。在每个 clock tick结束时，6 个页⾯的 R 位如下所⽰：<br><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225259459.png" alt="image-20231227225259459"></p><p>页表存放在主存中，对主存的⼀次存取需要100ns，对TLB表的查找时间为10ns，处理</p><p>⼀次缺页中断需要10^8 ns（10的8次⽅ns，含更新TLB和慢表的时间）。</p><p>22、 如果现在程序执⾏时遇到逻辑地址1AC5H，这次访问耗费时间为______。</p><p>A. 108 +220ns B. 100ns C. 110ns D. 210ns</p><p>23、 然后，程序执⾏时遇到逻辑地址32C5H，这次访问耗费时间为______。5</p><p>A. 108 +220ns B. 100ns C. 110ns D. 210ns</p><p>24、 32C5H对应的物理地址为______。</p><p>A. 7AC5H B. 22C5H C. 3AC5H D. F2C5H</p><p> 有⼀个整数矩阵为 100 ⾏*100 列，即 a[100][100]。系统分给该进程 5 个页⾯来存储此矩阵，设每页可存放 100 个整数，该程序要对整个数组初始化，数组存储时是按⾏存放的。页⾯采⽤ LRU 页⾯置换算法和局部置换策略。试计算下列两个程序各⾃的缺页次数（假定所有页都以请求⽅式调⼊）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225458098.png" alt="image-20231227225458098"></p><p>25、 程序⼀执⾏时产⽣的缺页中断次数为________。</p><p>A. 20 B. 100 C. 2000 D. 10000</p><p>26、 程序⼆执⾏时产⽣的缺页中断次数为________。</p><p>A. 20 B. 100 C. 2000 D. 10000</p><p>某计算机主存按字节编址，逻辑地址和物理地址都是 32 位，页⾯⼤⼩为 4KB，页表项⼤⼩为 4 字节。请回答下列问题。</p><p>27、 若使⽤⼀级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225436229.png" alt="image-20231227225436229"></p><p>此时页表最⼤占⽤空间为_______。</p><p>A. 4KB </p><p>B. 1MB </p><p>C. 4MB </p><p>D. 32MB</p><p>28、 若使⽤⼆级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225447428.png" alt="image-20231227225447428"></p><p>若该进程共⽤到了10000个页，则此时此⼆级页表占⽤的总空间最⼩为_______。</p><p>A. 4KB </p><p>B. 11KB </p><p>C. 44KB </p><p>D. 11MB</p><p>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 1KB，逻辑地址空间为 32 位，物理地址空间⼤⼩为 4 GB，按字节编址。页表采⽤多级页表，⼀个页表项⼤⼩为 4B。TLB（快表）采⽤全相联映射，有 4 个页表项，内容如下表所⽰。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225522350.png" alt="image-20231227225522350"></p><p>29、 该系统的页表项中，最多可以保存_______位标志位。</p><p>A．8 B．10 C．12 D．16</p><p>30、 若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤______级页</p><p>表较合适。</p><p>A．0 B．1 C．2 D．3</p><p>31、 对逻辑地址3FFF1880H转换为物理地址的结果是______。</p><p>A. 0C153080H B. 0F035880H C. TLB 缺失 D.缺页</p><p>某请求页式存储管理，允许⽤户空间为 32 个页⾯（每页 2KB），主存为 16KB，如有⼀</p><p>个⽤户程序有 10 页长，且某时刻该⽤户进程的页表如下表所⽰</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225948016.png" alt="image-20231227225948016"></p><p>32、 如果程序执⾏时遇到逻辑地址1AC5H，则它对应的物理地址为______。</p><p>A. 7AC5H B. 4AC5H C. 3AC5H D. 缺页</p><p>33、 页表存放在主存中，对主存的⼀次存取需要100ns，对TLB表的查找时间为10ns，</p><p>这次访问耗费时间为______。</p><p>A. 10ns B. 100ns C. 110ns D. 210ns</p><p>34、 如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为80%，则访问</p><p>内存中数据的平均有效访问时间是______。7</p><p>A．120ns B．130ns C．170ns D．190ns</p><p>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 4KB，逻辑地址空间为 32 位，</p><p>物理地址空间为 36 位，⼀个页表项⼤⼩为 4B。⼀次快表（TLB）的访问时间是 10ns，⼀次</p><p>内存的访问时间是 100ns，处理⼀次缺页的平均时间 10^8 ns（已含更新 TLB 和页表的时</p><p>间）。进程的驻留集⼤⼩固定为 2,采⽤最近未使⽤置换算法(NRU)和局部淘汰策略。假设（1）</p><p>TLB 初始为空;（2）地址转换时先访问 TLB,若 TLB 未命中,再访问页表(忽略访问页表之后</p><p>的 TLB 更新时间);（3）有效位为 0 表⽰页⾯不在内存,产⽣缺页中断,缺页中断处理后,返回</p><p>到产⽣缺页中断的指令处重新执⾏。进程的部分页表如下所⽰：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225914783.png" alt="image-20231227225914783"></p><p>35、 该系统的页表项中，最多可以保存_______位标志位。</p><p>A．4 B．8 C．12 D．16</p><p>36、 若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤______级页</p><p>表较合适。</p><p>A．0 B．1 C．2 D．3</p><p>37、 如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为90%，则访问</p><p>内存中数据的平均有效访问时间是______。</p><p>A．20ns B．110ns C．120ns D．320ns</p><p>38、 ⾸先，访问逻辑地址00001618H，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>39、 然后，访问逻辑地址00000FA6H，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>40、 最后，访问逻辑地址0000126CH，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>41、 在依次访问完上述三个逻辑地址后，页框101254H对应的页号为______。</p><p>A．00000H B．00001H C．00002H D．00003H</p><p>某基于动态分区存储管理的计算机,其主存容量为 55MB(初始为空闲) ,分配和释放的顺8</p><p>序为:分配 15MB,分配 30MB,释放 15MB,分配 8MB,分配 6MB。</p><p>42、 若采⽤最佳适配(Best Fit)算法，此时主存中最⼤空闲分区的⼤⼩是______。</p><p>A.7MB B.9MB C.10MB D.15MB</p><p>43、 若采⽤最差适配(Worst Fit)算法，此时主存中最⼤空闲分区的⼤⼩是______。</p><p>A.7MB B.9MB C.10MB D.15MB</p><h2 id="三、-计算题（填空）"><a href="#三、-计算题（填空）" class="headerlink" title="三、 计算题（填空）"></a>三、 计算题（填空）</h2><p>1、在逻辑地址转换为物理地址时，采⽤页式存储管理，两级页表，页⾯⼤⼩为 4 KB，页表</p><p>项⼤⼩为 4 字节。逻辑地址的结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225816196.png" alt="image-20231227225816196"></p><p>若该进程共⽤到了 3072 个页，则此时此⼆级页表占⽤的总空间最⼩为___(1)____。</p><p>TLB（快表）采⽤全相联映射，有 4 个页表项，内容如下表所⽰。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225808126.png" alt="image-20231227225808126"></p><p>则逻辑地址 03FFF180H 对应的物理地址是____(2)_____，逻辑地址 02FF3036H 对应的物理</p><p>地址是____(3)_____。（如⽆对应的物理地址，则填写原因，可能为“TLB 缺失”或“缺页”）</p><p>2、某计算机主存按字节编址，逻辑地址和物理地址都是 32 位，页表项⼤⼩为 4 字节。请</p><p>回答下列问题。</p><p>（1）若使⽤⼀级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225753388.png" alt="image-20231227225753388"></p><p>则页的⼤⼩是__(1)_<strong>。页表最⼤占⽤空间为</strong>(2)__。</p><p>（2）若使⽤⼆级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225746983.png" alt="image-20231227225746983"></p><p>设逻辑地址为LA，则其对应的页⽬录号的表达式___(3)<em><strong>和页表索引的表达式</strong></em>(4)___。</p><p>若该进程共⽤到了3072个页，则此时此⼆级页表占⽤的总空间最⼩为___(5)____。</p><p>（3）采⽤（1）中的分页存储管理⽅式，⼀个代码段起始逻辑地址为 0000 8000H，其长度为8 KB，被装载到从物理地址 0090 0000H 开始的连续主存空间中。页表从主存 0020 0000H 开始的物理地址处连续存放，如下图所⽰（地址⼤⼩⾃下向上递增）。则该代码段对应的两个页表项，物理地址 1 是___(6)<em><strong>，物理地址 2 是</strong></em>(7)_<strong>；这两个页表项中的页框号 1 是</strong>(8)<em><strong>，页框号 2 是</strong></em>(9)<em><strong>；以及代码页⾯ 2 的起始物理地址 3 是</strong></em>(10)___。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225700626.png" alt="image-20231227225700626"></p><h2 id="四、计算题（简答）"><a href="#四、计算题（简答）" class="headerlink" title="四、计算题（简答）"></a>四、计算题（简答）</h2><ol><li>请求分页管理系统中，假设某进程的页表内容如下表所⽰:</li></ol><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225642811.png" alt="image-20231227225642811"></p><p>页⾯⼤⼩为 4KB，⼀次内存的访问时间是 100ns，⼀次快表(TLB)的访问时间是 10ns，处理</p><p>⼀次缺页的平均时间 108 ns(已含更新 TLB 和页表的时间)，进程的驻留集⼤⼩固定为 2，</p><p>采⽤最近最少使⽤置换算法(LRU)和局部淘汰策略。假设 (1) TLB 初始为空; (2) 地址转换时</p><p>先访问 TLB，若 TLB 未命中，再访问页表(忽略访问页表之后的 TLB 更新时间); (3) 有效</p><p>位为 0 表⽰页⾯不在内存，产⽣缺页中断，缺页中断处理后，返回到产⽣缺页中断的指令</p><p>处重新执⾏。设有虚地址访问序列 2362H、1565H、25A5H，请问:</p><p>\1) 依次访问上述三个虚地址，各需多少时间?给出计算过程。</p><p>\2) 基于上述访问序列，虚地址 1565H 的物理地址是多少?请说明理由。</p><p>\2. 某系统的页⾯淘汰算法采⽤⽼化(Aging)算法，每个页⾯分配⼀个8位⼆进制数的计数器。</p><p>某进程共有 6 个页⾯，在时刻 0 之前所有页⾯均未被引⽤过。下表是前 5 个 clock tick 中10</p><p>各页⾯的被引⽤情况，被引⽤者标 1，未被引⽤者标 0。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225628323.png" alt="image-20231227225628323"></p><p>1） 在 clock tick 4 过后，需要淘汰⼀个页⾯，应选择哪个页⾯进⾏淘汰？为什么？</p><p>2） 为什么说⽼化(Aging)算法是⼀种简单有效的算法，但只是 LRU 的⼀个近似实现？</p><p>\3. 设某计算机的逻辑地址空间和物理地址空间均为 64KB,按字节编址。若某进程最多需要</p><p>6 页(Page)数据存储空间,页的⼤⼩为 1KB,操作系统采⽤固定分配局部置换策略为此进</p><p>程分配 4 个页框(Page Frame)。在时刻 260 前的该进程访问情况如下表所⽰(访问位即</p><p>使⽤位)。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225614727.png" alt="image-20231227225614727"></p><p>当该进程执⾏到时刻 260 时,要访问逻辑地址为 17CAH 的数据。请回答下列问题:</p><p>(1) 该逻辑地址对应的页号是多少?</p><p>(2) 若采⽤最近最少使⽤(LRU)置换算法,该逻辑地址对应的物理地址是多少?要求给出计</p><p>算过程。</p><p>\4. 已知某系统页⾯长 4KB，页表项 4B，虚拟地址空间为 64 位，物理地址空间 4GB。</p><p>（1）如采⽤多层分页策略，限定各分层页表最多占 1 页⼤⼩，请问可以采⽤⼏层分页</p><p>策略？</p><p>（2）如采⽤倒排页表⽅式，请问倒排页表的⼤⼩？是每个进程⼀张倒排页表还是系统</p><p>维护⼀张倒排页表？如何解决倒排页表不便于逻辑地址向物理地址转换的问题？11</p><h2 id="五、-简答题"><a href="#五、-简答题" class="headerlink" title="五、 简答题"></a>五、 简答题</h2><p>1、 在虚拟存储管理中，分段式内存管理⽅式解决了分页式内存管理中的什么问题，又</p><p>带来了什么问题呢？</p><p>2、 Intel IA32体系结构中的保护模式是将逻辑地址转成线性地址再转成物理地址，这</p><p>种内存管理⽅式是段页式内存管理⽅式吗，为什么？</p><p>3、 LRU页⾯置换算法是⼀种⽐较优秀的算法但是较难实现，为什么？试给出⼀种可⾏</p><p>的近似算法作为LRU的取代⽅案。</p><p>4、 单纯的分段式和分页式内存管理各有什么缺点？为什么段页式可以避免这些缺点？</p><p>为什么段页式内存管理没有被⼴泛采⽤呢？</p><p>5、 为什么内存管理⽅式中，可变分区管理中有最差适应（worst fit)分配算法，⽽固定</p><p>分区管理中没有这个算法？分区管理中的交换技术（swap）和段式管理中的请求式</p><p>分段技术有什么区别？请求式分段与覆盖技术（overlay）又有什么区别？</p><p>6、 页⾯置换（淘汰）的时机是什么？哪种算法最理想同时也不可能实现？为什么说</p><p>LRU算法很有效但是很难实现？什么是Belady异常？哪种算法存在Belady异常现</p><p>象？</p><p>7、 请讨论⼀下页⾯置换算法中⼯作集（Working Set）置换算法的⼯作原理。</p><p>8、 在内存管理的⽅法中，分段式管理⽐分页式管理有什么优势？段页式与其他⽅式相</p><p>⽐有什么好处？</p><p>9、 为了同时抢占⾼端和中低端市场，CPU ⼚商常常在同⼀⽣产线上⽣产主频和制作⼯</p><p>艺相同的⾼端和低端 CPU，如 Intel 曾经同时⽣产相同主频和制作⼯艺的“奔腾 4”和</p><p>“赛扬”，价格上相差很⼤，据称主要区别在⼆级缓存的⼤⼩。请问缓存（Cache）有</p><p>什么⽤，什么地⽅会⽤到它？12</p><p>10、 为什么要使⽤倒排页表？倒排页表⾯临的最⼤的问题是什么？如何解决？</p><p>11、 内存分区管理中的交换技术与请求式分段技术相⽐，有什么相同点和不同点？</p><p>12、 在页⾯淘汰算法中，为什么说⽼化(Aging)算法只是 LRU 的⼀个近似实现？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存管理习题&quot;&gt;&lt;a href=&quot;#内存管理习题&quot; class=&quot;headerlink&quot; title=&quot;内存管理习题&quot;&gt;&lt;/a&gt;内存管理习题&lt;/h1&gt;&lt;h2 id=&quot;⼀、-选择题&quot;&gt;&lt;a href=&quot;#⼀、-选择题&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些常见加密</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/08/29/++++++m/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/08/29/++++++m/</id>
    <published>2023-08-28T16:00:00.000Z</published>
    <updated>2024-01-18T14:37:50.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Base加密"><a href="#Base加密" class="headerlink" title="Base加密"></a>Base加密</h3><h4 id="Hex-base16"><a href="#Hex-base16" class="headerlink" title="Hex(base16)"></a>Hex(base16)</h4><p>8位二进制–&gt;2个4位字节，长度是源数据的两倍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///encode</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> charset[] = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">convert</span> <span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;<span class="number">0xA</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>+val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>+(val<span class="number">-0xA</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">hex_encode</span><span class="params">(<span class="type">char</span>*<span class="built_in">array</span>,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span>*encode;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">array</span>||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    encode=(<span class="type">char</span>*)<span class="built_in">malloc</span>(size*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        encoded[<span class="number">2</span>*i]=convert((<span class="built_in">array</span>[i]&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xF</span>);</span><br><span class="line">        encode[w*i+<span class="number">1</span>]=convert(<span class="built_in">array</span>[i]&amp;<span class="number">0xF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encode[size*<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> encode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//decode</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">re_convert</span> <span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;<span class="number">0xA</span>)</span><br><span class="line">        <span class="keyword">return</span> val-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> val+<span class="number">0xA</span>-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">hex_decode</span><span class="params">(<span class="type">char</span>*<span class="built_in">array</span>,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span>*decode;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">array</span>||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     encode=(<span class="type">char</span>*)<span class="built_in">malloc</span>((size+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        encoded[<span class="number">2</span>*i]=convert((<span class="built_in">array</span>[i]&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xF</span>);</span><br><span class="line">        encode[w*i+<span class="number">1</span>]=convert(<span class="built_in">array</span>[i]&amp;<span class="number">0xF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encode[size/<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> decode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> test1[] = &#123;<span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAB</span>, <span class="number">0xCD</span>, <span class="number">0xEF</span>&#125;;</span><br><span class="line"><span class="type">char</span> test2[] = &#123;<span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0x3B</span>, <span class="number">0x5C</span>, <span class="number">0xB9</span>, <span class="number">0xF9</span>, <span class="number">0x0F</span>, <span class="number">0x69</span>, <span class="number">0x61</span>, <span class="number">0x8F</span>,</span><br><span class="line"><span class="number">0x5D</span>, <span class="number">0xE6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *m1t1, *m1t2;</span><br><span class="line">    m1t1 = hex_encode(test1, <span class="keyword">sizeof</span>(test1));</span><br><span class="line">m1t2 = hex_encode(test2, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">    m1t3 = hex_decode(test1, <span class="keyword">sizeof</span>(test1));</span><br><span class="line">m1t4 = hex_decode(test2, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t1: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t2: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t3: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t4: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">free</span>(m1t1);</span><br><span class="line"><span class="built_in">free</span>(m1t2);</span><br><span class="line"><span class="built_in">free</span>(m1t3);</span><br><span class="line"><span class="built_in">free</span>(m1t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>编码表长度为64</p><p>编码后的字节数组长度为4的倍数、编码前的4&#x2F;3倍</p><p>编码得到的字符串常以“&#x3D;”结尾（</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</span><br></pre></td></tr></table></figure><p>#变种：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">encoded = <span class="string">&quot;zCN7zTJP3hj71C3BxSj72SuSnhQ=&quot;</span></span><br><span class="line">old = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">new = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ+/&quot;</span></span><br><span class="line">mapper = <span class="built_in">str</span>.maketrans(new, old)</span><br><span class="line">tmp = encoded.translate(mapper)</span><br><span class="line">flag = base64.b64decode(tmp)</span><br><span class="line"><span class="built_in">print</span> (flag.decode())</span><br></pre></td></tr></table></figure><h4 id="Base58"><a href="#Base58" class="headerlink" title="Base58"></a>Base58</h4><p>(少了0,o.l,I,+,&#x2F;)密文不断对58取模（得商和模），直到商为零（辗转相除），模逆向存入</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install base58</span></span><br><span class="line"><span class="keyword">import</span> base58</span><br><span class="line">enflag = <span class="string">&quot;2NEpo7TZRRrLZSi2U&quot;</span></span><br><span class="line"><span class="built_in">print</span>(base58.b58decode(enflag))</span><br></pre></td></tr></table></figure><h3 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h3><p>流加密，密钥长度变，加解密使用相同密钥，<strong>属于对称加密</strong>，<strong>有线等效加密</strong>（WEP）中使用得加密算法，</p><h5 id="S盒初始化"><a href="#S盒初始化" class="headerlink" title="S盒初始化"></a>S盒初始化</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">S[i]:=i <span class="comment">#?</span></span><br><span class="line">endfor</span><br><span class="line"></span><br><span class="line">j:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">j:=(j+S[i]+KEY[i mod key_len]) mod <span class="number">256</span>  <span class="comment">#256次for循环 #根据密钥打乱S盒</span></span><br><span class="line">    swap(S[i],S[j])</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h5 id="密钥流生成"><a href="#密钥流生成" class="headerlink" title="密钥流生成"></a>密钥流生成</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> GeneratingOutput</span><br><span class="line">i := (i + <span class="number">1</span>) mod <span class="number">256</span></span><br><span class="line">j := (j + S[i]) mod <span class="number">256</span></span><br><span class="line">swap(S[i], S[j])</span><br><span class="line">send(S[S[i]+S[j]mod <span class="number">256</span>]) to stream</span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure><h5 id="流加密"><a href="#流加密" class="headerlink" title="流加密"></a>流加密</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to plain_len  <span class="comment">#便利输入明文的每个字节，从s盒中去一个字节与之亦或，完成加密</span></span><br><span class="line">plain[i]^=stream[i]</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&quot;hello world&quot;</span></span><br><span class="line">cipher = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;A0 E2 BA F4 B5 02 ED 9B 41 2F E6 23&quot;</span>)</span><br><span class="line">rc4 = ARC4.new(key)</span><br><span class="line">plain = rc4.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span>(plain)</span><br></pre></td></tr></table></figure><p>特点：<br>前期准备很多很长</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>一般有两种形式的调用，一种是直接封装成一个函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8_t digest[<span class="number">16</span>];</span><br><span class="line">uint8_t <span class="built_in">input</span>[] = <span class="string">&quot;xxxxxxx&quot;</span>;</span><br><span class="line">MD5_hash(<span class="built_in">input</span>, sizeof(<span class="built_in">input</span>) - <span class="number">1</span>, digest);</span><br></pre></td></tr></table></figure><p>另一种是分三步完成哈希：</p><p>openssl</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MD5_CTX ctx;</span><br><span class="line">uint8_t digest[<span class="number">16</span>];</span><br><span class="line">uint8_t <span class="built_in">input</span>[] = <span class="string">&quot;xxxxxxx&quot;</span>;</span><br><span class="line">MD5_Init(&amp;ctx);</span><br><span class="line">MD5_Update(&amp;ctx, <span class="built_in">input</span>, sizeof(<span class="built_in">input</span>) - <span class="number">1</span>);</span><br><span class="line">MD5_Final(&amp;ctx, digest);</span><br></pre></td></tr></table></figure><p>在函数实现中，可以在靠近开头的位置看到几个特殊的常量</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0x67452301</span>;</span><br><span class="line">B = <span class="number">0xEFCDAB89</span>;</span><br><span class="line">C = <span class="number">0x98BADCFE</span>;</span><br><span class="line">D = <span class="number">0X10325476</span>;</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><p><strong>四个</strong>固定的常量（初始化向量）</p></li><li><p>不论输入是多长，输出永远是 <strong>16</strong> 字节</p></li><li><p>符合上述两种调用方式之一</p></li></ul><p><strong>逆向方式：</strong></p><ul><li><p>脚本爆破</p></li><li><p>查询网站：</p><ul><li>cmd5</li><li>[somd5][<a href="https://www.somd5.com/]">https://www.somd5.com/]</a></li></ul></li><li><p>hashcat 使用</p></li></ul><h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h4><p>五个常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H0 = 0x67452301</span><br><span class="line">H1 = 0xEFCDAB89</span><br><span class="line">H2 = 0x98BADCFE</span><br><span class="line">H3 = 0x10325476</span><br><span class="line">H4 = 0xC3D2E1F0</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><strong>五个</strong>固定的常量（初始化向量）</li><li>不论输入是多长，输出永远是 <strong>20</strong> 字节</li><li>符合上述两种调用方式之一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">target = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;ee 93 50 b8 86 a1 ba be c0 26 39 e4 7f 8b d2 a2 c1 22 3e a7&quot;</span>)</span><br><span class="line">charset = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(charset.repeat=<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> hashlib.sha1(<span class="built_in">bytes</span>(i)).digest()==tarfet:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">bytes</span>(i))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="sha-224-28个字节"><a href="#sha-224-28个字节" class="headerlink" title="sha_224 28个字节"></a>sha_224 28个字节</h4><h4 id="SHA-256"><a href="#SHA-256" class="headerlink" title="SHA-256"></a>SHA-256</h4><p>256&#x2F;8&#x3D;32</p><p>八个常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H0 = 0x6a09e667</span><br><span class="line">H1 = 0xbb67ae85</span><br><span class="line">H2 = 0x3c6ef372</span><br><span class="line">H3 = 0xa54ff53a</span><br><span class="line">H4 = 0x510e527f</span><br><span class="line">H5 = 0x9b05688c</span><br><span class="line">H6 = 0x1f83d9ab</span><br><span class="line">H7 = 0x5be0cd19</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><p>八个固定的常量（初始化向量）</p></li><li><p>不论输入是多长，输出永远是 <strong>32</strong> 字节</p></li><li><p>符合上述两种调用方式之一</p></li></ul><h3 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h3><p>[0x9e3779B9和0x61c88647]</p><p>识别特征：</p><p>标准 DELTA 常数（魔数）</p><p>密钥为 16 字节（4 个 DWORD）</p><p>加密轮数为 16&#x2F;32&#x2F;64 轮</p><p>加密结构中存在左 4 右 5 移位及异或运算</p><p>加密结构中存在轮加&#x2F;减相同常数的语句</p><p>对抗方式：</p><p>修改魔数</p><p>修改轮数</p><p>修改轮加&#x2F;减魔数的位置</p><h4 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h4><p>识别特征：</p><p>同 TEA</p><p>加密结构中存在右移 11 位并 &amp; 3 的运算</p><h4 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a><strong>XXTEA</strong></h4><p>XXTEA 是 XTEA 的升级版，其实现过程比前两种算法要略显复杂些，加密的明文数据可以不再是</p><p>64bit（两个 32 位无符号整数），并且其加密轮数是由 n，即待加密数据个数决定的。</p><p>识别特征基本同 TEA，但是加密轮数通过计算求得（6 + 52&#x2F;n）</p><h2 id="分组加密算法"><a href="#分组加密算法" class="headerlink" title="分组加密算法"></a>分组加密算法</h2><h3 id="常见工作模式"><a href="#常见工作模式" class="headerlink" title="常见工作模式"></a>常见工作模式</h3><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171156586.png" alt="image-20231112171156586"></p><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171208459.png" alt="image-20231112171208459"></p><h3 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171319806.png" alt="image-20231112171319806"></p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171443392.png" alt="image-20231112171443392"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171507346.png" alt="image-20231112171507346"></p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171515871.png" alt="image-20231112171515871"></h3><p>S：637c77 </p><p>16-10</p><p>24-12</p><p>32-14</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Base加密&quot;&gt;&lt;a href=&quot;#Base加密&quot; class=&quot;headerlink&quot; title=&quot;Base加密&quot;&gt;&lt;/a&gt;Base加密&lt;/h3&gt;&lt;h4 id=&quot;Hex-base16&quot;&gt;&lt;a href=&quot;#Hex-base16&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="密码 特征" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E5%AF%86%E7%A0%81-%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/06/25/Misc%EF%BC%9AMiscMasc%EF%BC%81/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/06/25/Misc%EF%BC%9AMiscMasc%EF%BC%81/</id>
    <published>2023-06-24T16:28:47.159Z</published>
    <updated>2023-07-05T14:29:52.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Misc：MiscMasc！"><a href="#Misc：MiscMasc！" class="headerlink" title="Misc：MiscMasc！"></a>Misc：MiscMasc！</h1><h2 id="适合作为桌面"><a href="#适合作为桌面" class="headerlink" title="适合作为桌面"></a>适合作为桌面</h2><p><a href="http://t.csdn.cn/XsnrR">http://t.csdn.cn/XsnrR</a></p><p>题解</p><pre><code>单纯从图片观察，未发现线索；右键使用记事本打开，依然未发现 flag 字样；考虑图片隐写，启动 Stegsolve ，加载图片；直接切换图片，在 red plane 1 中，可以看到，图片左上角出现了一个二维码。（图片隐写大概率可能还会涉及到数据提取，这道题比较基础，所以直接切换就可以看到）识别该二维码，在线条码解析，记得选择二维码，然后 read 读取；扫描结果是一串十六进制的数字；启动 winhex 进行解码，选择 AscII Hex虽然解析出来是乱码，但是根据这些关键字可以推断出，这应该是一个 python 被编译之后的 pyc 文件将其保存为 pyc 文件启动 easy python decompiler 对其进行反编译反编译会在 pyc 文件所在目录下生成这个文件将其后缀改为 py 使用 vscode 打开，发现实际上是一个名为 flag 的 python 方法，但并无调用语句，于是自己加上一行代码，调用这个方法找到 flag</code></pre><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>拿题目</p><p>首先还是分析题目，看看从题目中能发现什么蛛丝马迹。这是一道“13掌”打架题。先下载附加看看。</p><p> 与佛论禅</p><p>附件里面是一段看不懂的文字，但是正常的应该能看出这应该是一段佛文。</p><p>立马想到【与佛论禅】</p><p>复制解密一下：注意格式一定要加上：【佛曰：】进行解密，得到密文：{MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9}</p><p>十三掌解密</p><p>上面的第一步解密完成，但是输入进去是一个错误的flag，继续分析题干。题干上有一个比较明显的提示：【如来十三掌】。</p><p>必须很快的想到要进行rot13解码：解码得到{ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9}</p><p>输入依然不是正确的flag。</p><p>Base64解密</p><p>从13掌中得到的密文后，我们再进行一个Base64解密得到最终flag。flag{bdscjhbkzmnfrdhbvckijndskvbkjdsab}<br>————————————————<br>版权声明：本文为CSDN博主「Jum朱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_22903531/article/details/117768461">https://blog.csdn.net/qq_22903531/article/details/117768461</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Misc：MiscMasc！&quot;&gt;&lt;a href=&quot;#Misc：MiscMasc！&quot; class=&quot;headerlink&quot; title=&quot;Misc：MiscMasc！&quot;&gt;&lt;/a&gt;Misc：MiscMasc！&lt;/h1&gt;&lt;h2 id=&quot;适合作为桌面&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/06/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/06/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89/</id>
    <published>2023-06-21T14:12:23.277Z</published>
    <updated>2023-07-24T13:37:04.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言（王爽）"><a href="#汇编语言（王爽）" class="headerlink" title="汇编语言（王爽）"></a>汇编语言（王爽）</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>机器语言与机器指令 ：（eg）1000100111011000</p><p>汇编语言的主体是汇编指令</p><h4 id="CPU对存储器的读写："><a href="#CPU对存储器的读写：" class="headerlink" title="CPU对存储器的读写："></a>CPU对存储器的读写：</h4><ul><li>CPU想要进行数据的读写，必须和外部器件进行三类信息的交互：<ul><li>存储单元的地址（地址信息）</li><li>期间的选择、读或写命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul></li></ul><p> 将各类存储器看作一个逻辑存储器——统一编址</p><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><ul><li><p>主存储器地址空间</p><ul><li>RAM主存储器</li><li>ROM装有系统BIOS（来自最后一点）</li><li>RAM主存储器</li></ul></li><li><p>显存地址空间</p><ul><li>RAM显存</li></ul></li><li><p>显卡BIOS ROM地址空间</p><ul><li>ROM装有显卡BIOS</li></ul></li><li><p>网卡BIOS ROM地址空间</p><ul><li>ROM装有网卡BIOS</li></ul></li><li><p>系统BIOS ROM地址空间</p></li></ul><p>物理地址&#x3D;短地址*16+偏移地址</p><p>内存没有分段，段的划分来自于CPU </p><h2 id="汇编语言程序"><a href="#汇编语言程序" class="headerlink" title="汇编语言程序"></a>汇编语言程序</h2><h2 id="内存寻址方式"><a href="#内存寻址方式" class="headerlink" title="内存寻址方式"></a>内存寻址方式</h2><h2 id="流程转移与子程序"><a href="#流程转移与子程序" class="headerlink" title="流程转移与子程序"></a>流程转移与子程序</h2><h2 id="中断及其应用"><a href="#中断及其应用" class="headerlink" title="中断及其应用"></a>中断及其应用</h2><h2 id="高级汇编语言技术"><a href="#高级汇编语言技术" class="headerlink" title="高级汇编语言技术"></a>高级汇编语言技术</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编语言（王爽）&quot;&gt;&lt;a href=&quot;#汇编语言（王爽）&quot; class=&quot;headerlink&quot; title=&quot;汇编语言（王爽）&quot;&gt;&lt;/a&gt;汇编语言（王爽）&lt;/h1&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
</feed>
