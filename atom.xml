<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习生活手账本</title>
  <icon>https://www.gravatar.com/avatar/260de78781b3355b5fcbb52d09a7a2a9</icon>
  
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/"/>
  <updated>2024-02-02T12:06:37.855Z</updated>
  <id>https://github.com/xyy9233/xyy9233.github.io.git/</id>
  
  <author>
    <name>wind_9233</name>
    <email>1768765226@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/01/IDAPython%E4%B8%8Eelf%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/01/IDAPython%E4%B8%8Eelf%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2024-02-01T12:57:23.118Z</published>
    <updated>2024-02-02T12:06:37.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDAPython常用函数"><a href="#IDAPython常用函数" class="headerlink" title="IDAPython常用函数"></a>IDAPython常用函数</h1><p><a href="https://hex-rays.com/products/ida/support/idapython_docs/">官方文档</a></p><h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><ul><li>here() &#x2F; get_screen_ea()：返回光标当前所在地址</li><li>get_inf_attr(INF_MIN_EA) &#x2F; get_inf_attr(INF_MAX_EA)：获得最小 &#x2F; 最大地址</li><li>generate_disasm_line(ea, GENDSM_FORCE_CODE)：获得 ea 所在处的一条汇编指令</li><li>print_insn_mnem(ea)：获得 ea 所在处的指令助记符</li><li>print_operand(ea, n)：获取 ea 所在处的第 n 个操作数</li></ul><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><ul><li>Segments()：返回段的可遍历对象</li><li>get_segm_name(ea)：获得 ea 所在段名</li><li>get_next_seg(ea)：获取下一个段</li><li>get_segm_start(ea) &#x2F; get_segm_end(ea)：获取段开始 &#x2F; 结束地址</li></ul><p>for seg in Segments():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;&#123;get_segm_name(seg)&#125;, &#123;get_segm_start(seg)&#125;, &#123;get_segm_end(seg)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Functions() &#x2F; Funtions(start_addr, end_addr)：返回函数的可遍历对象</p><p>get_func_name(ea)：返回函数名称</p><p>idaapi.get_func(ea)：获得解析后的函数对象</p><p>get_func_attr(ea, FUNCATTR_START) &#x2F; get_func_attr(ea, FUNCATTR_END)：访问函数边界</p><p>get_next_func(ea) &#x2F; get_prev_func(ea)：获取上 &#x2F; 下一个函数</p><p>prev_head(ea) &#x2F; next_head(ea)：获得上 &#x2F; 下一条指令地址</p><p>FuncItems(ea)：获取 ea 所处函数的所有指令地址</p><p>eg:打印一个函数的反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ea = here()</span><br><span class="line">now = get_func_attr(ea, FUNCATTR_START)</span><br><span class="line">end = get_func_attr(ea, FUNCATTR_END)</span><br><span class="line">while now &lt; end:</span><br><span class="line">print(f&quot;0x&#123;now&#125; &#123;generate_disasm_line(now, 0)&#125;&quot;)</span><br><span class="line">now = next_head(now)</span><br></pre></td></tr></table></figure><p>使用 FuncItems 来完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ea in FuncItems(here()):</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>idaapi.decode_insn(out, ea)：解析指令并填充 out (insn_t 结构体)</p><p>ida_ua.insn_t()：new 一个 insn_t 结构体</p><p>例：找到函数中所有的跳转指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ea in FuncItems(here()):</span><br><span class="line">asm = generate_disasm_line(ea, 0)</span><br><span class="line">if &quot;jmp&quot; in asm:</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><p>另一种实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMPS = [idaapi.NN_jmp, idaapi.NN_jmpfi, idaapi.NN_jmpni]</span><br><span class="line">for ea in FuncItems(here()):</span><br><span class="line">ins = ida_ua.insn_t()</span><br><span class="line">idaapi.decode_insn(ins, ea)</span><br><span class="line">if ins.itype in JMPS:</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a><strong>操作数</strong></h2><p>可以使用 get_operand_type(ea, n) 得到操作数的类型。get_operand_value(ea, n) 来得到操作数的值。ea 是地址，n 是索引。</p><p>这里有 8 中不同类型的操作数类型。</p><p><strong>o_void</strong> 如果一个指令没有任何操作数它将返回 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa09166 retn</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure><p><strong>o_reg</strong> 如果一个操作数是一个普遍的寄存器将返回此类型。这个值在内部表示为 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa09163 pop edi</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure><p><strong>o_mem</strong> 如果一个操作数是直接内存引用它将返回这个类型。这个值在内部表示为 2。这种类型是有用的在 DATA 段查找引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05d86 cmp ds:dword_A152B8, 0</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure><p><strong>o_phrase</strong> 这个操作数被返回则这个操作数包含一个基本的寄存器或一个索引寄存器。这个值在内部表示为 3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0x1000b8c2 mov [edi+ecx], eax</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure><p><strong>o_displ</strong> 这个操作数被返回则操作数包含寄存器和一个位移值，这个为位移值是一个整数，例如 0x18。</p><p>这是常见的当一条指令访问值在一个结构中。在内部，它表示为 4 的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05dc1 mov eax, [edi+18h]</span><br><span class="line">Python&gt;print(get_operand_type(ea,1))</span><br><span class="line">&gt;&gt;&gt; 4</span><br></pre></td></tr></table></figure><p><strong>o_imm</strong> 操作数是这样一个为整数的 0xc 的值的类型。它在内部表示为 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05da1 add esp, 0Ch</span><br><span class="line">Python&gt;print(get_operand_type(ea,1))</span><br><span class="line">&gt;&gt;&gt; 5</span><br></pre></td></tr></table></figure><p><strong>o_far</strong> 是用来寻找操作数的访问立即数远地址的。它在内部表示为 6。</p><p><strong>o_near</strong> 是用来寻找操作数的访问立即数近地址的。它在内部表示为 7。</p><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><ul><li>get_bytes(ea, size)</li><li>ida_bytes.get_byte(ea)</li><li>ida_bytes.get_word(ea)</li><li>ida_bytes.get_dword(ea)</li><li>ida_bytes.get_qword(ea)</li><li>ida_bytes.patch_bytes(ea, buf)</li><li>ida_bytes.patch_byte(ea, val)</li><li>ida_bytes.patch_word(ea, val)</li><li>ida_bytes.patch_dword(ea, val)</li><li>ida_bytes.patch_qword(ea, val)</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>add_bpt(ea)：添加断点</li><li>del_bpt(ea)：删除断点</li><li>start_process(path, args, sdir)：启动调试</li><li>step_into()：步入</li><li>step_over()：步过</li><li>step_until_ret()：执行到返回</li><li>get_reg_value(regname)：获取寄存器值</li><li>set_reg_value(value, regname)：设置寄存器值</li><li>wait_for_next_event(wfne, timeout)：等待调试事件，第一个参数一般取为 WFNE_SUSP</li></ul><h1 id="ELF-运行流程"><a href="#ELF-运行流程" class="headerlink" title="ELF 运行流程"></a><strong>ELF</strong> 运行流程</h1><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223812328.png" alt="image-20240201223812328"></p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223823579.png" alt="image-20240201223823579"></p><h2 id="基本操作说明"><a href="#基本操作说明" class="headerlink" title="基本操作说明"></a><strong>基本操作说明</strong></h2><h3 id="sys-execve"><a href="#sys-execve" class="headerlink" title="sys_execve"></a><strong>sys_execve</strong></h3><p>该函数主要用于执行一个新的程序，即执行我们想要执行的程序，会检查相应的 argv 以及 envp 等参</p><p>数。</p><h3 id="do-execve"><a href="#do-execve" class="headerlink" title="do_execve"></a><strong>do_execve</strong></h3><p>该函数打开目标映像文件，并从目标文件的开始处读入指定长度的（目前为128）字节来获取相应目标</p><p>文件的基本信息。</p><h3 id="search-binary-handler"><a href="#search-binary-handler" class="headerlink" title="search_binary_handler"></a><strong>search_binary_handler</strong></h3><p>该函数会搜索支持处理当前类型的二进制文件类型队列，以便于让各种可执行程序的处理程序进行相应</p><p>的处理。</p><h3 id="load-elf-binary"><a href="#load-elf-binary" class="headerlink" title="load_elf_binary"></a><strong>load_elf_binary</strong></h3><p>该函数的主要处理流程如下</p><ul><li><p>-检查并获取 elf 文件的头部信息</p></li><li><p>如果目标文件采用动态链接，则使用 .interp 节来确定 loader 的路径。</p></li><li><p>将 program header 中记录的相应的段映射到内存中。program header 中有以下重要信息</p><ul><li>每一个段需要映射到的地址</li><li>每一个段相应的权限</li><li>记录哪些节属于哪些段</li></ul></li></ul><p>具体的映射如下</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223854316.png" alt="image-20240201223854316"></p><p>分情况处理</p><ul><li><p>动态链接情况下，将 sys_execve 的返回地址改为 loader(ld.so) 的 entry point</p></li><li><p>静态链接情况下，将 sys_execve 的返回地址改为程序的入口点</p></li></ul><h3 id="ld-so"><a href="#ld-so" class="headerlink" title="ld.so"></a><strong>ld.so</strong></h3><p>该文件有以下功能</p><ul><li>主要用于载入 ELF 文件中 DT_NEED 中记录的共享库</li><li>初始化工作</li><li>初始化 GOT 表</li><li>将 symbol table 合并到 global symbol table</li></ul><h3 id="start"><a href="#start" class="headerlink" title="_start"></a><strong>_start</strong></h3><ul><li>_start 函数会将以下项目交给 libc_start_main</li><li>环境变量起始地址</li><li>.init</li><li>启动 main 函数前的初始化工作</li><li>.fini</li><li>程序结束前的收尾工作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDAPython常用函数&quot;&gt;&lt;a href=&quot;#IDAPython常用函数&quot; class=&quot;headerlink&quot; title=&quot;IDAPython常用函数&quot;&gt;&lt;/a&gt;IDAPython常用函数&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hex-rays.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/30/%E6%9C%80%E8%BF%91%E6%89%93%E6%AF%94%E8%B5%9B%E7%9A%84%E4%B8%80%E4%BA%9Bwriteup/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/30/%E6%9C%80%E8%BF%91%E6%89%93%E6%AF%94%E8%B5%9B%E7%9A%84%E4%B8%80%E4%BA%9Bwriteup/</id>
    <published>2024-01-30T14:29:31.529Z</published>
    <updated>2024-02-02T10:32:20.303Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="HGAME-20240129"><a href="#HGAME-20240129" class="headerlink" title="HGAME 20240129"></a>HGAME 20240129</h1><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>日常关注微信号–flag</p><h3 id="SignIn"><a href="#SignIn" class="headerlink" title="SignIn"></a>SignIn</h3><p>侧着看着图片w（经典</p><h3 id="simple——attack"><a href="#simple——attack" class="headerlink" title="simple——attack"></a>simple——attack</h3><p>明文爆破zip</p><h3 id="来自星尘的问候"><a href="#来自星尘的问候" class="headerlink" title="来自星尘的问候"></a>来自星尘的问候</h3><p>六位弱加密</p><h3 id="希儿希儿希尔"><a href="#希儿希儿希尔" class="headerlink" title="希儿希儿希尔"></a>希儿希儿希尔</h3><p>希尔加密，但是图片怎么修复？</p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="ezIDA"><a href="#ezIDA" class="headerlink" title="ezIDA"></a>ezIDA</h3><p>打开IDA就是</p><h3 id="ezUPX"><a href="#ezUPX" class="headerlink" title="ezUPX"></a>ezUPX</h3><p>UPX脱壳，看伪代码，</p><p>flag xor 0x32 后为一个数组</p><p>写入010editor，转换一下就出来了</p><p>（一定要抄对（（别抄，直接shift e导出（（</p><h3 id="ezASM"><a href="#ezASM" class="headerlink" title="ezASM"></a>ezASM</h3><p>根据汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">    c = [74, 69, 67, 79, 71, 89, 99, 113, 111, 125, 107, 81, 125, 107, 79, 82, 18, 80, 86, 22, 76, 86, 125, 22, 125, 112, 71, 84, 17, 80, 81, 17, 95, 34]</span><br><span class="line">    flag = [0, 0, ..., 0]  # 33 elements initialized to 0</span><br><span class="line">    format = &quot;plz input your flag: &quot;</span><br><span class="line">    success = &quot;Congratulations!&quot;</span><br><span class="line">    failure = &quot;Sry, plz try again&quot;</span><br><span class="line"></span><br><span class="line">text:</span><br><span class="line">    function check_flag():</span><br><span class="line">        esi = 0</span><br><span class="line">        while esi &lt; 33:</span><br><span class="line">            temp = flag[esi] XOR 0x22</span><br><span class="line">            if temp != c[esi]:</span><br><span class="line">                return false</span><br><span class="line">            esi += 1</span><br><span class="line">        return true</span><br><span class="line"></span><br><span class="line">    procedure _start():</span><br><span class="line">        # Print prompt</span><br><span class="line">        system_call(4, 1, format, 20)</span><br><span class="line"></span><br><span class="line">        # Read user input</span><br><span class="line">        system_call(3, 0, flag, 33)</span><br><span class="line"></span><br><span class="line">        # Check flag</span><br><span class="line">        if check_flag():</span><br><span class="line">            # Print success message</span><br><span class="line">            system_call(4, 1, success, 14)</span><br><span class="line">        else:</span><br><span class="line">            # Print failure message</span><br><span class="line">            system_call(4, 1, failure, 18)</span><br><span class="line"></span><br><span class="line">        # Exit</span><br><span class="line">        system_call(1, 0, 0)</span><br><span class="line"></span><br><span class="line">    function system_call(eax, ebx, ecx, edx):</span><br><span class="line">        # Simulate system call</span><br><span class="line">        # This function depends on the specific system&#x27;s calling convention</span><br><span class="line">        # and how system calls are made (e.g., int 0x80 in this case).</span><br><span class="line"></span><br><span class="line">    # Entry point</span><br><span class="line">    _start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写脚本出</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_with_0x22</span>(<span class="params">byte_array</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> byte_array:</span><br><span class="line">       hex_value = <span class="built_in">hex</span>(byte)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">       xor_result = <span class="built_in">hex</span>(byte ^ <span class="number">0x22</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">       result.append((hex_value, xor_result))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">byte_array = [<span class="number">74</span>, <span class="number">69</span>, <span class="number">67</span>, <span class="number">79</span>, <span class="number">71</span>, <span class="number">89</span>, <span class="number">99</span>, <span class="number">113</span>, <span class="number">111</span>, <span class="number">125</span>, <span class="number">107</span>, <span class="number">81</span>, <span class="number">125</span>, <span class="number">107</span>, <span class="number">79</span>, <span class="number">82</span>, <span class="number">18</span>, <span class="number">80</span>, <span class="number">86</span>, <span class="number">22</span>, <span class="number">76</span>, <span class="number">86</span>, <span class="number">125</span>, <span class="number">22</span>, <span class="number">125</span>, <span class="number">112</span>, <span class="number">71</span>, <span class="number">84</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">17</span>, <span class="number">95</span>, <span class="number">34</span>]</span><br><span class="line"></span><br><span class="line">result = xor_with_0x22(byte_array)</span><br><span class="line"><span class="keyword">for</span> hex_value, xor_result <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;hex_value&#125;</span> XOR 0x22 = <span class="subst">&#123;xor_result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ezPYC"><a href="#ezPYC" class="headerlink" title="ezPYC"></a>ezPYC</h3><p>感觉是控制流平坦化后的程序。没做出来</p><p>怀疑是python deflat.py -f ezPYC.exe –addr 0x140008F41 留一下</p><h1 id="BeginCTF-20240131"><a href="#BeginCTF-20240131" class="headerlink" title="BeginCTF 20240131"></a>BeginCTF 20240131</h1><h2 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h2><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MJSWO2LOPNLUKTCDJ5GWKX3UN5PUEM2HNFXEGVCGL4ZDAMRUL5EDAUDFL5MU6VK7O5UUYMK7GEYWWZK7NE3X2===</span><br></pre></td></tr></table></figure><p>base32</p><h3 id="tupper"><a href="#tupper" class="headerlink" title="tupper"></a>tupper</h3><p>脚本把所有文件信息提取</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_text_from_zip</span>(<span class="params">zip_path, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(zip_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> output_txt:</span><br><span class="line">            <span class="keyword">for</span> file_info <span class="keyword">in</span> zip_ref.infolist():</span><br><span class="line">                <span class="keyword">if</span> file_info.filename.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">                    <span class="keyword">with</span> zip_ref.<span class="built_in">open</span>(file_info) <span class="keyword">as</span> file:</span><br><span class="line">                        text = file.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                        output_txt.write(text)</span><br><span class="line">                        <span class="comment">#output_txt.write(&#x27;\n\n&#x27;)  # 可以根据需要增加分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    desktop_path = os.path.join(os.path.expanduser(<span class="string">&quot;~&quot;</span>), <span class="string">&quot;Desktop&quot;</span>)  <span class="comment"># 桌面路径，根据实际情况修改</span></span><br><span class="line">    zip_file_path = os.path.join(desktop_path, <span class="string">&quot;tupper.zip&quot;</span>)  <span class="comment"># 压缩包路径，根据实际情况修改</span></span><br><span class="line">    output_file_path = os.path.join(desktop_path, <span class="string">&quot;output.txt&quot;</span>)  <span class="comment"># 输出文件路径，根据实际情况修改</span></span><br><span class="line"></span><br><span class="line">    extract_text_from_zip(zip_file_path, output_file_path)</span><br></pre></td></tr></table></figure><p>看题目是tupper，说不定是个加密方式，一搜，哈真是</p><p><a href="http://t.csdnimg.cn/OF1OP">代码急转弯——Tupper（塔珀自指公式）</a></p><p><a href="https://tuppers-formula.ovh/">https://tuppers-formula.ovh/</a></p><p>上面output.txt内容–&gt;bese64–&gt;k–&gt;flag</p><h3 id="where-is-crazyman-v1-0"><a href="#where-is-crazyman-v1-0" class="headerlink" title="where is crazyman v1.0"></a>where is crazyman v1.0</h3><p>google识图</p><h3 id="devil’s-word"><a href="#devil’s-word" class="headerlink" title="devil’s word"></a>devil’s word</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leu lia leu ng leu cai leu jau leu e cai b cai jau sa leng cai ng ng f leu b leu e sa leng cai cai ng f cai cai sa sa leu e cai a leu bo leu f cai ng ng f leu sii leu jau sa sii leu c leu ng leu sa cai sii cai d</span><br></pre></td></tr></table></figure><p>我的解密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">leu lia 62 </span><br><span class="line">leu ng 65</span><br><span class="line">leu cai 67</span><br><span class="line">leu jau 69</span><br><span class="line">leu e 61</span><br><span class="line">cai b 78</span><br><span class="line">cai jau 79</span><br><span class="line">sa leng 32</span><br><span class="line">cai ng 75</span><br><span class="line">ng f 58</span><br><span class="line">leu b 68</span><br><span class="line">leu e 65</span><br><span class="line">sa leng 32</span><br><span class="line">cai cai 77</span><br><span class="line">ng f 58</span><br><span class="line">cai cai 77</span><br><span class="line">sa sa 33</span><br><span class="line">leu e 61</span><br><span class="line">cai a 71</span><br><span class="line">leu bo 68</span><br><span class="line">leu f 68</span><br><span class="line">cai ng 75</span><br><span class="line">ng f 58</span><br><span class="line">leu sii 64</span><br><span class="line">leu jau 69</span><br><span class="line">sa sii 34</span><br><span class="line">leu c 67</span><br><span class="line">leu ng 65</span><br><span class="line">leu sa 63</span><br><span class="line">cai sii 74</span><br><span class="line">cai d 76</span><br></pre></td></tr></table></figure><h2 id="RE-1"><a href="#RE-1" class="headerlink" title="RE"></a>RE</h2><h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><p>agh{^bvuwTooahlYocPtmyiijj|ek</p><p>63290794207715587679621386735000</p><p>反调试</p><h3 id="real-checkin-xor"><a href="#real-checkin-xor" class="headerlink" title="real checkin xor"></a>real checkin xor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def decrypt_func(encrypted, key):</span><br><span class="line">    decrypted = []</span><br><span class="line">    for i in range(len(encrypted)):</span><br><span class="line">        decrypted.append(chr(encrypted[i] ^ ord(key[i % len(key)])))</span><br><span class="line">    return &#x27;&#x27;.join(decrypted)</span><br><span class="line"></span><br><span class="line">key = &quot;ez_python_xor_reverse&quot;</span><br><span class="line">ciper = [7, 31, 56, 25, 23, 15, 91, 21, 49, 15, 33, 88, 26, 48, 60, 58, 4, 86, 36, 64, 23, 54, 63, 0, 54, 22, 6, 55, 59, 38, 108, 39, 45, 23, 102, 27, 11, 56, 32, 0, 82, 24]</span><br><span class="line"></span><br><span class="line">decrypted_text = decrypt_func(ciper, key)</span><br><span class="line">print(&quot;解密后的文本:&quot;, decrypted_text)</span><br></pre></td></tr></table></figure><h2 id="Forensics"><a href="#Forensics" class="headerlink" title="Forensics"></a>Forensics</h2><h3 id="逆向工程-reverse-入门指南"><a href="#逆向工程-reverse-入门指南" class="headerlink" title="逆向工程(reverse)入门指南"></a>逆向工程(reverse)入门指南</h3><p>pdf隐写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;HGAME-20240129&quot;&gt;&lt;a href=&quot;#HGAME-20240129&quot; class=&quot;headerlink&quot; title=&quot;HGAME 20240129&quot;&gt;&lt;/a&gt;HGAME 20240129&lt;/h1&gt;&lt;h2 id=&quot;MISC&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/24/ollvm!/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/24/ollvm!/</id>
    <published>2024-01-24T03:49:00.194Z</published>
    <updated>2024-01-30T12:18:34.271Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="OLLVM"><a href="#OLLVM" class="headerlink" title="OLLVM"></a>OLLVM</h1><p>LLVM 是一个<strong>开源的编译器架构</strong>，利用虚拟技术对源代码提供现代化的、与目标无关的、针对多种 CPU的，代码优化和代码生成功能。</p><p>LLVM 核心库提供了与编译器相关的支持，可以作为多种语言编译器的后台来使用，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。</p><p>LLVM 三段式架构：</p><ul><li><p>前端：解析源代码，由语法分析器和语义分析协同工作，检查语法错误，并构建语言的抽象语法树来表示输入代码， 然后将分析好的代码转化为 LLVM 的中间表示 IR (IntermediateRepresentation) 。</p></li><li><p>优化器：通过一系列的 Pass 对中间代码 IR 进行优化， 改善代码的运行时间使代码更高效。</p></li><li><p>后端：负责将优化器优化后的中间代码 IR 转换为目标机器的代码</p></li></ul><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130149036.png" alt="image-20240124130149036"></p><p><strong>OLLVM(Obfuscator-LLVM)</strong> 是瑞士西部应用科学大学安全小组于 2010 年 6 月发起的一个项目。该项目的目的是提供一套开源的<strong>基于****LLVM</strong>的代码混淆工具，通过代码混淆和防篡改提供更高的软件安全</p><p>性。</p><p>OLLVM 工作在 LLVM IR 中间表示层，通过<strong>编写<strong><strong>Pass</strong></strong>来混淆****IR</strong>， 后端依照 IR 转换的目标机器的代码也就达到了混淆的目的。</p><p>OLLVM 提供了三种混淆模式：</p><ul><li><p>指令替换 (Instructions Substitution)</p></li><li><p>虚假控制流 (BogusControl Flow)</p></li><li><p>控制流平坦化 (Control Flow Flattening)</p></li></ul><h2 id="正向使用"><a href="#正向使用" class="headerlink" title="正向使用"></a><strong>正向使用</strong></h2><h4 id="编译-ollvm"><a href="#编译-ollvm" class="headerlink" title="编译 ollvm"></a><strong>编译</strong> <strong>ollvm</strong></h4><p>编译环境为 ubuntu 20.04，先下载 ollvm 源码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b llvm-<span class="number">4</span>.<span class="number">0</span> https://github.com/obfuscator-llvm/obfuscator.git</span><br></pre></td></tr></table></figure><p>然后修改 <code>obfuscator/include/llvm/ExecutionEngine/Orc/OrcRemoteTargetClient.h</code> 文件第690 行，将 <code>Expected&lt;std::vector&lt;uint8_t&gt;&gt;</code> 改为<code>Expected&lt;std::vector&lt;unsigned char&gt;&gt;</code></p><p>接着降低 gcc 版本，执行如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-<span class="number">8</span> g++-<span class="number">8</span> -y</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-<span class="number">8</span> <span class="number">8</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-<span class="number">8</span> <span class="number">8</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-<span class="number">9</span> <span class="number">9</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-<span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>切换 gcc 与 g++ 的默认版本</p><p>sudo update-alternatives –config gcc</p><p>sudo update-alternatives –config g++</p><p>在 obfuscator 目录下执行如下命令，开始编译：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../</span><br><span class="line">make -j7</span><br></pre></td></tr></table></figure><p>编译完成后，在 obfuscator&#x2F;build&#x2F;bin 目录下会产生很多可执行文件，将这个路径添加到环境变量即可。</p><h3 id="使用-ollvm"><a href="#使用-ollvm" class="headerlink" title="使用 ollvm"></a><strong>使用</strong> <strong>ollvm</strong></h3><h4 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a><strong>指令替换</strong></h4><p>通过功能上等价的但更复杂的指令序列， 替换标准二元运算符（如加法、 减法或布尔运算符）， 当有</p><p>多个可用的等效指令序列时， 随机选择一个。</p><p>编译选项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -sub: 激活指令替代</span><br><span class="line">-mllvm -sub_loop=<span class="number">3</span>: 混淆次数，一个函数会被混淆<span class="number">3</span>次，默认为<span class="number">1</span>次</span><br></pre></td></tr></table></figure><p>混淆前后对比</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130430375.png" alt="image-20240124130430375"></p><h5 id="指令转换："><a href="#指令转换：" class="headerlink" title="指令转换："></a>指令转换：</h5><p>Addition</p><ul><li><p><code>a = b - (-c)</code></p></li><li><pre><code>r = rand (); a = b - r; a = a + b; a = a + r<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  r = rand (); a = b + r; a = a + c; a = a - r</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>a = -(-b + (-c))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Subtraction</span><br><span class="line"></span><br><span class="line">- `a = b + (-c)`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  r = rand (); a = b - r; a = a - c; a = a + r</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>r = rand (); a = b + r; a = a - c; a = a - r</code></pre></li></ul><p>AND</p><ul><li><code>a = b &amp; c</code> &#x3D;&gt; <code>a = (b ^ ~c) &amp; b</code></li></ul><p>OR</p><ul><li><code>a = b | c</code> &#x3D;&gt; <code>a = (b &amp; c) | (b ^ c)</code></li></ul><p>XOR</p><ul><li><code>a = a ^ b</code> &#x3D;&gt; <code>a = (~a &amp; b) | (a &amp; ~b)</code></li></ul><h4 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a><strong>虚假控制流</strong></h4><p>通过在当前基本块之前添加基本块来修改程序的控制流图，原始的基本块也会被克隆，并插入随机的垃圾指令。</p><p>编译选项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -bcf: 激活虚假控制流</span><br><span class="line">-mllvm -bcf_loop=<span class="number">3</span>: 混淆次数，一个函数会被混淆<span class="number">3</span>次，默认为<span class="number">1</span></span><br><span class="line">-mllvm -bcf_prob=<span class="number">40</span>: 每个基本块被混淆的概率，当前每个基本块被混淆的概率为<span class="number">40</span><span class="variable">%，默认为30%</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130457258.png" alt="image-20240124130457258"></p><h4 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a><strong>控制流平坦化</strong></h4><p>消除正常程序控制流中基本块的相互关联，使用一个集中的主分发块来调度基本块的执行顺序，得到一</p><p>个循环嵌套Switch的执行逻辑。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130521676.png" alt="image-20240124130521676"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130535132.png" alt="image-20240124130535132"></p><p>序言：函数的第一个执行的基本块主(子)分发器：控制程序跳转到下一个待执行的基本块</p><p>retn块：函数出口</p><p>真实块：混淆前的基本块，程序真正执行工作的版块</p><p>预处理器：跳转到主分发器</p><p>编译选项：</p><p><a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening">https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -fla: 激活控制流平坦化</span><br><span class="line">-mllvm -split: 激活基本块分割</span><br><span class="line">-mllvm -split_num=<span class="number">3</span>: 指定基本块分割的数目</span><br></pre></td></tr></table></figure><p><a href="http://t.csdnimg.cn/FaGnP">angr安装</a></p><p>关于angr的一些题目：<a href="https://www.cnblogs.com/level5uiharu/p/16925991.html">https://www.cnblogs.com/level5uiharu/p/16925991.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;OLLVM&quot;&gt;&lt;a href=&quot;#OLLVM&quot; class=&quot;headerlink&quot; title=&quot;OLLVM&quot;&gt;&lt;/a&gt;OLLVM&lt;/h1&gt;&lt;p&gt;LLVM 是一个&lt;strong&gt;开源的编译器架构&lt;/strong&gt;，利用虚拟技术对源代码提供现代</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>指令虚拟化</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2024-01-22T16:00:00.000Z</published>
    <updated>2024-01-23T16:56:30.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令虚拟化"><a href="#指令虚拟化" class="headerlink" title="指令虚拟化"></a>指令虚拟化</h1><p>虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数和结构来解析自定义的指令并执行相应的功能。</p><p>虚拟化是一种基于虚拟机的代码保护技术。他将硬件支持的机器码转化为字节码指令系统，来达到不被轻易篡改和逆向的目的。</p><p>简单来说就是出题人通过实现一个小型的虚拟机，自定义一些操作码（opcode），然后在程序执行时通过解释操作码，执行对应的函数，从而实现程序原有的功能。</p><p>下图是常见的虚拟机结构：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123191130428.png" alt="image-20240123191130428"></p><p>虚拟机的主程序其实就是一个循环，这个循环不断的去读取指令（伪机器码 opcode），然后执行指令opcode 所对应的一些函数，这样下来就可以与真实的程序执行相差无几。</p><h2 id="正向实现"><a href="#正向实现" class="headerlink" title="正向实现"></a><strong>正向实现</strong></h2><p>想要对抗虚拟化，首先要搞清楚用于保护的虚拟机是如何实现的要想实现虚拟机，需要完成两个目标：</p><ol><li><p>定义一套指令集</p></li><li><p>实现对应的解释器</p></li></ol><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h3><p>真实赛题中的 VM 通常会实现一个类似如下的结构体，用于保存虚拟机状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r1; <span class="comment">// 虚拟寄存器 r1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r2; <span class="comment">// 虚拟寄存器 r2</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> eip; <span class="comment">// 指向正在解释的 opcode 地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mem[<span class="number">256</span>]; <span class="comment">// 虚拟内存</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[<span class="number">1024</span>]; <span class="comment">// 存放自定义机器码</span></span><br><span class="line">&#125; VM;</span><br></pre></td></tr></table></figure><h3 id="opcode-定义"><a href="#opcode-定义" class="headerlink" title="opcode 定义"></a><strong>opcode</strong> <strong>定义</strong></h3><p>接着自定义一些指令，需要决定该指令集是<strong>定长</strong>的还是<strong>变长</strong>的。</p><p>这里以变长指令集为例，先列出一个表来：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123194824707.png" alt="image-20240123194824707"></p><h3 id="书写机器码"><a href="#书写机器码" class="headerlink" title="书写机器码"></a><strong>书写机器码</strong></h3><p>假定希望实现的语义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> input[<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> target[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, input);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">input[i] ^= <span class="number">0x21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(input, target, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们定义的指令对其进行拆分和重构，可以得到如下机器码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[] = &#123;</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="comment">// mem[0x10] = &#x27;H&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="comment">// mem[0x11] = &#x27;e&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x12] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x13] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="comment">// mem[0x14] = &#x27;o&#x27;</span></span><br><span class="line"><span class="number">0x40</span>, <span class="comment">// scanf(&quot;%5s&quot;, &amp;mem[0]);</span></span><br><span class="line"><span class="number">0x11</span>, <span class="number">0x21</span>, <span class="comment">// r2 = 0x21</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x0</span>, <span class="comment">// r1 = 0</span></span><br><span class="line"><span class="number">0x30</span>, <span class="comment">// mem[r1] ^= r2</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x1</span>, <span class="comment">// r1 = 1</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x2</span>, <span class="comment">// r1 = 2</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x3</span>, <span class="comment">// r1 = 3</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x4</span>, <span class="comment">// r1 = 4</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span> <span class="comment">// return memcmp(&amp;mem[0], &amp;mem[0x10], 5);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化虚拟机"><a href="#初始化虚拟机" class="headerlink" title="初始化虚拟机"></a><strong>初始化虚拟机</strong></h3><p>在实际运行虚拟机之前，需要先对 VM 结构体进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM* <span class="title function_">vm_new</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = (VM*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(VM)); <span class="comment">// 申请内存</span></span><br><span class="line"><span class="built_in">memset</span>(vm, <span class="number">0</span>, <span class="keyword">sizeof</span>(VM)); <span class="comment">// 清空结构体字段</span></span><br><span class="line"><span class="built_in">memcpy</span>(vm-&gt;code, code, <span class="keyword">sizeof</span>(code)); <span class="comment">// 拷贝机器码</span></span><br><span class="line"><span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释器编写"><a href="#解释器编写" class="headerlink" title="解释器编写"></a><strong>解释器编写</strong></h3><p>现在就可以来实现每条指令的 handle 以及 dispatcher 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vm_run</span><span class="params">(VM* vm)</span> &#123;</span><br><span class="line"><span class="type">char</span> opcode;</span><br><span class="line"><span class="type">char</span> operand_1, operand_2;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">opcode = vm-&gt;code[vm-&gt;eip];</span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r1 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r2 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line">vm-&gt;mem[operand_1] = operand_2;</span><br><span class="line">vm-&gt;eip += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2;</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, &amp;vm-&gt;mem[<span class="number">0</span>]);</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">memcmp</span>(&amp;vm-&gt;mem[<span class="number">0</span>], &amp;vm-&gt;mem[operand_1], operand_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><p>于是 main 函数可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = vm_new();</span><br><span class="line"><span class="keyword">if</span> (!vm_run(vm))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a><strong>解题步骤</strong></h2><p>遇到 VM 类的赛题，我们一般按照如下的步骤来解题：</p><ul><li><p>分析 VM 结构</p><ul><li>结构体大小</li><li>有哪些字段（内存、寄存器）</li></ul></li><li><p>分析指令集</p><ul><li>指令长度是否可变</li><li>每种指令的构成</li><li>每种指令的含义（伪汇编）</li><li>VM 的退出条件</li></ul></li><li><p>编写 Python 版解释器，输出伪汇编代码</p></li><li><p>阅读伪代码，分析程序流程，写出去虚拟化的原始代码</p></li><li><p>书写解题脚本</p></li></ul><p>本例中的 Python 版解释器如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>,</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="number">0x40</span>, <span class="number">0x11</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0x0</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x1</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x2</span>,</span><br><span class="line"><span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x3</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x4</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span>]</span><br><span class="line">ip = <span class="number">0</span></span><br><span class="line">r1 = r2 = <span class="number">0</span></span><br><span class="line">mem = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">opcode = code[ip]</span><br><span class="line"><span class="keyword">if</span> opcode == <span class="number">0x10</span> :</span><br><span class="line">r1 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r1, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x11</span> :</span><br><span class="line">r2 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r2, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x20</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">mem[op1] = op2</span><br><span class="line">print(f<span class="string">&quot;mov [&#123;hex(op1)&#125;], &#123;hex(op2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">3</span></span><br><span class="line">elif opcode == <span class="number">0x30</span> :</span><br><span class="line">mem[r1] ^= r2</span><br><span class="line">print(f<span class="string">&quot;xor [&#123;hex(r1)&#125;], &#123;hex(r2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x40</span> :</span><br><span class="line"><span class="meta"># flag = input().encode()</span></span><br><span class="line">flag = b<span class="string">&quot;iDMMN&quot;</span></span><br><span class="line"><span class="keyword">for</span> i in range(len(flag)) :</span><br><span class="line">mem[i] = flag[i]</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x50</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">print(mem[<span class="number">0</span>:op2] == mem[op1:op1 + op2])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">raise ValueError(<span class="string">&quot;unknown opcode&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指令虚拟化&quot;&gt;&lt;a href=&quot;#指令虚拟化&quot; class=&quot;headerlink&quot; title=&quot;指令虚拟化&quot;&gt;&lt;/a&gt;指令虚拟化&lt;/h1&gt;&lt;p&gt;虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数</summary>
      
    
    
    
    
    <category term="指令虚拟化 VM" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96-VM/"/>
    
  </entry>
  
  <entry>
    <title>自修改代码</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/</id>
    <published>2024-01-21T16:00:00.000Z</published>
    <updated>2024-01-22T16:06:59.822Z</updated>
    
    <content type="html"><![CDATA[<p>PE文件结构&#x2F;&#x2F;</p><h1 id="自修改代码"><a href="#自修改代码" class="headerlink" title="自修改代码"></a>自修改代码</h1><p>Self-Modifying Code</p><p>自修改代码（Self-Modifying Code），指在一段代码执行前对它进行修改。把代码以加密的形式保存在可执行文件中（或静态资源中），然后在程序执行的时候进行动态解密。这样我们在采用静态分析时，看到的都是加密的内容，从而减缓甚至阻止静态分析。</p><h2 id="原理与示例"><a href="#原理与示例" class="headerlink" title="原理与示例"></a>原理与示例</h2><p>SMC思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (运行条件满足) &#123;</span><br><span class="line">DecryptProc(Address of Check) <span class="comment">// 对 Check 代码解密</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">Check(); <span class="comment">// 调用 Check</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">EncryptProc(Address of Check) <span class="comment">// 再对代码进行加密，防止程序被 dump</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SMC静态分析对抗示例：</p><p>正常程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS 中 Release 32 位下编译（关闭随机基址），放入 IDA 中查看：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122225317272.png" alt="image-20240122225317272"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> _check__YAHH_Z[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x51</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xEB</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x8B</span>, <span class="number">0xE5</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们想把 check 函数保护起来，先把其机器码摘出来进行加密：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> check[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x33</span>, <span class="number">0xC0</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x94</span>, <span class="number">0xC0</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(check); i++)</span><br><span class="line">&#123;</span><br><span class="line">check[i] ^= <span class="number">0x90</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, check[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c5 1b 7c c1 11 ed 98 a9 a0 90 90 e5 99 57 d5 6c 91 90 90 90 7b 97 57 d5 6c 90 90 90 90 1b d5 6c 1b 75 cd 53</span><br></pre></td></tr></table></figure><p>修改初始代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line">DWORD old;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, PAGE_EXECUTE_READWRITE, &amp;old); <span class="comment">// 修改内存页权限</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, old, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt(); <span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译后，在 16 进制编辑器中找到并修改 check 函数的机器码为加密后的数据</p><p>一个具备 SMC 属性的可执行文件已经构造完成了，现在再用 IDA 进行分析：</p><p>发现原始逻辑已经被很好地隐藏了。</p><p>另一种常见的实现方法是通过新增一个具备 RWX 属性的程序段，将需要保护的代码书写在其中，这样就可以避免调用 VirtualAlloc &#x2F; VirtualProtect &#x2F; mprotect 这类 API 来暴露 SMC 的意图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg(<span class="string">&quot;.qaq&quot;</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:.qaq,ERW&quot;</span>)</span></span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt();</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 IDA 中看到新增了一个段：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122235013392.png" alt="image-20240122235013392"></p><h2 id="对抗思路"><a href="#对抗思路" class="headerlink" title="对抗思路"></a>对抗思路</h2><p>能动态调试最好直接动态调试，因为在程序运行的某一时刻，它一定是解密完成的，这时也就暴露了，使用<strong>动态分析运行到这一时刻即可过掉保护</strong>。</p><p>其次是根据静态分析获得解密算法，写出解密脚本提前解密这段代码。</p><p>解密得到的机器码可以通过 IDAPython 的 patch_byte 接口很方便地写回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PE文件结构&amp;#x2F;&amp;#x2F;&lt;/p&gt;
&lt;h1 id=&quot;自修改代码&quot;&gt;&lt;a href=&quot;#自修改代码&quot; class=&quot;headerlink&quot; title=&quot;自修改代码&quot;&gt;&lt;/a&gt;自修改代码&lt;/h1&gt;&lt;p&gt;Self-Modifying Code&lt;/p&gt;
&lt;p&gt;自修改代码</summary>
      
    
    
    
    
    <category term="逆向 子修改代码" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91-%E5%AD%90%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>花指令&amp;反调试</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/</id>
    <published>2024-01-18T16:00:00.000Z</published>
    <updated>2024-01-22T17:09:44.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="花指令-amp-反调试"><a href="#花指令-amp-反调试" class="headerlink" title="花指令&amp;反调试"></a>花指令&amp;反调试</h1><p>2024&#x2F;01&#x2F;17</p><p>好，做道upx练手，把sublime搞崩了。后来才知道是文件没有保存用不了。<br>现在还有个问题，就是文件git不上去。。。听天由命吧</p><p>2024&#x2F;01&#x2F;18</p><p>git上去了！</p><p>方法：更改了C:\Windows\System32\drivers\etc的hosts，加了IP表，好用！（呜呜呜）</p><p>2024&#x2F;01&#x2F;19</p><p>听伯尼学长说，修改系统配置的http_proxy和https_proxy为梯子的ip，这样就可以在ping的时候走梯子了</p><p>或者直接在cmd里<code>set http_proxy=http://127.0.0.1:7890 &amp; set https_proxy=http://127.0.0.1:7890</code></p><p>欸嘿，昨天玩儿了一天，今天继续学</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>解析失败，一般可能是花指令</p><h3 id="会被执行"><a href="#会被执行" class="headerlink" title="会被执行"></a>会被执行</h3><p>干扰静态分析*</p><h4 id="改变堆栈操作"><a href="#改变堆栈操作" class="headerlink" title="改变堆栈操作"></a>改变堆栈操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">add esp, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用call指令或jmp指令增加执行流程复杂度"><a href="#利用call指令或jmp指令增加执行流程复杂度" class="headerlink" title="利用call指令或jmp指令增加执行流程复杂度"></a>利用call指令或jmp指令增加执行流程复杂度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">call xxx</span><br><span class="line">xxx :</span><br><span class="line">add[esp], <span class="number">0x7</span></span><br><span class="line">retn</span><br><span class="line">_emit <span class="number">0x12</span></span><br><span class="line">_emit <span class="number">0x34</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wwwwww&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有0x12,0x34，push没识别出来，printf后没法执行。</p><p>call–&gt;结束</p><p>找到栈变化的地方（esp转向）按C重编译</p><h3 id="不会被执行"><a href="#不会被执行" class="headerlink" title="不会被执行"></a>不会被执行</h3><h4 id="插入机器码"><a href="#插入机器码" class="headerlink" title="插入机器码"></a>插入机器码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="keyword">xor</span> eax, eax;</span><br><span class="line">jz xxx;</span><br><span class="line">_emit <span class="number">0x11</span>;</span><br><span class="line">_emit <span class="number">0x22</span>;</span><br><span class="line">_emit <span class="number">0x33</span>; <span class="comment">// 0x33是 xor 指令的操作码，会导致后面正常的 push 指令被错误解析</span></span><br><span class="line">xxx:</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改变堆栈平衡"><a href="#改变堆栈平衡" class="headerlink" title="改变堆栈平衡"></a>改变堆栈平衡</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        <span class="keyword">xor</span> eax,eax;</span><br><span class="line">        jz s;</span><br><span class="line">        add esp,<span class="number">0x11</span>;</span><br><span class="line">    s:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA反编译报错，好像可以F5重编译。。。或者发现花指令地方nop！</p><p>xor eax，eax后有jz命令后有一个+1</p><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>检测调试的陷阱w~</p><h3 id="函数检测："><a href="#函数检测：" class="headerlink" title="函数检测："></a>函数检测：</h3><p>函数检测就是通过 Windows 自带的公开或未公开的函数直接检测程序是否处于调试状态。</p><h4 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a><strong>IsDebuggerPresent</strong></h4><p>最简单的调试器检测函数是 IsDebuggerPresent() ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">IsDebuggerPresent</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数查询进程环境块（PEB）中的 BeingDebugged 标志，如果进程处在调试上下文中，则返回一个非零值，否则返回零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> IsDebuggerPresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a><strong>CheckRemoteDebuggerPresent</strong></h4><p>CheckRemoteDebuggerPresent() 用于检测一个远程进程是否处于调试状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">CheckRemoteDebuggerPresent</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE hProcess,</span></span><br><span class="line"><span class="params">_Inout_ PBOOL pbDebuggerPresent</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>如果 hProcess 句柄表示的进程处于调试上下文，则设置 pbDebuggerPresent 变量被设置为TRUE ，否则被设置为 FALSE 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BOOL ret;</span><br><span class="line">CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a><strong>NtQueryInformationProcess</strong></h4><p>NtQueryInformationProcess 用于获取给定进程的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI <span class="title function_">NtQueryInformationProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">_In_ PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class="line"><span class="params">_Out_ PVOID ProcessInformation,</span></span><br><span class="line"><span class="params">_In_ ULONG ProcessInformationLength,</span></span><br><span class="line"><span class="params">_Out_opt_ PULONG ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>第二个参数 ProcessInformationClass 给定了需要查询的进程信息类型。当给定值为0 （ ProcessBasicInformation ）或 7 （ProcessDebugPort ）时，就能得到相关调试信息，返回信息会写到第三个参数 ProcessInformation 指向的缓冲区中。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dbgport = <span class="number">0</span>;</span><br><span class="line">HMODULE hModule = LoadLibrary(<span class="string">&quot;Ntdll.dll&quot;</span>);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess =(NtQueryInformationProcessPtr)GetProcAddress(hModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), <span class="number">7</span>, &amp;dbgPort,<span class="keyword">sizeof</span>(dbgPort),<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> dbgPort != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetLastError"><a href="#GetLastError" class="headerlink" title="GetLastError"></a><strong>GetLastError</strong></h4><p>编写应用程序时，经常需要涉及到错误处理问题。许多函数调用只用 TRUE 和 FALSE 来表明函数的运行结果。一旦出现错误，MSDN 中往往会指出请用 GetLastError 函数来获得错误原因。</p><p>恶意代码可以使用异常来破坏或者探测调试器。调试器捕获异常后，并不会立即将处理权返回被调试进程处理，大多数利用异常的反调试技术往往据此来检测调试器。</p><p>多数调试器默认的设置是捕获异常后不将异常传递给应用程序。如果调试器不能将异常结果正确返回到被调试进程，那么这种异常失效可以被进程内部的异常处理机制探测。</p><p>对于 OutputDebugString 函数，它的作用是在调试器中显示一个字符串，同时它也可以用来探测调试器的存在。使用 SetLastError 函数，将当前的错误码设置为一个任意值。</p><p>如果进程没有被调试器附加，调用 OutputDebugString 函数会失败，错误码会重新设置，因此GetLastError 获取的错误码应该不是我们设置的任意值。</p><p>但如果进程被调试器附加，调用 OutputDebugString 函数会成功，这时 GetLastError 获取的错误码应该没改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD errorValue = <span class="number">12345</span>;</span><br><span class="line"><span class="built_in">SetLastError</span>(errorValue);</span><br><span class="line"><span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Test for debugger!&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == errorValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 DeleteFiber 函数，如果给它传递一个无效的参数的话会抛出ERROR_INVALID_PARAMETER 异常。如果进程正在被调试的话，异常会被调试器捕获。所以，同样可以通过验证 LastError 值来检测调试器的存在。如代码所示，0x57 就是指 ERROR_INVALID_PARAMETER 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> fib[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">DeleteFiber</span>(fib);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">GetLastError</span>() != <span class="number">0x57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样还可以使用 CloseHandle 、 CloseWindow 产生异常，使得错误码改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseHandle((HANDLE)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseWindow((HWND)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_WINDOW_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据检测"><a href="#数据检测" class="headerlink" title="数据检测"></a><strong>数据检测</strong></h3><h4 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a><strong>BeingDebugged</strong></h4><p>数据检测是指程序通过测试一些与调试相关的关键位置的数据来判断是否处于调试状态。比如 PEB 中的 BeingDebugged 参数。数据检测就是直接定位到这些数据地址并测试其中的数据，从而避免调用函数，使程序的行为更加隐蔽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDebug = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h] ; 指向 PEB 基地址</span><br><span class="line">movzx eax, byte ptr [eax+<span class="number">2</span>]</span><br><span class="line">mov BeingDebug, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDebug != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fs:[30h]</strong></p><h4 id="NTGlobalFlag"><a href="#NTGlobalFlag" class="headerlink" title="NTGlobalFlag"></a><strong>NTGlobalFlag</strong></h4><p>由于调试器中启动的进程与正常启动的进程创建堆的方式有些不同，系统使用 PEB 结构偏移量 0x68 处的一个未公开的位置 NTGlobalFlag ，来决定如何创建堆结构。如果这个位置上的值为 0x70 ，则进程处于调试器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h]</span><br><span class="line">mov eax, dword ptr [eax + <span class="number">68</span>h]</span><br><span class="line">and eax, <span class="number">0x70</span></span><br><span class="line">mov BeingDbg, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDbg != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程检测"><a href="#进程检测" class="headerlink" title="进程检测"></a><strong>进程检测</strong></h3><p>进程检测通过检测当前桌面中是否存在特定的调试进程来判断是否存在调试器，但不能判断该调试器是否正在调试该程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FindWindowA(<span class="string">&quot;x32dbg&quot;</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD ID;</span><br><span class="line">    DWORD ret = <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;OllyDBG.EXE&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;OllyICE.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;x64_dbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;windbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;ImmunityDebugger.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特征码检测"><a href="#特征码检测" class="headerlink" title="特征码检测"></a><strong>特征码检测</strong></h3><p>特征码检测枚举当前正在运行的进程，并在进程的内存空间中搜索特定调试器的代码片段。</p><p>例如 OllyDbg 有这样一段特征码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x41, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00,</span><br><span class="line">0x20, 0x00, 0x4f, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x79, 0x00,</span><br><span class="line">0x44, 0x00, 0x62, 0x00, 0x67, 0x00, 0x00, 0x00, 0x4f, 0x00,</span><br><span class="line">0x4b, 0x00, 0x00, 0x00</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;BYTE sign[] = &#123; <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x6f</span>, <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x79</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x44</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x4b</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>; &#125;</span><br><span class="line">    PROCESSENTRY32 sentry32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">    HANDLE phsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    Process32First(phsnap, &amp;sentry32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HANDLE hps = OpenProcess(MAXIMUM_ALLOWED, FALSE,</span><br><span class="line">            sentry32.th32ProcessID);</span><br><span class="line">        <span class="keyword">if</span> (hps != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD szReaded = <span class="number">0</span>;</span><br><span class="line">            BYTE signRemote[<span class="keyword">sizeof</span>(sign)];</span><br><span class="line">            ReadProcessMemory(hps, (LPCVOID)<span class="number">0x4f632a</span>, signRemote,</span><br><span class="line">                <span class="keyword">sizeof</span>(signRemote), &amp;szReaded);</span><br><span class="line">            <span class="keyword">if</span> (szReaded &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span>(sign, signRemote, <span class="keyword">sizeof</span>(sign)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    CloseHandle(phsnap);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">&#125;<span class="keyword">while</span> (Process32Next(phsnap, &amp;sentry32));</span><br></pre></td></tr></table></figure><h3 id="时间检测"><a href="#时间检测" class="headerlink" title="时间检测"></a><strong>时间检测</strong></h3><p>时间检测是指在程序中通过代码感知程序处于调试时与未处于调试时的各种运行时间差异来判断程序是否处于调试状态。</p><p>例如我们在调试时步过两条指令所花费的时间远远超过 CPU 正常执行花费的时间，于是就可以通过rdtsc 指令或 GetTickCount 函数来进行测试。</p><p>注： rdtsc 指令用于将时间标签计数器读入 EDX:EAX 寄存器。 GetTickCount 返回从操作系统动</p><p>所经过的毫秒数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        rdtsc</span><br><span class="line">        mov ecx, edx</span><br><span class="line">        rdtsc</span><br><span class="line">        sub edx, ecx</span><br><span class="line">        mov BeingDbg, edx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BeingDbg &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD time1 = GetTickCount();</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">        mov edx, <span class="number">6</span></span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD time2 = GetTickCount();</span><br><span class="line">    <span class="keyword">if</span> (time2 - time1 &gt; <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断点检测"><a href="#断点检测" class="headerlink" title="断点检测"></a><strong>断点检测</strong></h3><p>断点检测是根据调试器设置断点的原理来检测软件代码中是否设置了断点。调试器一般使用两者方法设置代码断点：</p><ul><li><p>通过修改代码指令为 INT3（机器码为0xCC）触发软件异常</p></li><li><p>通过硬件调试寄存器设置硬件断点</p></li></ul><p>针对软件断点，检测系统会扫描比较重要的代码区域，看是否存在多余的 INT3 指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS32 pNtHeaders;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">DWORD dwBaseImage = (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;</span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader -</span><br><span class="line">&gt; e_lfanew);</span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders +</span><br><span class="line"><span class="keyword">sizeof</span>(pNtHeaders-&gt;Signature) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +</span><br><span class="line">(WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;</span><br><span class="line">DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">BOOL Found = FALSE;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">cld</span><br><span class="line">mov edi, dwAddr</span><br><span class="line">mov ecx, dwCodeSize</span><br><span class="line">mov al, <span class="number">0</span>CCH</span><br><span class="line">repne scasb; 在EDI指向大小为ECX的缓冲区中搜索AL包含的字节</span><br><span class="line">jnz NotFound</span><br><span class="line">mov Found, <span class="number">1</span></span><br><span class="line">NotFound:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于硬件断点，由于程序工作在保护模式下，无法访问硬件调试断点，所以一般需要构建异常程序来获取 DR 寄存器的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">CONTEXT context;</span><br><span class="line">HANDLE hThread = GetCurrentThread();</span><br><span class="line">context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">GetThreadContext(hThread, &amp;context);</span><br><span class="line"><span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> ||</span><br><span class="line">context.Dr3 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他检测"><a href="#其他检测" class="headerlink" title="其他检测"></a><strong>其他检测</strong></h3><h4 id="判断父进程是否为-explorer-exe"><a href="#判断父进程是否为-explorer-exe" class="headerlink" title="判断父进程是否为 explorer.exe"></a><strong>判断父进程是否为</strong> <strong>explorer.exe</strong></h4><p>一般双击运行的进程的父进程都是 explorer.exe，但是如果进程被调试父进程则是调试器进程。也就是说如果父进程不是 explorer.exe 则可以认为程序正在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LONG status;</span><br><span class="line">    DWORD dwParentPID = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    PROCESS_BASIC_INFORMATION pbi;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PNTQUERYINFORMATIONPROCESS NtQueryInformationProcess =</span><br><span class="line">        (PNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandleA(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtQueryInf</span></span><br><span class="line"><span class="string">            ormationProcess&quot;</span>);</span><br><span class="line">            status = NtQueryInformationProcess(hProcess, SystemBasicInformation,</span><br><span class="line">                (PVOID)&amp;pbi, <span class="keyword">sizeof</span>(PROCESS_BASIC_INFORMATION), <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pbi.InheritedFromUniqueProcessId == pe32.th32ProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;explorer.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-STARTUPINFO"><a href="#测试-STARTUPINFO" class="headerlink" title="测试 STARTUPINFO"></a><strong>测试</strong> <strong>STARTUPINFO</strong></h4><p>在使用 CreateProcess 创建进程时,需要传递 STARTUPINFO 的结构体指针，而常常我们并不会一个一个设置其结构的值，连把其他不用的值清 0 都会忽略。</p><p>故可以使用 GetStartupInfo 检查启动信息，如果很多值不为 0，那么就说明自己的父进程不是explorer（explorer.exe 使用 shell32 中 ShellExecute 来运行程序， ShellExecute 会清掉不用的值）</p><p>所以可以利用 STARTUPINFO 结构体中不用的字段来判断程序是否在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">STARTUPINFO si;</span><br><span class="line">GetStartupInfo(&amp;si);</span><br><span class="line"><span class="keyword">if</span> (si.dwX != <span class="number">0</span> || si.dwY != <span class="number">0</span> || si.dwFillAttribute != <span class="number">0</span> || si.dwXSize != <span class="number">0</span> ||</span><br><span class="line">si.dwYSize != <span class="number">0</span> || si.dwXCountChars != <span class="number">0</span> || si.dwYCountChars != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于异常的反调试"><a href="#基于异常的反调试" class="headerlink" title="基于异常的反调试"></a><strong>基于异常的反调试</strong></h4><p>进程中发生异常时若 SEH 未处理或注册的 SEH 不存在，会调用 UnhandledExceptionFilter ，它会运行系统最后的异常处理器。 UnhandledExceptionFilter 内部调用了前面提到过的NtQueryInformationProcess 以判断进程是否正在被调试。</p><p>若进程未被调试，则运行最后的异常处理器。若进程处于调试状态，则将异常派送给调试器。</p><p>SetUnhandledExceptionFilter 函数可以修改系统最后的异常处理器。</p><h4 id="Debug-Block"><a href="#Debug-Block" class="headerlink" title="Debug Block"></a><strong>Debug Block</strong></h4><p>Debug Block 是指在需要保护的程序中，程序自身将一些只能同时有 1 个实例的功能占为己用。比如一般情况下，一个进程只能同时被 1 个调试器调试，那么就可以设计一种模式，将程序以调试方式启动，然后利用系统的调试机制防止被其他调试器调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;花指令-amp-反调试&quot;&gt;&lt;a href=&quot;#花指令-amp-反调试&quot; class=&quot;headerlink&quot; title=&quot;花指令&amp;amp;反调试&quot;&gt;&lt;/a&gt;花指令&amp;amp;反调试&lt;/h1&gt;&lt;p&gt;2024&amp;#x2F;01&amp;#x2F;17&lt;/p&gt;
&lt;p&gt;好，做道up</summary>
      
    
    
    
    
    <category term="花指令 逆向学习 反调试" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4-%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>寄网</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/18/%E7%AE%80%E5%8D%95%E5%AF%84%E7%BD%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/18/%E7%AE%80%E5%8D%95%E5%AF%84%E7%BD%91/</id>
    <published>2024-01-17T16:00:00.000Z</published>
    <updated>2024-01-19T09:06:48.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker网络模式Linux-Bridge-Host-None"><a href="#Docker网络模式Linux-Bridge-Host-None" class="headerlink" title="Docker网络模式Linux-Bridge|Host|None"></a>Docker网络模式Linux-Bridge|Host|None</h2><p> 如果假设Linux是宿主，有一个enp0s3的以太网接口，当有了docker后，会多一个docker0接口，这个docker0是默认Brigade网络的网关，容器的数据要出去需要经过docker0。</p><p>如果创建新的模式（eth0），会默认加入这个docker0网络里，此时docker0下面会多了一个附属的接口，并且通过veth的方式和容器的eth0接口进行连接，如果有新的容器也是会发生同样的事情，这个网络模式叫做Bridge；而“桥”就是docker0，veth可以想象为容器各自通往桥的路，正因为有docker0这座桥，容器里的数据才可以抵达宿主的enp0s3接口，也就是说容器是可以访问外部网络的。</p><p>在Bridge网络中，可以进行容器间、容器与宿主间，容器向互联网的访问，但是互联网-&gt;容器需要端口关联</p><table><thead><tr><th></th><th>默认Bridge</th><th>自定义Bridge</th><th>Host</th><th>None</th></tr></thead><tbody><tr><td>优点</td><td>自动加入</td><td>自动DNS隔离</td><td>网络性能佳</td><td>隔离</td></tr><tr><td>缺点</td><td>无自动DNS</td><td>NAT</td><td>安全问题<br />仅Linux</td><td>不能联网</td></tr><tr><td>场景</td><td>不建议</td><td>单宿主多容器</td><td>单容器多端口</td><td>备份<br />一次性操作</td></tr></tbody></table><h2 id="【虚拟机网络模式】NAT-NAT网络-桥接Bridged-内部网络Internal-仅主机-Host-Only"><a href="#【虚拟机网络模式】NAT-NAT网络-桥接Bridged-内部网络Internal-仅主机-Host-Only" class="headerlink" title="【虚拟机网络模式】NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)"></a>【虚拟机网络模式】NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)</h2><p>ping 的实质：发送一个icmp回显请求报文给目的的主机，并等待回显的icmp应答。然后打印出回显报文。</p><p>回显的结果包括：字节数  、 反应时间、TTL（生存时间）</p><p>Tracert 的实质：利用ICMP数据报和IP数据报头部中的TTL值。TTL（Time To Live）是一个IP数据报的生存时间，当每个IP数据报经过路由器的时候都回把TTL值减去1或者减去在路由器中停留的时间，但是大多数数据报在路由器中停留的时间都小于1秒种，因此实际上就是在TTL值减去了1。这样，TTL值就相当于一个路由器的计数器。<br>当路由器接收到一个TTL为0或者1的IP数据报的时候，路由器就不再转发这个数据了，而直接丢弃，并且发送一个ICMP“超时”信息给源主机。Tracert程序的关键就是这个回显的ICMP报文的IP报头的信源地址就是这个路由器的IP地址。同时，如果到达了目的主机，我们并不能知道，于是，Tracert还同时发送一个UDP信息给目的主机，并且选择一个很大的值作为UDP的端口，使主机的任何一个应用程序都不使用这个端口。所以，当达到目的主机的时候，UDP模块就产生一个“端口不可到达”的错误，这样就能判断是否是到达目的地了。</p><p>原文链接：<a href="https://blog.csdn.net/u013078669/article/details/48437559">https://blog.csdn.net/u013078669/article/details/48437559</a></p><p><a href="http://t.csdnimg.cn/tx3ql">http://t.csdnimg.cn/tx3ql</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker网络模式Linux-Bridge-Host-None&quot;&gt;&lt;a href=&quot;#Docker网络模式Linux-Bridge-Host-None&quot; class=&quot;headerlink&quot; title=&quot;Docker网络模式Linux-Bridge|Host|</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>常用命令/快捷方式</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/16/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/16/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</id>
    <published>2024-01-15T16:00:00.000Z</published>
    <updated>2024-01-30T12:18:23.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令-x2F-快捷方式"><a href="#常用命令-x2F-快捷方式" class="headerlink" title="常用命令&#x2F;快捷方式"></a>常用命令&#x2F;快捷方式</h1><h2 id="IDA："><a href="#IDA：" class="headerlink" title="IDA："></a>IDA：</h2><h3 id="静态调试"><a href="#静态调试" class="headerlink" title="静态调试"></a>静态调试</h3><p>交叉引用：X</p><p>地址跳转：G</p><p>书写注释：&#x2F;（伪代码） ；（反编译窗口）</p><p>修改符号名：N</p><p>数据类型操作：Y</p><p>修改数据长度：D</p><p>函数操作：  </p><ul><li>定义函数：P</li><li>删除函数：Delete&#x2F;U</li><li>修改函数范围：Ctrl+E（函数窗口） Alt+P（反汇编）</li></ul><p>代码与数据转换：</p><ul><li>U取消已有数据</li><li>D变成数据</li><li>C变成指令</li><li>A以该位置为起点定义一个以\0结尾的字符串类型</li><li>O将此处定义为一个地址偏移</li></ul><p>创建数组：* </p><p>创建结构体：Shift+f1–local types–insert</p><p>提取数据：shift+E</p><p>函数调用图：View–Graphs–Function calls</p><p>常数搜索：Alt+I</p><p>Patch：Edit -&gt; Patch program -&gt; Change byte</p><p>要永久 Patch， Edit -&gt; Patch program -&gt; Apply patches to input file</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>选择 Debugger -&gt; Select debugger，选择合适的调试器：</p><p>如果是 exe，可以使用 Local Windows Debugger</p><p>如果是 ELF， 则选择 Remote Linux Debugger</p><p>选择 Debuugger -&gt; Start Process 或者按 F9 开始调试。</p><ul><li>继续运行：F9</li><li>单步步入：F7</li><li>单步步过：F8</li><li>执行到返回：Ctrl +F7</li><li>执行到光标处：F4</li><li>添加、删除断点：F2</li></ul><p>Ctrl+Alt+B 打开断点列表</p><p>Ctrl+E 进行编辑</p><p>F2改内存数据</p><p>选择了调试器之后，打开 Debugger -&gt; Process options，在 Parameters 一栏写入命令行参数即可。</p><h2 id="x96dbg"><a href="#x96dbg" class="headerlink" title="x96dbg"></a>x96dbg</h2><h3 id="常用调试快捷键："><a href="#常用调试快捷键：" class="headerlink" title="常用调试快捷键："></a>常用调试快捷键：</h3><ul><li>F4：运行到光标</li><li>F7：单步步入</li><li>F8：单步步过</li><li>F9：运行程序</li><li>Ctrl+F9：执行到函数返回处</li></ul><h2 id="UPX工具壳"><a href="#UPX工具壳" class="headerlink" title="UPX工具壳"></a>UPX工具壳</h2><p>加壳upx -o packed.exe xxx.exe</p><p>脱壳upx -d xxx.exe</p><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>现在，你知道如何在 <em>Insert</em> 和 <em>Normal</em> 模式下切换了。下面是一些命令，可以让你在 <em>Normal</em> 模式下幸存下来：</p><blockquote><ul><li><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li><li><code>x</code> → 删当前光标所在的一个字符。</li><li><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)  （陈皓注：:w 后可以跟文件名）</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li></ul><p><strong>推荐</strong>:</p><ul><li><code>hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</li><li><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（陈皓注：退出帮助需要输入:q）</li></ul></blockquote><p>sudo su 炒鸡</p><p>reboot 重启</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令-x2F-快捷方式&quot;&gt;&lt;a href=&quot;#常用命令-x2F-快捷方式&quot; class=&quot;headerlink&quot; title=&quot;常用命令&amp;#x2F;快捷方式&quot;&gt;&lt;/a&gt;常用命令&amp;#x2F;快捷方式&lt;/h1&gt;&lt;h2 id=&quot;IDA：&quot;&gt;&lt;a href=&quot;#IDA</summary>
      
    
    
    
    
    <category term="命令 快捷" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E5%91%BD%E4%BB%A4-%E5%BF%AB%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>2024寒假MISC小记录_更0130</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/2024%E5%AF%92%E5%81%87MISC%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/2024%E5%AF%92%E5%81%87MISC%E5%B0%8F%E8%AE%B0%E5%BD%95/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-01-30T14:29:26.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MISCMISC！"><a href="#MISCMISC！" class="headerlink" title="MISCMISC！"></a>MISCMISC！</h1><h2 id="2024-x2F-01-x2F-14"><a href="#2024-x2F-01-x2F-14" class="headerlink" title="2024&#x2F;01&#x2F;14"></a>2024&#x2F;01&#x2F;14</h2><h3 id="签到喵："><a href="#签到喵：" class="headerlink" title="签到喵："></a>签到喵：</h3><p>python库函数，喵语</p><h3 id="加密-A-宽宽-S-00-E："><a href="#加密-A-宽宽-S-00-E：" class="headerlink" title="加密 A 宽宽 S 00 E："></a>加密 A 宽宽 S 00 E：</h3><p>零宽字节，ASE加密 </p><h3 id="是uu吗："><a href="#是uu吗：" class="headerlink" title="是uu吗："></a>是uu吗：</h3><p>uuencode，steghide （感觉这几个隐写工具都得筛一次啊（悲</p><h3 id="机密："><a href="#机密：" class="headerlink" title="机密："></a>机密：</h3><p>文件隐藏，爆破 </p><h3 id="EZ签到："><a href="#EZ签到：" class="headerlink" title="EZ签到："></a>EZ签到：</h3><p>伪加密，imagemagick，gaps，f5加密，base家族 （ez））</p><h3 id="社会主义好："><a href="#社会主义好：" class="headerlink" title="社会主义好："></a>社会主义好：</h3><p>核心价值观解码，rabbit解码</p><h2 id="2024-x2F-01-x2F-15"><a href="#2024-x2F-01-x2F-15" class="headerlink" title="2024&#x2F;01&#x2F;15"></a>2024&#x2F;01&#x2F;15</h2><h3 id="签到（web混入）"><a href="#签到（web混入）" class="headerlink" title="签到（web混入）"></a>签到（web混入）</h3><p><strong>元素反应</strong></p><p>看到提交按钮不能用，先把元素里的disabled变成abled点击试试，弹框：</p><blockquote><p>小火汁提交“ilovejljcxy”就能的到flag了啊</p></blockquote><p>输入框只能输入9位，改成11位，提交”ilovejljcxy“，得到flag</p><h3 id="签到题（web再混入）"><a href="#签到题（web再混入）" class="headerlink" title="签到题（web再混入）"></a>签到题（web再混入）</h3><p><strong>cookie 绕过</strong></p><p>看cookie，didi&#x3D;no，用Editthiscookie插件改一下yes，刷新得</p><p>Li9kYXRhL2luZGV4LnBocA（补全&#x3D;&#x3D;后）解密.&#x2F;data&#x2F;index.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    $file = $_GET[&#x27;file&#x27;];</span><br><span class="line">    if(!isset($file))</span><br><span class="line">        $file = &#x27;1&#x27;;</span><br><span class="line">    $file = str_replace(&#x27;../&#x27;, &#x27;&#x27;, $file);</span><br><span class="line">    include_once($file.&quot;.php&quot;);</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>绕过-&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=..././..././..././..././flag</span><br></pre></td></tr></table></figure><p>PD9waHANCiAgICAkZmxhZyA9ICJmbGFnezkyZWI1ZmZlZTZhZTJmZWMzYWQ3MWM3Nzc1MzE1NzhmfSI7DQo&#x2F;Pg&#x3D;&#x3D;（base64）解密：</p><p>flag{92eb5ffee6ae2fec3ad71c777531578f}</p><h3 id="0和255"><a href="#0和255" class="headerlink" title="0和255"></a>0和255</h3><p><strong>程序逆向</strong> </p><p>小小的程序逆向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding = utf-8 -*-</span><br><span class="line"># @software:PyCharm</span><br><span class="line">from PIL import Image</span><br><span class="line">image = Image.open(&#x27;flag.png&#x27;)   #flag.png分辨率为33*33</span><br><span class="line">width = image.width</span><br><span class="line">height = image.height</span><br><span class="line">image_list = []</span><br><span class="line">for x in range(height):</span><br><span class="line">    scanline_list = []</span><br><span class="line">    for y in range(width):</span><br><span class="line">        pixel = image.getpixel((y, x))</span><br><span class="line">        scanline_list.append(pixel)</span><br><span class="line">    image_list.append(scanline_list)</span><br><span class="line">print(image_list)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding = utf-8 -*-</span><br><span class="line"># @software:PyCharm</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image_list =[...]</span><br><span class="line">width = len(image_list[0])</span><br><span class="line">height = len(image_list)</span><br><span class="line">new_image = Image.new(&#x27;RGB&#x27;, (width, height))</span><br><span class="line">for x in range(height):</span><br><span class="line">    for y in range(width):</span><br><span class="line">        pixel = image_list[x][y]</span><br><span class="line">        new_image.putpixel((y, x), pixel)</span><br><span class="line"></span><br><span class="line">new_image.save(&#x27;flag.png&#x27;)</span><br></pre></td></tr></table></figure><p>扫出来：Polar_Night</p><p>得到字符串MD5加密套上flag</p><h2 id="2024-x2F-01-x2F-16"><a href="#2024-x2F-01-x2F-16" class="headerlink" title="2024&#x2F;01&#x2F;16"></a>2024&#x2F;01&#x2F;16</h2><h3 id="docx隐写"><a href="#docx隐写" class="headerlink" title="docx隐写"></a>docx隐写</h3><p><strong>docx 隐写</strong></p><blockquote><p><code>docx</code>隐写的主要考察方式有：</p><p>​1.docx文件的本质是压缩包，其内可存储文件。</p><p>​2.docx内将文字颜色改透明实现隐藏。</p><p>​3.<code>office</code>和<code>wps</code>均支持<code>docx</code>文件的隐藏文字功能，通过设置可以看到隐藏的文字。</p></blockquote><p>猜到了1、2，但是没找到3</p><p>蛮好玩的。</p><h3 id="超级简单的流量"><a href="#超级简单的流量" class="headerlink" title="超级简单的流量"></a>超级简单的流量</h3><p>确实简单—追踪tcp流–<code>tcp.stream eq 2</code></p><h3 id="100RGB"><a href="#100RGB" class="headerlink" title="100RGB"></a>100RGB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">🐯🐩🐣🐮🐨🐣🐭🐭</span><br><span class="line">🐨🐧🐩🐣🐨🐧🐯🐣🐰🐮</span><br><span class="line">🐨🐧🐪🐣🐨🐩🐪🐣🐭🐬</span><br><span class="line">🐨🐨🐧🐣🐫🐰🐣🐨🐧🐰</span><br><span class="line">🐰🐮🐣🐫🐰🐣🐨🐨🐬</span><br><span class="line">🐪🐩🐣🐰🐬🐣🐰🐮</span><br><span class="line"> 🐨🐨🐫🐣🐬🐨🐣🐰🐬</span><br><span class="line">🐰🐰🐣🐨🐨🐮🐣🐫🐪</span><br><span class="line">🐨🐧🐨🐣🐨🐩🐬🐣🐧</span><br></pre></td></tr></table></figure><p>..我懂了，base100啊。base100是emoji加密</p><p>记得删除换行。</p><p>然后就是ascii解密（16进制</p><p>……</p><p>后面写了几道蚌埠住了，去画画了嘿嘿</p><h2 id="2024-x2F-01-x2F-17"><a href="#2024-x2F-01-x2F-17" class="headerlink" title="2024&#x2F;01&#x2F;17"></a>2024&#x2F;01&#x2F;17</h2><p>ctfshow做了几道（突然发现的小题库（好玩（（欸嘿</p><h3 id="杂项签到"><a href="#杂项签到" class="headerlink" title="杂项签到"></a>杂项签到</h3><p>直接拖winhex</p><h3 id="损坏的压缩包"><a href="#损坏的压缩包" class="headerlink" title="损坏的压缩包"></a>损坏的压缩包</h3><p>拖winhex–png–改了后缀–flag</p><h2 id="2024-x2F-01-x2F-19"><a href="#2024-x2F-01-x2F-19" class="headerlink" title="2024&#x2F;01&#x2F;19"></a>2024&#x2F;01&#x2F;19</h2><p>?做的题又没记录？</p><p>好像是什么。</p><h3 id="迷之栅栏"><a href="#迷之栅栏" class="headerlink" title="迷之栅栏"></a>迷之栅栏</h3><p><a href="http://t.csdnimg.cn/BtcMt">这里放个破解010的过程，有时间读读</a></p><p>使用010editor的文件比较功能找到两张图片的十六进制不同点，按顺序互相取一位数或者栅栏2位解得flag</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121000329395.png" alt="image-20240121000329395"></p><h3 id="你会数数吗"><a href="#你会数数吗" class="headerlink" title="你会数数吗"></a>你会数数吗</h3><p>使用010editor的 工具→直方图 统计计数解得flag，或者复制出来词频统计</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121000544233.png" alt="image-20240121000544233"></p><h2 id="2024-x2F-01-x2F-20"><a href="#2024-x2F-01-x2F-20" class="headerlink" title="2024&#x2F;01&#x2F;20"></a>2024&#x2F;01&#x2F;20</h2><h3 id="你会异或吗"><a href="#你会异或吗" class="headerlink" title="你会异或吗"></a>你会异或吗</h3><p>图片16进制0x50异或</p><h3 id="flag一分为二"><a href="#flag一分为二" class="headerlink" title="flag一分为二"></a>flag一分为二</h3><p>前半watermark，后半改高度</p><h3 id="打不开的图"><a href="#打不开的图" class="headerlink" title="打不开的图"></a>打不开的图</h3><p>png文件开头应该是89 50 4E 47，观察下题目给的png的开头是77 B0 B2 B9，会发现0x89+0x77&#x3D;0x100, 0x50+0xB0&#x3D;0x100, 0x4E+0xB2&#x3D;0x100, 0x47+0xB9&#x3D;0x100, 所以，只要用0x100减去现在png文件中的每个字节的16进制数即可恢复出可以预览的png图片。<br>但是要注意这里还有一个小坑，就是0x100是十进制数的256，而bytes格式最大只能表示到255，出现256会报错，所以题目原png文件中是0的位置，还是0，不能用0x100去减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ff=<span class="built_in">open</span>(<span class="string">&#x27;./misc5.5.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data=ff.read()</span><br><span class="line">l=[]</span><br><span class="line"><span class="keyword">for</span> dd <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> dd==<span class="number">0</span>:</span><br><span class="line">        l.append(dd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l.append(<span class="number">0x100</span>-dd) </span><br><span class="line">ff=<span class="built_in">open</span>(<span class="string">&#x27;./1234.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="comment">#会新建一个可写入的新文件1234.png</span></span><br><span class="line">ff.write(<span class="built_in">bytes</span>(l))</span><br><span class="line">ff.close()</span><br></pre></td></tr></table></figure><h2 id="2024-x2F-01-x2F-21"><a href="#2024-x2F-01-x2F-21" class="headerlink" title="2024&#x2F;01&#x2F;21"></a>2024&#x2F;01&#x2F;21</h2><h3 id="黑丝白丝还有什么丝？"><a href="#黑丝白丝还有什么丝？" class="headerlink" title="黑丝白丝还有什么丝？"></a>黑丝白丝还有什么丝？</h3><p>莫斯密码，白丝·，黑丝_，转场是空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.-- ....- -. - - ----- -... ...-- -- --- .-. . -.-. ..- - .</span><br></pre></td></tr></table></figure><h3 id="我吐了你随意"><a href="#我吐了你随意" class="headerlink" title="我吐了你随意"></a>我吐了你随意</h3><p>好题目。<a href="http://330k.github.io/misc_tools/unicode_steganography.html">零宽解密</a></p><h3 id="迅疾响应"><a href="#迅疾响应" class="headerlink" title="迅疾响应"></a>迅疾响应</h3><p>一道二维码题目，得学学了。。—&gt;<a href="http://t.csdnimg.cn/hNYjT">http://t.csdnimg.cn/hNYjT</a></p><p><a href="https://www.cnblogs.com/SanCai-Newbie/p/16979691.html">他写的好好。</a></p><p><a href="https://merri.cx/qrazybox/">QRazyBox</a></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121223704858.png" alt="image-20240121223704858"></p><h3 id="You-and-me"><a href="#You-and-me" class="headerlink" title="You and me"></a>You and me</h3><p>盲水印，使用工具 BlindWaterMark-master</p><p>python3 bwmforpy3.py decode you.png you_and_me.png wm2.png</p><p><a href="https://ctf-show.feishu.cn/docx/UpC6dtDqgo7VuoxXlcvcLwzKnqh">https://ctf-show.feishu.cn/docx/UpC6dtDqgo7VuoxXlcvcLwzKnqh</a></p><h2 id="20240122"><a href="#20240122" class="headerlink" title="20240122"></a>20240122</h2><p>两个图片题，好像直接扔识图里就ok</p><p>还有一个re</p><p>简单rc4加密，密钥是DH<del>mqqvqxB^||zll@Jq</del>jkwpmvez{</p><p>密文：Ã‚£%öL6;YÌÄéñµ2±–®¿5</p><p>不想写了，chatpy</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_with_0x1F</span>(<span class="params">input_str</span>):</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> input_str:</span><br><span class="line">        <span class="comment"># 将每个字符与0x1F进行异或操作</span></span><br><span class="line">        xored_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="number">0x1F</span>)</span><br><span class="line">        result += xored_char</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">input_string = <span class="string">&quot;DH~mqqvqxB^||zll@Jq~jkwpmvez&#123;&quot;</span></span><br><span class="line">output_string = xor_with_0x1F(input_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入字符串:&quot;</span>, input_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异或操作后的字符串:&quot;</span>, output_string)</span><br></pre></td></tr></table></figure><h2 id="20240123"><a href="#20240123" class="headerlink" title="20240123"></a>20240123</h2><h3 id="crypto签到"><a href="#crypto签到" class="headerlink" title="crypto签到"></a>crypto签到</h3><p>63746673686f777b77656c636f6d655f325f636169676f755f6375707d</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;63746673686f777b77656c636f6d655f325f636169676f755f6375707d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.decode())</span><br></pre></td></tr></table></figure><p>16进制是ascii</p><h3 id="crypto签到2"><a href="#crypto签到2" class="headerlink" title="crypto签到2"></a>crypto签到2</h3><p>Ao(mgHX^E)AN2PSBOu3qI0o</p><p>wp：</p><p><strong>Ao(mg</strong>就是flag用base85编码之后的表示形式<br> base85还有各式各样的编码表。。这是ASCII</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">a=<span class="string">&quot;Ao(mgHX^E)AN2PSBOu3qI0o&quot;</span></span><br><span class="line">a=base64.a85decode(a).decode()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h3 id="Caesar"><a href="#Caesar" class="headerlink" title="Caesar"></a>Caesar</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Zhofrph wr FWIvkrz yhjhwdeoh grj fxs!</span><br></pre></td></tr></table></figure><p>#3 Welcome to CTFshow vegetable dog cup!</p><h3 id="0x36d"><a href="#0x36d" class="headerlink" title="0x36d"></a>0x36d</h3><p>密文： 😫🙄👰😰👣🙋😱👧👌👷👯👩😴👖👫👚🙃👹👏👏😶👳😫👕🙂🙊👵👶👨👰👮🙉👶👵👸👲👺👮👑😶👴😫🙊👫😴👬👹👤👑😱👗🙃👐😶 提示： 有没有一种可能，标题就是密码？</p><p>wp：熟悉的emoji解密，但是，，0x36d不行，换成877</p><h3 id="类型-7"><a href="#类型-7" class="headerlink" title="类型-7"></a>类型-7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">094F5A0F0A0D1805103B0B3D143117183B720438350A45550967674D1E064F2969784440455A460F1A1B</span><br></pre></td></tr></table></figure><p>ctfshow{Wow_u_Kn0w_Ci$c0_Type7_P@ssword!}</p><h3 id="base47"><a href="#base47" class="headerlink" title="base47"></a>base47</h3><p><a href="https://www.cnblogs.com/Guanz/p/17909958.html">写的很好</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"> </span><br><span class="line">ciper = <span class="string">&#x27;E9CV^T+HT5#X36RF4@LAU703+F$E-0N$@68LMXCVDRJJD5@MP#7MUZDTE?WWLG1S#L@+^66H@59KTWYK8TW0RV&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;0123456789ABCDEFGHJKLMNPQRSTUVWXYZ?!@#$%^&amp;*-+&#x27;</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">0</span>  <span class="comment"># 密文转十进制数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciper)):</span><br><span class="line">    p = key.index(ciper[i])  <span class="comment"># 找到每个密文字符对应字典的下标</span></span><br><span class="line">    num += p * (<span class="built_in">len</span>(key) ** (<span class="built_in">len</span>(ciper) - i - <span class="number">1</span>))  <span class="comment"># 45进制转十进制后求和</span></span><br><span class="line"> </span><br><span class="line">s = libnum.n2s(num)  <span class="comment"># 十进制数转字符串 ascii码表 256进制</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="PWN签到题"><a href="#PWN签到题" class="headerlink" title="PWN签到题"></a>PWN签到题</h3><p>欸嘿 nc过去就是</p><h3 id="PWN02"><a href="#PWN02" class="headerlink" title="PWN02"></a>PWN02</h3><p><a href="http://t.csdnimg.cn/GMR5G">http://t.csdnimg.cn/GMR5G</a></p><h2 id="20240124"><a href="#20240124" class="headerlink" title="20240124"></a>20240124</h2><h3 id="flag白给"><a href="#flag白给" class="headerlink" title="flag白给"></a>flag白给</h3><p>嗯…看出套壳upx，然后找flag</p><p>想了半天，不知道这个序列号啥意思，启动程序才知道，</p><p>输入错了，按着这个串找</p><p>嗯……HackAv</p><h3 id="数学不及格"><a href="#数学不及格" class="headerlink" title="数学不及格"></a>数学不及格</h3><p>嗯……数学题，<a href="https://www.cnblogs.com/ethan269/p/ctfshow_re8.html">好题解</a></p><p>源程序不困难，逻辑清晰</p><p>先预定几个参数（注意strtol），再参数运算判断，逆向求解</p><h3 id="签退"><a href="#签退" class="headerlink" title="签退"></a>签退</h3><p><a href="http://t.csdnimg.cn/9c7WX">pyc逆向</a></p><p>在线工具反编译</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 2.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">c_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + <span class="string">&#x27;()&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;BozjB3vlZ3ThBn9bZ2jhOH93ZaH9&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">origin_bytes</span>):</span><br><span class="line">    c_bytes = [ <span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(b)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> origin_bytes ]</span><br><span class="line">    resp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    nums = <span class="built_in">len</span>(c_bytes) // <span class="number">3</span></span><br><span class="line">    remain = <span class="built_in">len</span>(c_bytes) % <span class="number">3</span></span><br><span class="line">    integral_part = c_bytes[<span class="number">0</span>:<span class="number">3</span> * nums]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> [</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">6</span>,</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">18</span>]:</span><br><span class="line">        tmp_unit = [][<span class="built_in">int</span>(tmp_unit[x:x + <span class="number">6</span>], <span class="number">2</span>)]</span><br><span class="line">        resp += <span class="string">&#x27;&#x27;</span>.join([ c_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit ])</span><br><span class="line">        integral_part = integral_part[<span class="number">3</span>:]</span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">        remain_part = <span class="string">&#x27;&#x27;</span>.join(c_bytes[<span class="number">3</span> * nums:]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;0&#x27;</span> * <span class="number">8</span></span><br><span class="line">        tmp_unit = [ <span class="built_in">int</span>(remain_part[x:x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">6</span>,</span><br><span class="line">            <span class="number">12</span>,</span><br><span class="line">            <span class="number">18</span>] ][:remain + <span class="number">1</span>]</span><br><span class="line">        resp += <span class="string">&#x27;&#x27;</span>.join([ c_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit ]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> rend(resp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rend</span>(<span class="params">s</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encodeCh</span>(<span class="params">ch</span>):</span><br><span class="line">        </span><br><span class="line">        f = <span class="keyword">lambda</span> x: <span class="built_in">chr</span>(((<span class="built_in">ord</span>(ch) - x) + <span class="number">2</span>) % <span class="number">26</span> + x)</span><br><span class="line">        <span class="keyword">if</span> ch.islower():</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">97</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">None</span>,).isupper():</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&#x27;&#x27;</span>.join,)((<span class="keyword">lambda</span> <span class="number">.0</span>: <span class="keyword">pass</span>)(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#补充一个，ZmxhZw常见flagbase64头，</p><p>明文+base64+凯撒3—-&gt;密文</p><h2 id="20240125"><a href="#20240125" class="headerlink" title="20240125"></a>20240125</h2><h3 id="misc2"><a href="#misc2" class="headerlink" title="misc2"></a>misc2</h3><p>1、打开misc2压缩包，里面只有misc1是未加密的。</p><p>2、打开misc1压缩包，里面png文件未加密，打开是2020，尝试输入加密文件music的密码。</p><p>3、打开music，得到 ♭‖♭‖‖♯♭♭♬‖♩♫‖♬∮♭♭¶♭‖♯‖¶♭♭‖∮‖‖♭‖§♭‖♬♪♭♯§‖‖♯‖‖♬‖‖♪‖‖♪‖¶§‖‖♬♭♯‖♭♯♪‖‖∮‖♬§♭‖‖‖♩♪‖‖♬♭♭♬‖♩♪‖♩¶‖♩♪‖♩♬‖¶§‖‖♩‖¶♫♭♭♩‖♬♯‖♬§♭‖♭‖♩¶‖‖∮♭♭♬‖‖♭‖♫§‖¶♫‖♩∮♭♭§‖♭§‖♭§§&#x3D;</p><p>4、音符解码得到 U2FsdGVkX1&#x2F;eK2855m8HM4cTq8Fquqtm6QDbcUu4F1yQpA&#x3D;&#x3D;</p><p>5、考虑rabbit解码，key为2020，得到：welcome_to_payhelp</p><p>6、将5、得到的考虑为hint.txt的密码，得到： VmpKMFUxTXhXWGxVV0dob1RUSjRVVll3V2t0aFJscDBZMGhLYTAxWGVIaFZiRkpUWWtaYVZWSnJXbFpOVjJoeVZYcEdZVkpzVG5KVWJHaHBWa1ZWZDFkV1ZtRmtNRFZYVjJ4c2FWSlVWbFJVVnpWdVRXeFZlV1ZHVGxSaVZrWTBXVlJPYzFWR1pFZFRiVGxYWW01Q1dGcEdXbE5UUjBZMlVXMTBWMWRGU2xkV1ZtUXdVekpGZUZOWWJHaFRSVFZWV1d0YVMxTXhjRVZUYTFwc1ZteHdlRlp0ZERCV01VcFlaRE53V0Zac2NIWldSekZMVW1zeFdWSnNTbWxXUjNodlZtMXdUMkl5Vm5OaVNGWnBVbXh3YzFac1VrZFNiRlY0WVVkMFZXSlZXbmxWYlRWUFZsWlplbEZyWkZSaVJrcFFWV3hGYkUwd1VXeE5NRkVsTTBRJTNE</p><p>7、将6、base64解码6次，得到 welcome_to_2020%0Aflag%20is%20coming…%0Athe%20key%20is%20hello%202020%21Ü0</p><p>8、对7、中的url解码进行替换得到 welcome_to_2020 flag is coming…%0Athe key is hello 2020!Ü0</p><p>9、猜测hello 2020!为flag.txt密码</p><p>10、得到flag：flag{g00d_f0r_y0u}</p><h3 id="misc50"><a href="#misc50" class="headerlink" title="misc50"></a>misc50</h3><p>嗯……蛮复杂的</p><p><a href="http://t.csdnimg.cn/Y9SyV">http://t.csdnimg.cn/Y9SyV</a></p><h2 id="20240129"><a href="#20240129" class="headerlink" title="20240129"></a>20240129</h2><p>忘记录了呜呜</p><p>一个是word隐写（因为打开查看隐藏功能，所以一打开就是flag（有点无语</p><p>一个是图片隐写，winhex打开有字符，base85</p><h2 id="20240130"><a href="#20240130" class="headerlink" title="20240130"></a>20240130</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MISCMISC！&quot;&gt;&lt;a href=&quot;#MISCMISC！&quot; class=&quot;headerlink&quot; title=&quot;MISCMISC！&quot;&gt;&lt;/a&gt;MISCMISC！&lt;/h1&gt;&lt;h2 id=&quot;2024-x2F-01-x2F-14&quot;&gt;&lt;a href=&quot;#2024-x2</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>修电脑杂记</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/%E4%BF%AE%E7%94%B5%E8%84%91%E6%9D%82%E8%AE%B0(win/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/%E4%BF%AE%E7%94%B5%E8%84%91%E6%9D%82%E8%AE%B0(win/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-01-25T14:16:21.459Z</updated>
    
    <content type="html"><![CDATA[<p>2024&#x2F;1&#x2F;14</p><h2 id="嘿嘿早上把家里的电脑修好了"><a href="#嘿嘿早上把家里的电脑修好了" class="headerlink" title="嘿嘿早上把家里的电脑修好了"></a>嘿嘿早上把家里的电脑修好了</h2><p>问题：ntfs.sys丢失或损坏蓝屏<br>原因：U盘在开机前启动，导致win7系统没起来，系统文件被修改了<br>解决：命令行：<code>chkdsk C: /f /r</code> ,然后<code>Y</code>，重启后修复就ok了</p><p>修改磁盘大小</p><p><a href="https://support.microsoft.com/zh-cn/topic/microsoft-%E6%94%AF%E6%8C%81-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%94%80%E6%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%8D%E6%96%B0%E5%88%86%E5%8C%BA-c3d64de0-4672-b21f-de4e-b4908fb35ae3">官方win7修改磁盘分区方法</a><br>差不多，还好要删除的F盘在C盘右侧，直接删除F盘，C盘扩展就ok了</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>Domain Name System</p><p>DNS服务器</p><p>2.4GHz频段具备强大的穿墙能力和广阔的覆盖范围，而5GHz频段则更注重速度和稳定性。</p><p>2024&#x2F;01&#x2F;20</p><h2 id="win7系统ip地址冲突"><a href="#win7系统ip地址冲突" class="headerlink" title="win7系统ip地址冲突"></a>win7系统ip地址冲突</h2><p>当同一网络上的两台或多台设备分配了相同的IP地址时，就会发生IP地址冲突</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">ipconfig</span>/release</span><br><span class="line">&gt;<span class="built_in">ipconfig</span>/renew</span><br></pre></td></tr></table></figure><h2 id="win7防火墙0x80070422问题"><a href="#win7防火墙0x80070422问题" class="headerlink" title="win7防火墙0x80070422问题"></a>win7防火墙0x80070422问题</h2><p>win+r–services.msc–windows firewall–启动类型为手动，应用后服务状态改启动，ok了</p><h2 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h2><p>df：查看系统整体空间剩余情况</p><p>du:查看每个文件夹占用情况，或查看当前目录下磁盘用量</p><h3 id="dev-x2F-sha1满了"><a href="#dev-x2F-sha1满了" class="headerlink" title="dev&#x2F;sha1满了"></a>dev&#x2F;sha1满了</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoclean   //清理旧版本软件缓存</span><br><span class="line"></span><br><span class="line">sudo apt-get clean      //清理所有软件缓存</span><br><span class="line"></span><br><span class="line">sudo apt-get autoremove  //删除系统不再使用的孤立软件</span><br></pre></td></tr></table></figure><h2 id="VM-ubuntu没网"><a href="#VM-ubuntu没网" class="headerlink" title="VM-ubuntu没网"></a>VM-ubuntu没网</h2><p>折腾了两天，重装解决一切问题。</p><p>伤心。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2024&amp;#x2F;1&amp;#x2F;14&lt;/p&gt;
&lt;h2 id=&quot;嘿嘿早上把家里的电脑修好了&quot;&gt;&lt;a href=&quot;#嘿嘿早上把家里的电脑修好了&quot; class=&quot;headerlink&quot; title=&quot;嘿嘿早上把家里的电脑修好了&quot;&gt;&lt;/a&gt;嘿嘿早上把家里的电脑修好了&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>x32/64dbg</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/14/20240114-15-16_%E5%A3%B3/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/14/20240114-15-16_%E5%A3%B3/</id>
    <published>2024-01-13T16:00:00.000Z</published>
    <updated>2024-01-24T17:05:05.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习x32dbg，x64dbg使用方法"><a href="#学习x32dbg，x64dbg使用方法" class="headerlink" title="学习x32dbg，x64dbg使用方法"></a>学习x32dbg，x64dbg使用方法</h1><h2 id="x64dbg工具使用"><a href="#x64dbg工具使用" class="headerlink" title="x64dbg工具使用"></a>x64dbg工具使用</h2><h3 id="常用调试快捷键："><a href="#常用调试快捷键：" class="headerlink" title="常用调试快捷键："></a>常用调试快捷键：</h3><ul><li>F4：运行到光标</li><li>F7：单步步入</li><li>F8：单步步过</li><li>F9：运行程序</li><li>Ctrl+F9：执行到函数返回处</li></ul><h2 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h2><p>常见压缩壳：upx，ASpack，PECompat<br>常见加密壳：ASProtector，Armadillo，EXECryptor，Themida，VMProtect</p><p>保存入口参数，通常用pushed&#x2F;popad、pushfd&#x2F;popfd指令对来保存喝回复现场环境</p><h3 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a><strong>壳的加载过程</strong></h3><h5 id="保存入口参数"><a href="#保存入口参数" class="headerlink" title="保存入口参数"></a><strong>保存入口参数</strong></h5><ol><li><p>加壳程序初始化时保存各寄存器的值</p></li><li><p>外壳执行完毕，恢复各寄存器值</p></li><li><p>最后再跳到原程序执行</p></li></ol><p>通常用 pushad &#x2F; popad 、 pushfd &#x2F; popfd 指令对来保存和恢复现场环境</p><h5 id="获取所需函数-API"><a href="#获取所需函数-API" class="headerlink" title="获取所需函数 API"></a><strong>获取所需函数</strong> <strong>API</strong></h5><ol><li><p>一般壳的输入表中只有 GetProcAddress 、 GetModuleHandle 和 LoadLibrary 这几个 API 函数</p></li><li><p>如果需要其他 API 函数，则通过 LoadLibraryA(W) 或 LoadLibraryExA(W) 将 DLL 文件映射到调用进程的地址空间中</p></li><li><p>如果 DLL 文件已被映射到调用进程的地址空间里，就可以调用 GetModuleHandleA(W) 函数获得DLL 模块句柄 </p></li><li><p>一旦 DLL 模块被加载，就可以调用 GetProcAddress 函数获取输入函数的地址</p></li></ol><h5 id="解密各区块数据"><a href="#解密各区块数据" class="headerlink" title="解密各区块数据"></a><strong>解密各区块数据</strong></h5><ol><li><p>处于保护源程序代码和数据的目的，一般会加密源程序文件的各个区块。在程序执行时外壳将这些区块数据解密，以让程序正常运行</p></li><li><p>外壳一般按区块加密，按区块解密，并将解密的数据放回在合适的内存位置</p></li></ol><h5 id="跳转回原程序入口点"><a href="#跳转回原程序入口点" class="headerlink" title="跳转回原程序入口点"></a><strong>跳转回原程序入口点</strong></h5><ol><li><p>在跳转回入口点之前，一般会恢复填写原 PE 文件输入表（IAT），并处理好重定位项（主要是DLL 文件）</p></li><li><p>因为加壳时外壳自己构造了一个输入表，因此在这里需要重新对每一个 DLL 引入的所有函数重新获取地址，并填写到 IAT 表中3. 做完上述工作后，会将控制权移交原程序，并继续执行</p></li></ol><p>*《程序员的自我修养》</p><h3 id="脱壳方法论"><a href="#脱壳方法论" class="headerlink" title="脱壳方法论"></a><strong>脱壳方法论</strong></h3><p>如今脱壳主要分为两种方式，第一种方式是：</p><h4 id="工具脱壳"><a href="#工具脱壳" class="headerlink" title="工具脱壳"></a><strong>工具脱壳</strong></h4><p>所谓脱壳机是针对特定的一种或一类壳开发出来的脱壳软件，它们是由他人在逆向完壳的相关原理后编写的一类自动化工具，具有一定的局限性。</p><p>对于无法使用工具成功脱壳的情况，便需要用到第二种方式：</p><h4 id="手动脱壳（手脱）"><a href="#手动脱壳（手脱）" class="headerlink" title="手动脱壳（手脱）"></a><strong>手动脱壳（手脱）</strong></h4><p>也就是通过一步步分析程序加壳原理，手动还原原始程序的过程，通过手动脱壳，我们可以加深对 PE 格式的理解，增长自己的脱壳水平。在手脱的过程中，我们一般会涉及如下几个概念：</p><ol><li><strong>查壳</strong>。遇到一个加壳程序，第一步应该去分析这是一个什么壳保护的程序，之后我们才能更加有针对性地进行分析与跟踪，遇到难以处理的问题也可以更方便地利用搜索引擎检索同类壳的技术贴。</li></ol><p>常用的查壳工具有 PEiD、Exeinfo PE、DIE 等。</p><ol start="2"><li><p><strong>寻找程序的原入口点（OEP）</strong>。通过单步跟踪、ESP 定律、内存断点等方法找到 OEP。</p></li><li><p><strong>Dump</strong> <strong>内存</strong>。所谓 Dump 内存，指的是将一个进程的内存镜像通过某种方式抓取下来，保存至本地磁盘中，之所以需要 Dump 内存，是因为<strong>在程序执行到</strong> <strong>OEP</strong> <strong>时，内存的状态往往就与未加壳前****的程序相同</strong>（因为壳段代码已经帮我们完成了解密、解压等工作），此时我们将这个状态保存出去，再加上一些后期的修复，就能完成整个脱壳操作了。</p></li><li><p><strong>输入表（IAT）重建</strong>。在 Dump 操作结束之后，程序并不能直接运行，很大程度上是因为输入表并没有被修复好。IAT 可以根据 PE 结构手动修复，也可以通过工具完成。</p></li><li><p><strong>关闭程序重定位</strong>。</p></li></ol><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h4><ul><li>查壳</li><li>识别函数少</li><li>Ctrl-s 段名UPX*</li></ul><h3 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h3><p>手工脱壳:hw1.exe</p><h4 id="寻找OEP-ESP定律-（好用）"><a href="#寻找OEP-ESP定律-（好用）" class="headerlink" title="寻找OEP(ESP定律)（好用）"></a>寻找OEP(ESP定律)（好用）</h4><p>原理利用程序中堆栈平衡来快速寻找OEP</p><h4 id="去重定位"><a href="#去重定位" class="headerlink" title="去重定位"></a>去重定位</h4><p>用CFF小辣椒或者010都可以</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习x32dbg，x64dbg使用方法&quot;&gt;&lt;a href=&quot;#学习x32dbg，x64dbg使用方法&quot; class=&quot;headerlink&quot; title=&quot;学习x32dbg，x64dbg使用方法&quot;&gt;&lt;/a&gt;学习x32dbg，x64dbg使用方法&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="逆向学习 UPX壳" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-UPX%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>操作系统_文件管理专题</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T16:00:00.000Z</published>
    <updated>2024-01-14T14:47:01.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件管理习题"><a href="#文件管理习题" class="headerlink" title="文件管理习题"></a><strong>文件管理习题</strong></h1><p><strong>共三个习题：</strong><br>进程管理、内存管理、文件管理</p><h2 id="一、-单项选择题"><a href="#一、-单项选择题" class="headerlink" title="一、 单项选择题"></a>一、 单项选择题</h2><p>1、下列选项中，用于提高RAID可靠性的措施有 <strong>B</strong></p><p>I.磁盘镜像 II.条带化 III. 奇偶校验 IV.增加Cache机制</p><p>A.仅I、II B.仅I、IIIC.仅I、III和IV D.仅II、III和IV</p><p><strong>&#x2F;&#x2F;提高RAID可靠性措施：eg：RAID0磁盘镜像，RAID5奇偶校验</strong></p><p><a href="http://t.csdnimg.cn/Y2JQw">RAID（磁盘阵列）学习参考</a></p><p>顺便学一下：（可用容量）<br><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227232806438.png" alt="image-20231227232806438"></p><p>2、某磁盘的转速为10000转&#x2F;分，平均寻道时间是6 ms，磁盘传输速率是20 MB&#x2F;s，磁盘控制器延迟为0.2 ms，读取一个4 KB的扇区所需的平均时间约为 <strong>B</strong></p><p>A. 9 ms B. 9.4 ms C. 12 ms D. 12.4 ms</p><p><strong>&#x2F;&#x2F; 平均时间为 9.4ms。</strong></p><p><strong>第一部分 找到磁道的时间 &#x3D; 平均寻道时间&#x3D; 6ms</strong></p><p><strong>第二部分 找到扇区的时间 &#x3D; 磁盘转一圈的时间÷2（平均）&#x3D;（60 秒）&#x2F;（2*10000 转&#x2F;分）&#x3D;3ms</strong></p><p><strong>第三部分 磁盘控制器延迟时间 &#x3D; 0.2ms</strong></p><p><strong>第四部分 数据传输时间 &#x3D; 传输字节数 &#x2F; 磁盘传输速度 &#x3D; 4K &#x2F; 20M &#x3D; 0.2ms（1K≈10 的 3 次方）</strong></p><p><strong>综上 6ms+3ms+0.2ms+0.2ms&#x3D;9.4ms。</strong></p><p>3、用户在删除某文件的过程中，操作系统不可能执行的操作是  <strong>A</strong></p><p>A.删除此文件所在的目录 B.删除与此文件关联的目录项</p><p>C.删除与此文件对应的文件控制块 D.释放与此文件关联的内存缓冲区</p><p><strong>&#x2F;&#x2F;删除此文件所在的目录</strong>（要是我删文件，连该文件目录也删了那太过分了吧啊喂！！！</p><p>4、为支持CD-ROM中视频文件的快速随机播放，播放性能最好的文件数据块组织方式是 <strong>A</strong></p><p>A.连续结构 B.链式结构 </p><p>C.直接索引结构 D.多级索引结构</p><p><strong>&#x2F;&#x2F;虽然是随机播放，但毕竟还是读取文件，播放性能好-&gt;内存离得近-&gt;连续结构</strong></p><p>5、若某文件系统索引结点（inode）中有直接地址项和间接地址项，则下列选项中，与单个文件长度无关的因素是 <strong>A</strong></p><p>A.索引结点的总数 B.间接地址索引的级数 C.地址项的个数 D.文件块大小</p><p><strong>&#x2F;&#x2F;与文件长度无关-&gt;索引结点的总数，怎么索引与文件无关</strong></p><p>6、设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是  <strong>C</strong></p><p>A. 3 B. 75 C. 80 D. 63</p><p><strong>&#x2F;&#x2F;文件大小512B，第1569字节在第1569&#x2F;512&#x3D;3.06-&gt;第四页，顺序在题目上，为80</strong></p><p>7、文件系统采用两级索引分配方式。如果每个磁盘块的大小为 1KB，每个盘块号占 4B，则该系统中单个文件的最大长度是 <strong>B</strong></p><p>A. 32MB B. 64MB C. 128MB D. 256MB</p><p>**&#x2F;&#x2F;单个文件最大长度：被两级索引：[(1KB&#x2F;4B)^2]<em>4B&#x3D;64MB</em>*</p><p>8、一个磁盘的转速为 7200 转&#x2F;分，每个磁道有 160 个扇区，每个扇区为 512B，那么理想情况下，其数据传输率为  <strong>C</strong></p><p>A. 576000KB&#x2F;s B. 7200KB&#x2F;s C. 9600KB&#x2F;s D. 19200KB&#x2F;s</p><p><strong>&#x2F;&#x2F;的转速为 7200r&#x2F;min&#x3D;120r&#x2F;s，转一圈经过 160 个扇区，每个扇区有 512B 所以数据传输率为 120×160×512&#x2F;1024&#x3D;9600KB&#x2F;s。</strong>  </p><p>9、现有容量为10GB的磁盘分区，磁盘空间以簇（cluster）为单位进行分配，簇的大小为4KB。若采用位图法管理该分区的空闲空间，即用一位（bit）标识一个簇是否被分配，则存放该位图所需要簇的个数为： <strong>A</strong></p><p>A. 80 B. 320 C. 80K D. 320K </p><p><strong>&#x2F;&#x2F;10GB&#x2F;4KB&#x3D;2.5M，共有2.5M个可分配的簇， 2.5M&#x2F;8&#x3D;320KB，需要320K的字节来标记可分配的簇， 320KB&#x2F;4KB&#x3D;80个，这320KB同样是按4KB一簇在硬盘上存储，所以需要除4K，得80个簇</strong></p><p>10、 某磁盘阵列中包含 15 块 SAS 硬盘，单一硬盘的容量为 1TB。采用 RAID技术提供具备高可靠性和高可用性的数据存储方案。使用 4 块硬盘组成一个RAID10 硬盘组，8 块硬盘组成一个 RAID 5 硬盘组，3 块硬盘作为热备份硬盘。此磁盘阵列的总可用空间约为 <strong>B</strong></p><p> A. 8TB B. 9TB C. 10TB D.11TB</p><p><strong>&#x2F;&#x2F;1题要记得那个表的最后一行，一一对应，RAID10-一半，2TB；RAID5一个-8-1&#x3D;7TB，3个热备份不算，共9TB</strong></p><p>11、 设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是 <strong>C</strong></p><p>A. 3 B. 75 C. 80 D. 63</p><p><strong>&#x2F;&#x2F;怎么重复了</strong></p><p>12、 若磁盘转速为7200转&#x2F;分，平均寻道时间为8ms,每个磁道包含1000个扇区，则访问一个扇区的平均存取时间大约是 <strong>B</strong></p><p>A．8.1ms B．12.2ms C．16.3ms D．20.5ms</p><p>**&#x2F;&#x2F;磁盘的平均寻址时间包括平均寻道时间和平均等待时间。平均寻道时间为8ms，平均等待时间与磁盘转速有关，为[60s&#x2F;7200]<em>0.5  ≈4.165ms。磁盘的存取一个扇区的时间为60s&#x2F;(7200 * 1000) ≈ 0.0083ms。因此总的时间为：8   4.165    0.0083 &#x3D; 12.1733ms</em>*</p><p>13、 在文件的索引节点中存放直接索引指针10个，一级二级索引指针各1个，磁盘块大小为1KB。每个索引指针占4个字节。若某个文件的索引节点已在内存中，到把该文件的偏移量（按字节编址）为1234和307400处所在的磁盘块读入内存。需访问的磁盘块个数分别是（）</p><p>A．1，2 B．1，3 C．2，3 D．2，4</p><p><strong>&#x2F;&#x2F;直接索引指针所在位置大小 10*1KB ；一级 (1KB&#x2F;4B) *1KB&#x3D;256KB; 二级 [(1KB&#x2F;4B)^2] *1KB</strong></p><p><strong>1234B-&gt;小于10KB，磁盘块1</strong></p><p><strong>307400B-&gt;大于10KB+256KB-&gt;磁盘块3</strong></p><p>14、 假设磁头当前位于第 100 道,正在向磁道序号增加的方向移动。现有一3个磁道访问请求序列为 35,68,110,180,采用 SSTF （最近寻道优先）调度算法得到的磁道访问序列是 ______。<strong>D</strong></p><p>A. 35,68,110,180 B. 110,180,35,68 C. 110,180,68,35 D. 110,68,35,180</p><p><strong>&#x2F;&#x2F;学会（看大题2，3题），学最近寻道优先，很简单</strong></p><p>在某UNIX操作系统中，文件系统给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含13个直接块指针、1个一级间接块指针和1个二级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小一致，均为1KB，地址指针所占空间为4B。</p><p>15、 若某inode共有2个硬链接（hard link），分别为a和b，另有1个符号链接（symbolic link）x-&gt;a，则该inode的link counter为______。 <strong>C</strong></p><p>A．0 B．1 C．2 D．3</p><p><strong>&#x2F;&#x2F;不算符号链接，所以link counter 为 2</strong> </p><p><a href="http://t.csdnimg.cn/ZLrNn">硬链接和符号链接详解</a></p><p>16、 将a删除后，访问x，结果为______。 <strong>A</strong></p><p>A．提示文件不存在 B．打开文件b C．打开一个空文件 D．x已被删除</p><p><strong>&#x2F;&#x2F;提示文件不存在，实践经历（</strong></p><p>17、 假设该索引节点已经被加载进内存中，则若要读取文件的第1MB的内容，需要访问磁盘___3____次。</p><p>A．1 B．2 C．3 D．4 </p><p><strong>&#x2F;&#x2F;直接块指针13个：13KB</strong></p><p>*<em>一级1个，(1KB&#x2F;4B)<em>1KB&#x3D;256KB</em></em></p><p>*<em>二级1个，[(1KB&#x2F;4B)^2]<em>1KB&#x3D;64MB</em></em></p><p><strong>所以需要3次访问磁盘，需要访问二个索引块和一个数据块</strong></p><p>18、 该文件系统能支持的文件最大容量约为_______<strong>B</strong></p><p>A．64KB B．64MB C．4GB ．16GB</p><p><strong>&#x2F;&#x2F;根据上题，最大为64MB</strong></p><p>19、 若将数据块的大小修改为4KB，则该文件系统能支持的文件最大容量约为________。 <strong>C</strong></p><p>A．64KB B．64MB C．4GB ．16GB</p><p>**&#x2F;&#x2F; [(4KB&#x2F;4B)^2]<em>4KB&#x3D;4GB</em>*</p><p>20、 若保持数据块大小1KB不变，在不增加inode中的指针个数的前提下，取</p><p>消一个直接块指针，增加一个三级间接块指针，则能支持的文件最大容量约</p><p>为________。 <strong>D</strong></p><p>A．64KB B．64MB C．4GB D．16GB</p><p>**&#x2F;&#x2F; [(1KB&#x2F;4B)^3]<em>1KB&#x3D;16GB</em>*</p><h2 id="二、-计算问答题"><a href="#二、-计算问答题" class="headerlink" title="二、 计算问答题"></a>二、 计算问答题</h2><p>1、某操作系统中，给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含 12 个直接块指针和 1 个一级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小均为一个扇区，即 512B，地址指针所占空间为 4B。</p><p>1） 该文件系统能支持的文件最大容量是____(1)____。</p><p>2） 为了支持更大的文件，在不增加 inode 中的指针个数的前提下，取消一4个直接块指针，增加一个二级间接块指针，则能支持的文件最大容量是____(2)____。</p><p>3） 在上一问的基础上，若将数据块的大小修改为 1KB，则该文件系统能支持的文件最大容量是____(3)____。</p><p>4） 在上一问的基础上，假设该索引节点已经被加载进内存中，则若要读取文件的第 10MB 的内容，需要访问磁盘____(4)____次。</p><p>*<em>答：（1）(12+(512&#x2F;4))<em>512B&#x3D;71680B&#x3D;70KB</em></em></p><p>*<em>（2）(11+(512&#x2F;4)+ (512&#x2F;4)^2)<em>512B&#x3D;8459776B&#x3D;8261.5KB&#x3D;8.068MB</em></em></p><p>*<em>（3）(11+(1024&#x2F;4)+(1024&#x2F;4)^2)<em>1024B&#x3D;65803KB&#x3D;64.261MB</em></em></p><p><strong>（4）3 次．由上一问知，10MB 需要通过二级间接索引访问，故需要访问二个索引块和一个数据块。</strong></p><p>2、在 inode 的多级索引指针中，为什么保留了直接指向数据块的指针，而不是设计成只使用一个指向多级间接索引块的指针，就可以访问到所有的数据块？数据块的大小可以影响文件系统能支持的最大文件的大小，但是数据块的大小对文件系统的性能和空间利用率之间有什么关系？为什么？</p><p><strong>答：直接指针访问速度快，适合小文件。</strong></p><p><strong>数据块增大，传输数据的单位容量增大，传输效率提升，性能上升。</strong></p><p><strong>数据块增大，则文件存储分配单位变大，内部剩余增加，空间利用率下降。</strong></p><p><strong>数据块减小则情况相反。</strong></p><p>3、若干个等待访问磁盘者依次要访问的柱面为 20,44,40,4,80,12,76，假设每移动一个柱面需要 3ms 时间，移动臂当前位于 40 号柱面，磁头正向磁道号增加的方向移动，请按 FCFS, SSTF, SCAN 算法分别计算为完成上述访问总共花费的寻找时间。</p><p><em><em>FCFS：（|20-40| + |44-20| + |40-44| + |4-40| + |80-4| + |12-80| + |76-12|）</em> 3 &#x3D;</em>* </p><p>**(20+24+4+36+76+68+64)<em>3 &#x3D; 876ms</em>* </p><p><strong>SSTF： 40 - 44 - 20 - 12 – 4 - 76 – 80</strong> </p><p><em><em>（4+24+8+8+72+4）</em> 3 &#x3D; 360 ms</em>*</p><p><strong>SCAN：40 – 44 – 76 – 80 – 20 – 12 - 4</strong> </p><p><em><em>（4+32+4+60+8+8）</em> 3 &#x3D; 348 ms</em>*</p><p>4、假设计算机系统采用 CSCAN(循环扫描)磁盘调度策略,使用 2KB 的内存空间记录 16384 个磁盘块的空闲状态。</p><p>(1) 请说明在上述条件下如何进行磁盘块空闲状态的管理。</p><p>(2) 设某单面磁盘旋转速度为每分钟6000 转,每个磁道有100 个扇区,相邻磁道间的平均移动时间为1ms。若在某时刻,磁头位于100 号磁道处,并沿着磁道号增大的方向移动(如下图所示),磁道号请求队列为50,90,30,120,对请求队列中的每个磁道需读取1 个随机分布的扇区,则读完这4 个扇区点共需要多少时间?要求给出计算过程。</p><p>(3) 如果将磁盘替换为随机访问的Flash 半导体存储器(如U 盘、SSD 等),是否有比CSCAN 更高效的磁盘调度策略?若有,给出磁盘调度策略的名称并说明理由;若无,说明理由。</p><p><strong>(1) 位图法</strong></p><blockquote><p>在CSCAN磁盘调度策略下，管理磁盘块的空闲状态可以采用位图的方式进行。位图是一种数据结构，用于表示磁盘块的分配状态，每个磁盘块用一个比特位来表示其状态（已分配或空闲）。</p><p>给定16384个磁盘块，每个块用一个比特位来表示其状态，所需的比特数可以通过以下方式计算：</p><p>16384个块 ÷ 8位&#x2F;字节 &#x3D; 2048字节 ÷ 1024字节&#x2F;KB &#x3D; 2KB</p><p>因此，需要2KB的内存空间来记录这些磁盘块的空闲状态。</p><p>管理这个位图时，通过初始化所有比特位为“0”来表示所有磁盘块都是空闲的状态。当磁盘块被分配时，相应的比特位被设置为“1”表示已被占用。当磁盘块被释放时，相应的比特位重新设置为“0”以表示它变为空闲状态。</p><p>CSCAN调度算法将磁盘的访问方向限制在一个特定的范围内移动，这使得磁盘空间的管理可以更加高效地实现。</p></blockquote><p><strong>(2) CSCAN：190.4 ms</strong></p><p><strong>寻道时间：|120-100| + |30-120| + |50-30| + |90-50| &#x3D; 170ms</strong></p><p><strong>旋转时间：10ms&#x2F;2*4 &#x3D; 20ms</strong></p><p><strong>读数据：10ms&#x2F;100 * 4 &#x3D; 0.4ms</strong></p><p><strong>(3) FCFS</strong></p><p>ps：</p><blockquote><p><strong>当参加天津大学智算学部“操作系统原理”课程期末考试时</strong></p><p>1．SCAN 算法，磁臂从磁盘的一端向另一端移动，当磁头移过每一个</p><p>柱面时，处理位于该柱面上的请求服务。当到达另一端时，改变方向</p><p>继续处理。（每次都运动到顶端）</p><p>2．C-SCAN 算法，C-SCAN 也是将磁头从磁盘一端移到另一端，随着</p><p>移动不断的处理请求。但是，当磁头移到另一端时，会马上返回到磁</p><p>盘开始，返回时不处理请求.（每次都运动到顶端）</p><p>3．LOOK 算法：是改进的 SCAN 算法，处理过程与 SCAN 相似，只是</p><p>每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。</p><p>4．C-LOOK 算法：是改进的 C-SCAN 算法，处理过程与 C-SCAN 相似，</p><p>只是每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。 </p><p><strong>非期末考试时（如阅读其他教参时、做作业时等）</strong></p><p>SCAN 算法＝LOOK 算法&#x3D;上面第 3 条描述（两头不到顶）</p><p>C-SCAN 算法＝C-LOOK 算法&#x3D;上面第 4 条描述（两头不到顶）</p></blockquote><p>整理自：<a href="https://blog.csdn.net/m0_73495245?type=blog">Wind_9233</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件管理习题&quot;&gt;&lt;a href=&quot;#文件管理习题&quot; class=&quot;headerlink&quot; title=&quot;文件管理习题&quot;&gt;&lt;/a&gt;&lt;strong&gt;文件管理习题&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;共三个习题：&lt;/strong&gt;&lt;br&gt;进程管理、内存管理、</summary>
      
    
    
    
    
    <category term="操作系统_文件管理专题" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T15:12:41.862Z</published>
    <updated>2023-12-27T15:12:42.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理习题！"><a href="#进程管理习题！" class="headerlink" title="进程管理习题！"></a>进程管理习题！</h1><h2 id="一、-单项选择题"><a href="#一、-单项选择题" class="headerlink" title="一、 单项选择题"></a>一、 单项选择题</h2><p>1、设与某资源关联的记录型信号量初值为 1,当前值为 -3。则当前因等待使用该资源而处于阻塞态的进程个数为______。</p><p> A.1 B.0 C.3 D.4</p><p>2、当一个进程处于（ ）状态时，称其为等待（或阻塞）状态。 </p><p>A. 它正等待中央处理机 B. 它正等待合作进程的一个消息 </p><p>C. 它正等待分给它一个时间片 D. 它正等待进入内存</p><p>3、下面关于线程的叙述中，正确的是（ ）。</p><p> A.不论是系统支持线程还是用户级线程，其切换都需要内核的支持。</p><p> B.线程是资源的分配单位，进程是调度和分配的单位。</p><p> C.不管系统中是否有线程，进程都是拥有资源的独立单位。</p><p> D.在引入线程的系统中，进程仍是资源分配和调度分派的基本单位。</p><p>4、资源的按序分配策略可以破坏______条件。</p><p>A. 互斥使用资源 B. 占有且等待资源 C. 非抢夺资源 D. 循环等待资源</p><p>5、下列选项中，会导致用户进程从用户态切换到内核态的操作是</p><p>I.整数除以零 II. sin()函数调用 III. read系统调用</p><p>A.仅I、II B.仅I、III C.仅II、III D. I、II和III</p><p>6、下列关于银行家算法的叙述中，正确的是</p><p>A. 银行家算法可以预防死锁 </p><p>B. 当系统处于安全状态时，系统中一定无死锁进程</p><p>C. 当系统处于不安全状态时，系统中一定会出现死锁进程</p><p>D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件2</p><p>7、有 5 个批处理任务 A、B、C、D、E 几乎同时到达一个计算中心。它们预计运行的时间分别是 10min、6min、2min、4min 和 8min。其优先级（由外部设定）分别为 3、5、2、1 和</p><p>4，这里 5 为最高优先级。下列各种调度算法中，其平均进程周转时间为 14min 的是</p><p>A. 时间片轮转调度算法 B. 优先级调度算法</p><p>C. 先来先服务调度算法 D. 最短作业优先算法</p><p>8、可以被多个进程在任意时刻共享的代码必须是________。</p><p>A. 顺序代码 B. 机器语言代码 C.不能自身修改的代码 D. 无转移指令代码</p><p>9、设m为同类资源数，n为系统中并发线程数。当n个进程共享m个互斥资源时，每个进程的最大需求是w；则下列情况会出现系统死锁的是：</p><p>A. m&#x3D;2,n&#x3D;1,w&#x3D;2 B. m&#x3D;2,n&#x3D;2,w&#x3D;1 C. m&#x3D;4,n&#x3D;3,w&#x3D;2 D. m&#x3D;4,n&#x3D;2,w&#x3D;3</p><p>10、 下列调度算法中，不可能导致饥饿现象的是：</p><p>A.时间片轮转 B.静态优先级调度 </p><p>C.非抢占式作业优先 D.抢占式短作业优先</p><p>11、 某系统有n台互斥使用的同类设备，3个并发进程，最多分别需要3,4,5台设备，可确保系统不会发生死锁的设备数n最少为：</p><p>A. 9 B. 10 C. 11 D. 12</p><p>12、 下列指令中，不能在用户态执行的是：</p><p>A.trap 指令 B.跳转指令 C. 压栈指令 D.关中断指令</p><p>13、 一个进程调用了阻塞式系统调用read()进行读磁盘操作，操作完成后，操作系统针对该进程必须做的是：</p><p>A.修改进程状态为就绪态 B.降低进程优先级</p><p>C.进程分配用户内存空间 D.增加进程的时间片大小</p><p>设系统中有三种类型的资源（A、B、C），它们的资源数量分别是 17、5、20，五个进程（P1，</p><p>P2，P3，P4，P5）。在 T0 时刻系统状态如下表所示，系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230517556.png" alt="image-20231227230517556"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230525378.png" alt="image-20231227230525378"></p><p>14、 在T0时刻若进程P2请求资源（0,3,4），是否能实施分配？为什么？</p><p>A. 不可以，因为无足够资源完成分配。</p><p>B. 不可以，因为分配后进入不安全状态。</p><p>C. 可以，分配后存在安全序列 P4-&gt;P2-&gt;P5-&gt;P3-&gt;P1。</p><p>D. 可以，分配后存在安全序列 P2-&gt;P5-&gt;P4-&gt;P1-&gt;P3。</p><p>假定在单道批处理环境下有5个作业，各作业进入系统的时间和估计运行时间如下表所示：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230539993.png" alt="image-20231227230539993"></p><p>15、 如果应用最短作业优先的作业调度算法，则作业的平均周转时间为______分钟。</p><p> A. 50.3 B. 77.4 C. 37.2 D. 43.4</p><p>16、 某系统正在执行三个进程 P1、P2 和 P3，各进程的计算（CPU）时间和 I&#x2F;O 时间比</p><p>例如下表所示。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230555000.png" alt="image-20231227230555000"></p><p>为提高系统资源利用率，合理的进程优先级设置应为</p><p>A. P1&gt;P2&gt;P3 B. P3&gt;P2&gt;P1 C. P2&gt;P1&#x3D;P3 D. P1&gt;P2&#x3D;P3</p><p>17、 中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调4用不需要保存的是</p><p>A. 程序计数器 B. 程序状态字寄存器C. 通用数据寄存器 D. 通用地址寄存器</p><p>18、 有 5 个批处理任务 A、B、C、D、E 几乎同时到达一个计算中心。它们预计运行的时间分别是 10min、6min、2min、4min 和 8min。其优先级（由外部设定）分别为 3、5、2、1 和 4，这里 5 为最高优先级。下列各种调度算法中，其平均进程周转时间为 14min 的</p><p>是</p><p>A. 时间片轮转调度算法 B. 优先级调度算法</p><p>C. 先来先服务调度算法 D. 最短作业优先算法</p><p>19、 </p><p>一个多道批处理系统中仅有P1和P2两个作业，P2比P1晚5 ms到达。它们的计算和I&#x2F;O操作顺序如下：</p><p>P1：计算 60 ms，I&#x2F;O 80 ms，计算 20 ms</p><p>P2：计算 120 ms，I&#x2F;O 40 ms，计算 40 ms</p><p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是</p><p>A. 240 ms B. 260 ms C. 340 ms D. 360ms</p><p>20、 若某单处理器多进程系统中有多个就绪态进程，则下列关于处理机调度的叙述中错误的是</p><p>A. 在进程结束时能进行处理机调度 B. 创建新进程后能进行处理机调度</p><p>C. 在进程处于临界区时不能进行处理机调度</p><p>D. 在系统调用完成并返回用户态时能进行处理机调度</p><p>21、 下列关于进程和线程的叙述中，正确的是</p><p>A. 不管系统是否支持线程，进程都是资源分配的基本单位</p><p>B. 线程是资源分配的基本单位，进程是调度的基本单位</p><p>C. 系统级线程和用户级线程的切换都需要内核的支持</p><p>D. 同一进程中的各个线程拥有各自不同的地址空间</p><p>22、 下列关于银行家算法的叙述中，正确的是</p><p>A. 银行家算法可以预防死锁</p><p>B. 当系统处于安全状态时，系统中一定无死锁进程5</p><p>C. 当系统处于不安全状态时，系统中一定会出现死锁进程</p><p>D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件</p><p>23、 若一个用户过程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过</p><p>程的叙述中，正确的是</p><p>Ⅰ. 若该文件的数据不在内存，则该进程进入睡眠等待状态</p><p>Ⅱ. 请求 read 系统调用会导致 CPU 从用户态切换到核心态</p><p>Ⅲ. read 系统调用的参数应包含文件的名称</p><p>A. 仅Ⅰ、Ⅱ </p><p>B. 仅Ⅰ、Ⅲ </p><p>C. 仅Ⅱ、Ⅲ </p><p>D. Ⅰ、Ⅱ和Ⅲ</p><p>24、 假设5个进程P0、P1、P2、P3、P4的共享3类资源R1、R2、R3，这些资源总数分别</p><p>为18、6、22。T0时刻的资源分配情况如下表所示，此时存在的一个安全序列是</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230612035.png" alt="image-20231227230612035"></p><p>A. P0，P2，P4，P1，P3 </p><p>B. P1，P0，P3，P4，P2</p><p>C. P2，P1，P0，P3，P4 </p><p>D. P3，P4，P2，P1，P0</p><p>25、 设有3个进程共享一个互斥段，如果最多允许有2个进程同时进入互斥段，则所采用的信号量的初值应是（ ）：</p><p>A．2 B．3 C．1 D．0</p><p>26、 两个进程合作完成一个任务。在并发执行中，一个进程要等待其合作伙伴发来消息，或者建立某个条件后再向前执行，这种制约性合作关系被称为进程的（ ）。</p><p>A．同步 B．互斥 C．调度 D．执行</p><p>27、 设备分配问题中，算法实现时，同样要考虑安全性问题，防止在多个进程进行设备请求时，因相互等待对方释放所占设备所造成的（ ）现象。6</p><p>A．瓶颈 B．碎片 C．系统抖动 D．死锁</p><p>28、 下列进程状态的转换中，哪一个是不正确的（ ）。</p><p>A．就绪-&gt;运行 B．运行-&gt;就绪 C．就绪-&gt;阻塞 D．阻塞-&gt;就绪</p><p>29、 在多进程的系统中，为了保证公共变量的完整性，各进程应互斥进入临界区。所</p><p>谓临界区是指______。</p><p>A．一个缓冲区 B．一段数据区 C．同步机制 D．一段程序</p><p>假设系统中有 4 个进程和 4 个可分配资源，当前分配和最大需求如下表所示，已知资源的最大拥有量为 E&#x3D;（12，9，5，4）。系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230628809.png" alt="image-20231227230628809"></p><p>30、 在当前时刻若进程2请求资源（0,1,0,0），是否能实施分配？若能，给出安全序列。</p><p>A．不能分配，因为分配后不存在安全序列。</p><p>B．不能分配，因为资源不足。</p><p>C．能分配，分配后存在安全序列 3-&gt;4-&gt;2-&gt;1</p><p>D．能分配，分配后存在安全序列 3-&gt;4-&gt;1-&gt;2</p><p>有 6 个 CPU 密集型批处理作业 A、B、C、D、E 和 F，几乎同时被提交。预计运行时间分别为 12，6，2，4，8 和 2 分钟。对于下列每种调度算法，忽略进程切换的开销，计算其平均进程周转时间。</p><p>31、 设进程A-F的优先级分别为4，6，3，2，5和1，其中1为最高优先级。则采用优先级调度算法，平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟</p><p>32、 采用先来先服务调度算法，按照A、B、C、D、E和F的顺序运行。则平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟7</p><p>33、 采用最短作业优先调度算法，平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟</p><p>34、 某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的输入、计算和输出时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执行，则执行完3个作业需要的时间最少是______。</p><p>A. 15ms B. 17ms C. 22ms D.27ms</p><p>35、 系统中有3个不同的临界资源R1、R2和R3，被4个进程P1、P2、P3和P4共享。各进程对资源的需求为：P1申请R1和R2，P2申请R2和R3，P3申请R1和R3，P4申请R2。若系统出现死锁，则处于死锁状态的进程数至少是______。</p><p>A. 1 B. 2 C. 3 D.4</p><p>36、 进程P1和P2均包含并发执行的线程，部分伪代码描述如下所示：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230643549.png" alt="image-20231227230643549"></p><p>下列选项中，需要互斥执行的操作是______。</p><p>A. a&#x3D;1 与 a&#x3D;2 B. a&#x3D;x 和 b&#x3D;x C. x+&#x3D;1 与 x+&#x3D;2 D. x+&#x3D;1 与 x+&#x3D;3</p><p>假设系统中有 4 个进程和 1 个可分配资源，当前分配和最大需求如下表所示，已知资源的总量为 100。系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230701803.png" alt="image-20231227230701803"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230708036.png" alt="image-20231227230708036"></p><p>37、 在当前时刻若进程2请求该资源数量为10，是否能实施分配？若能，给出安全序列。</p><p>A．不能分配，因为分配后不存在安全序列。</p><p>B．不能分配，因为资源不足。</p><p>C．能分配，分配后存在安全序列 3-&gt;4-&gt;2-&gt;1</p><p>D．能分配，分配后存在安全序列 3-&gt;4-&gt;1-&gt;2</p><h2 id="二、-简答题"><a href="#二、-简答题" class="headerlink" title="二、 简答题"></a>二、 简答题</h2><p>1、你需要在一个很古老的 UNIX 上编写支持多线程的程序，它的内核不支持线程，内核代码也未公开，所以很难改造内核。请问如何解决这个问题？</p><p>2、在 UNIX 中父进程通过 fork()产生与自己一模一样的子进程，请问执行什么系统调用后，子进程才拥有自己独立的新代码段。这个系统调用的返回值是如何规定的？</p><p>3、当检测到死锁发生时，如果必须杀死一个进程以解除死锁，请问以什么标准来选择被杀死的进程比较合理？</p><p>4、在一单道批处理系统中，一组作业的提交时刻和运行时间如下表所示。试计算一下三种作业调度算法的平均周转时间 T 和平均带权周转时间 W。 (1) 先来先服务; (2) 短作业优先 (3) 高响应比优先。作业提交时刻和运行时间如下表</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230719689.png" alt="image-20231227230719689"></p><p>5、设系统中有 3 种类型的资源(A，B，C)和 5 个进程(P1，P2，P3，P4，P5)，A 资源的数量为 17，B 资源的数量为 5，C 资源的数量为 20。在 T0 时刻系统状态表如下表所示。<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230729750.png" alt="image-20231227230729750"></p><p>系统采用银行家算法试试死锁避免策略。</p><p>(1) T0 时刻是否为安全状态?若是，请给出安全序列。</p><p>(2) 在 T0 时刻若进程 P2 请求资源(0,3,4)，是否能实施资源分配?为什么?</p><p>(3) 在(2)的基础上，若进程 P4 请求资源(2,0,1)，是否能实施资源分配?为什么?</p><p>(4) 在(3)的基础上，若进程 P1 请求资源(0,2,0)，是否能实施资源分配?为什么?</p><p>6、某系统有 R1,R2,R3 共 3 类资源，在 T0 时刻 P1,P2,P3 和 P4 这 4 个进程对资源的占用和 需求情况见下表，此刻系统可用资源向量为(2,1,2）</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230747261.png" alt="image-20231227230747261"></p><p>问题:</p><p> (1)将系统中各种资源总量和此刻各进程对各资源的需求数目用向量或矩阵表示出来</p><p>(2)如果此时 P1,P2 均发出资源请求向量 Request(1,0,1),为了保持系统的安全性应该如 何分配资源?说明你所采用策略的原因。</p><p>(3)如果(2)中两个请求立刻得到满足后，系统此刻是否处于死锁状态?</p><p>7、设有 3 个进程 P、Q、R，它们共享 10 个同类资源，P、Q、R 进程的资源最大需求量依次为 4、7 和 8。现假定它们对资源的请示序列如下表所示:</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230759306.png" alt="image-20231227230759306"></p><p>为了避免死锁，系统分配资源时采用银行家算法。如果申请资源得不到满足，进程就转入阻塞态。根据上述信息，试描述各步骤结束时，申请资源的进程是得到满足，还是转入阻塞状 态，为什么?(起始状态:各进程均不拥有资源，无进程处于阻塞态)</p><p>8、分时操作系统中进程调度算法中对普通进程常常采用的是优先级轮转法，请问如何保证不会有进程因为优先级太低而饥饿？</p><p>9、死锁是一种对操作系统正常运行危害很大的现象，但是大多数死锁的解决方法只停留在理论探讨中，无法应用于实际的操作系统系统。请列举中哪些方法是实际操作系统中采用的应对死锁的可行方法。如果操作系统发现死锁已经发生，应如何应对使造成的损失较小？</p><p>10、 假定下面的 C 语言程序在 UNIX 系统上运行，并且所有系统调用都能成功完成。其中“pthread_create(&amp;t, NULL, bar, NULL);”的功能是创建一个新线程来执行函数bar，并返回线程对象标识 t。“pthread_join(t,NULL);”的功能是等待线程 t 结束。试问此程序在运行过程中会打印出多少个“hello”？需要说明分析过程。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230857634.png" alt="image-20231227230857634"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230904055.png" alt="image-20231227230904055"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程管理习题！&quot;&gt;&lt;a href=&quot;#进程管理习题！&quot; class=&quot;headerlink&quot; title=&quot;进程管理习题！&quot;&gt;&lt;/a&gt;进程管理习题！&lt;/h1&gt;&lt;h2 id=&quot;一、-单项选择题&quot;&gt;&lt;a href=&quot;#一、-单项选择题&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T15:04:10.874Z</published>
    <updated>2023-12-27T15:04:11.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理习题"><a href="#内存管理习题" class="headerlink" title="内存管理习题"></a>内存管理习题</h1><h2 id="⼀、-选择题"><a href="#⼀、-选择题" class="headerlink" title="⼀、 选择题"></a>⼀、 选择题</h2><p>1、设备分配问题中，算法实现时，同样要考虑安全性问题，防⽌在多个进程进⾏设备请求时，因相互等待对⽅释放所占设备所造成的（ D）现象。</p><p>A．瓶颈 B．碎⽚ C．系统抖动 D．死锁</p><p>&#x2F;&#x2F;概念题</p><p>2、主存与辅存间频繁的页⾯置换现象被称为（C ）。</p><p>A．请求调页 B．碎⽚整理 C．系统抖动 D．输⼊输出</p><p>&#x2F;&#x2F;概念题</p><p>3、在可变分区存储管理中，最差适应分配算法要求对空闲区表项按（C ）进⾏排列。</p><p>A．地址从⼤到⼩ B．地址从⼩到⼤ C．尺⼨从⼤到⼩ D．尺⼨从⼩到⼤</p><p>&#x2F;&#x2F;概念题</p><p>4、段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管</p><p>理的基本思想，即（B）。</p><p> A、⽤分段⽅法来分配和管理物理存储空间，⽤分页⽅法来管理⽤户地址空间。 </p><p> B、⽤分段⽅法来分配和管理⽤户地址空间，⽤分页⽅法来管理物理存储空间。 </p><p> C、⽤分段⽅法来分配和管理主存空间，⽤分页⽅法来管理辅存空间。 </p><p>D、⽤分段⽅法来分配和管理辅存空间，⽤分页⽅法来管理主存空间。</p><p>&#x2F;&#x2F;概念题：先分段再分页</p><p>5、下列措施中，能加快虚实地址转换的是：（C）</p><p>I. 增⼤快表（TLB） II. 让页表常驻内存 III. 增加交换区</p><p>A. 仅 I B. 仅 II C. 仅 I,II D. 仅 II,III</p><p>6、在页式存储管理系统中，采⽤某些页⾯置换算法，会出现Belady异常现象，即进程的缺页次数会随着分配给该进程的页框个数的增加⽽增加。下列算法中，可能出现Belady异常现象的是：</p><p>I. LRU 算法 II. FIFO 算法 III. OPT 算法</p><p>A. 仅 II B.仅 I,II C. 仅 I,III D. 仅 II,III2</p><p>7、下列选项中，属于多级页表优点的是：</p><p>A.加快地址变换速度 </p><p>B.减少缺页中断次数</p><p>C. 减少⼀个页表项所占字节数 </p><p>D.减少页表所占的内存空间</p><p>8、下列关于虚拟存储器的叙述中，正确的是</p><p>A. 虚拟存储器只能基于连续分配技术 B. 虚拟存储器只能基于⾮连续分配技术</p><p>C. 虚拟存储器只受外存容量的限制 D. 虚拟存储器只受内存容量的限制</p><p>9、在⼀个请求分页系统中，采⽤ LRU 页⾯转换算法时，加⼊⼀个作业的页⾯⾛向为：</p><p>1，3，2，1，1，3，5，1，3，2，1，5.当分配给该作业的物理块数分别为 3 和 4 时，在</p><p>访问过程中所发⽣的缺页率为</p><p>A. 25%，33% B. 50%，25% C.50%,33% D. 50%，75%</p><p>10、 设有 8 页的逻辑空间，每页有 1024B,它们被映射到 32 块的物理存储区中。那么，</p><p>逻辑地址的有效位是_______位，物理地址⾄少是________位。</p><p>A. 10、11 </p><p>B. 12、14 </p><p>C. 13、15 </p><p>D. 14、16</p><p>11、 某作业的逻辑地址空间为4页，页⾯⼤⼩为2048，已知页表如下所⽰，则逻辑地址</p><p>4865（⼗进制）对应的物理地址为（ ）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227224908008.png" alt="image-20231227224908008"></p><p>A、4865 B、8961 C、13057 D、6865</p><p>12、 若⽤户进程访问内存时产⽣缺页，则下列选项中，操作系统可能执⾏的操作是</p><p>I.处理越界错 </p><p>II.置换页 </p><p>III.分配内存</p><p>A.仅I、II B.仅II、III C. 仅I、III D. I、II和III</p><p>13、 可以被多个进程在任意时刻共享的代码必须是________。</p><p>A. 顺序代码 B. 机器语⾔代码 C.不能⾃⾝修改的代码 D. ⽆转移指令代码</p><p>14、 假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000 H；地址 1000H 中</p><p>的内容为 2000H，地址 2000H 中的内容为 3000H，地址 3000 H 中的内容为 4000H，则变3</p><p>址寻址⽅式下访问到的操作数是： </p><p>A. 1000H B. 2000H C. 3000H D. 4000 H</p><p>15、 有⼀个整数矩阵为 100 ⾏*200 列，即 a[100][200]。在⼀个虚拟系统中，采⽤ LRU 算</p><p>法，系统分给该进程 5 个页⾯来存储数据（不包含程序），设每页可存放 200 个整数，该</p><p>程序要对整个数组初始化，数组存储时是按⾏存放的。试计算下列两个程序各⾃的缺页</p><p>次数（假定所有页都以请求⽅式调⼊）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225029374.png" alt="image-20231227225029374"></p><p>A. 100,200 B. 100,20000 C. 200,100 D. 20000,100</p><p>16、 考虑页⾯置换算法，系统有 m 个物理块供调度，初始时全空，页⾯引⽤串长度为</p><p>p，包含了 n 个不同的页号，⽆论⽤什么算法，缺页次数不会少于（ ）</p><p>A、m B、p C、n D、min(m,n)</p><p>17、 总体上说，“按需调页”（Demand-Paging）是个很好的虚拟内存管理策略。但是，</p><p>有些程序设计技术并不适合于这适种环境。例如（ ）</p><p>A、堆栈 B、线性搜索 C、⽮量运算 D、⼆分法搜索</p><p>18、 把进程地址空间中使⽤的逻辑地址变成内存中物理地址的过程称为：</p><p>A、重定位 B、物理化 C、逻辑化 D、加载</p><p>19、 在可变分区存储管理中，最佳适应分配算法要求对空闲区表项按（ ）进⾏排列。</p><p>A、地址从⼤到⼩ B、地址从⼩到⼤ C、尺⼨从⼤到⼩ D、尺⼨从⼩到⼤</p><p>20、 主存与辅存间频繁的页⾯置换现象被称为（ ）。</p><p>A、请求调页 B、碎⽚整理 C、系统抖动 D、输⼊输出</p><p>21、 某作业的逻辑地址空间为 4 页，页⾯⼤⼩为 2048，已知页表如下所⽰，则逻辑地址4865（⼗进制）对应的物理地址为（ ）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225202115.png" alt="image-20231227225202115"></p><p>A、4865 B、8961 C、13057 D、6865</p><h2 id="⼆、-计算题（选择）"><a href="#⼆、-计算题（选择）" class="headerlink" title="⼆、 计算题（选择）"></a>⼆、 计算题（选择）</h2><p>某操作系统中，进程的逻辑地址空间和系统的物理地址空间均为 64KB，按字节编址。某进程最多需要 8 页（Page）数据存储空间，页的⼤⼩为 2KB，操作系统采⽤固定分配局部置换策略为此进程分配 6 个页框（Page Frame），采⽤⽼化算法（aging）进⾏页⾯置换，每个页⾯使⽤ 8bits 记录使⽤情况。在每个 clock tick结束时，6 个页⾯的 R 位如下所⽰：<br><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225259459.png" alt="image-20231227225259459"></p><p>页表存放在主存中，对主存的⼀次存取需要100ns，对TLB表的查找时间为10ns，处理</p><p>⼀次缺页中断需要10^8 ns（10的8次⽅ns，含更新TLB和慢表的时间）。</p><p>22、 如果现在程序执⾏时遇到逻辑地址1AC5H，这次访问耗费时间为______。</p><p>A. 108 +220ns B. 100ns C. 110ns D. 210ns</p><p>23、 然后，程序执⾏时遇到逻辑地址32C5H，这次访问耗费时间为______。5</p><p>A. 108 +220ns B. 100ns C. 110ns D. 210ns</p><p>24、 32C5H对应的物理地址为______。</p><p>A. 7AC5H B. 22C5H C. 3AC5H D. F2C5H</p><p> 有⼀个整数矩阵为 100 ⾏*100 列，即 a[100][100]。系统分给该进程 5 个页⾯来存储此矩阵，设每页可存放 100 个整数，该程序要对整个数组初始化，数组存储时是按⾏存放的。页⾯采⽤ LRU 页⾯置换算法和局部置换策略。试计算下列两个程序各⾃的缺页次数（假定所有页都以请求⽅式调⼊）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225458098.png" alt="image-20231227225458098"></p><p>25、 程序⼀执⾏时产⽣的缺页中断次数为________。</p><p>A. 20 B. 100 C. 2000 D. 10000</p><p>26、 程序⼆执⾏时产⽣的缺页中断次数为________。</p><p>A. 20 B. 100 C. 2000 D. 10000</p><p>某计算机主存按字节编址，逻辑地址和物理地址都是 32 位，页⾯⼤⼩为 4KB，页表项⼤⼩为 4 字节。请回答下列问题。</p><p>27、 若使⽤⼀级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225436229.png" alt="image-20231227225436229"></p><p>此时页表最⼤占⽤空间为_______。</p><p>A. 4KB </p><p>B. 1MB </p><p>C. 4MB </p><p>D. 32MB</p><p>28、 若使⽤⼆级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225447428.png" alt="image-20231227225447428"></p><p>若该进程共⽤到了10000个页，则此时此⼆级页表占⽤的总空间最⼩为_______。</p><p>A. 4KB </p><p>B. 11KB </p><p>C. 44KB </p><p>D. 11MB</p><p>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 1KB，逻辑地址空间为 32 位，物理地址空间⼤⼩为 4 GB，按字节编址。页表采⽤多级页表，⼀个页表项⼤⼩为 4B。TLB（快表）采⽤全相联映射，有 4 个页表项，内容如下表所⽰。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225522350.png" alt="image-20231227225522350"></p><p>29、 该系统的页表项中，最多可以保存_______位标志位。</p><p>A．8 B．10 C．12 D．16</p><p>30、 若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤______级页</p><p>表较合适。</p><p>A．0 B．1 C．2 D．3</p><p>31、 对逻辑地址3FFF1880H转换为物理地址的结果是______。</p><p>A. 0C153080H B. 0F035880H C. TLB 缺失 D.缺页</p><p>某请求页式存储管理，允许⽤户空间为 32 个页⾯（每页 2KB），主存为 16KB，如有⼀</p><p>个⽤户程序有 10 页长，且某时刻该⽤户进程的页表如下表所⽰</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225948016.png" alt="image-20231227225948016"></p><p>32、 如果程序执⾏时遇到逻辑地址1AC5H，则它对应的物理地址为______。</p><p>A. 7AC5H B. 4AC5H C. 3AC5H D. 缺页</p><p>33、 页表存放在主存中，对主存的⼀次存取需要100ns，对TLB表的查找时间为10ns，</p><p>这次访问耗费时间为______。</p><p>A. 10ns B. 100ns C. 110ns D. 210ns</p><p>34、 如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为80%，则访问</p><p>内存中数据的平均有效访问时间是______。7</p><p>A．120ns B．130ns C．170ns D．190ns</p><p>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 4KB，逻辑地址空间为 32 位，</p><p>物理地址空间为 36 位，⼀个页表项⼤⼩为 4B。⼀次快表（TLB）的访问时间是 10ns，⼀次</p><p>内存的访问时间是 100ns，处理⼀次缺页的平均时间 10^8 ns（已含更新 TLB 和页表的时</p><p>间）。进程的驻留集⼤⼩固定为 2,采⽤最近未使⽤置换算法(NRU)和局部淘汰策略。假设（1）</p><p>TLB 初始为空;（2）地址转换时先访问 TLB,若 TLB 未命中,再访问页表(忽略访问页表之后</p><p>的 TLB 更新时间);（3）有效位为 0 表⽰页⾯不在内存,产⽣缺页中断,缺页中断处理后,返回</p><p>到产⽣缺页中断的指令处重新执⾏。进程的部分页表如下所⽰：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225914783.png" alt="image-20231227225914783"></p><p>35、 该系统的页表项中，最多可以保存_______位标志位。</p><p>A．4 B．8 C．12 D．16</p><p>36、 若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤______级页</p><p>表较合适。</p><p>A．0 B．1 C．2 D．3</p><p>37、 如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为90%，则访问</p><p>内存中数据的平均有效访问时间是______。</p><p>A．20ns B．110ns C．120ns D．320ns</p><p>38、 ⾸先，访问逻辑地址00001618H，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>39、 然后，访问逻辑地址00000FA6H，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>40、 最后，访问逻辑地址0000126CH，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>41、 在依次访问完上述三个逻辑地址后，页框101254H对应的页号为______。</p><p>A．00000H B．00001H C．00002H D．00003H</p><p>某基于动态分区存储管理的计算机,其主存容量为 55MB(初始为空闲) ,分配和释放的顺8</p><p>序为:分配 15MB,分配 30MB,释放 15MB,分配 8MB,分配 6MB。</p><p>42、 若采⽤最佳适配(Best Fit)算法，此时主存中最⼤空闲分区的⼤⼩是______。</p><p>A.7MB B.9MB C.10MB D.15MB</p><p>43、 若采⽤最差适配(Worst Fit)算法，此时主存中最⼤空闲分区的⼤⼩是______。</p><p>A.7MB B.9MB C.10MB D.15MB</p><h2 id="三、-计算题（填空）"><a href="#三、-计算题（填空）" class="headerlink" title="三、 计算题（填空）"></a>三、 计算题（填空）</h2><p>1、在逻辑地址转换为物理地址时，采⽤页式存储管理，两级页表，页⾯⼤⼩为 4 KB，页表</p><p>项⼤⼩为 4 字节。逻辑地址的结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225816196.png" alt="image-20231227225816196"></p><p>若该进程共⽤到了 3072 个页，则此时此⼆级页表占⽤的总空间最⼩为___(1)____。</p><p>TLB（快表）采⽤全相联映射，有 4 个页表项，内容如下表所⽰。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225808126.png" alt="image-20231227225808126"></p><p>则逻辑地址 03FFF180H 对应的物理地址是____(2)_____，逻辑地址 02FF3036H 对应的物理</p><p>地址是____(3)_____。（如⽆对应的物理地址，则填写原因，可能为“TLB 缺失”或“缺页”）</p><p>2、某计算机主存按字节编址，逻辑地址和物理地址都是 32 位，页表项⼤⼩为 4 字节。请</p><p>回答下列问题。</p><p>（1）若使⽤⼀级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225753388.png" alt="image-20231227225753388"></p><p>则页的⼤⼩是__(1)_<strong>。页表最⼤占⽤空间为</strong>(2)__。</p><p>（2）若使⽤⼆级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225746983.png" alt="image-20231227225746983"></p><p>设逻辑地址为LA，则其对应的页⽬录号的表达式___(3)<em><strong>和页表索引的表达式</strong></em>(4)___。</p><p>若该进程共⽤到了3072个页，则此时此⼆级页表占⽤的总空间最⼩为___(5)____。</p><p>（3）采⽤（1）中的分页存储管理⽅式，⼀个代码段起始逻辑地址为 0000 8000H，其长度为8 KB，被装载到从物理地址 0090 0000H 开始的连续主存空间中。页表从主存 0020 0000H 开始的物理地址处连续存放，如下图所⽰（地址⼤⼩⾃下向上递增）。则该代码段对应的两个页表项，物理地址 1 是___(6)<em><strong>，物理地址 2 是</strong></em>(7)_<strong>；这两个页表项中的页框号 1 是</strong>(8)<em><strong>，页框号 2 是</strong></em>(9)<em><strong>；以及代码页⾯ 2 的起始物理地址 3 是</strong></em>(10)___。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225700626.png" alt="image-20231227225700626"></p><h2 id="四、计算题（简答）"><a href="#四、计算题（简答）" class="headerlink" title="四、计算题（简答）"></a>四、计算题（简答）</h2><ol><li>请求分页管理系统中，假设某进程的页表内容如下表所⽰:</li></ol><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225642811.png" alt="image-20231227225642811"></p><p>页⾯⼤⼩为 4KB，⼀次内存的访问时间是 100ns，⼀次快表(TLB)的访问时间是 10ns，处理</p><p>⼀次缺页的平均时间 108 ns(已含更新 TLB 和页表的时间)，进程的驻留集⼤⼩固定为 2，</p><p>采⽤最近最少使⽤置换算法(LRU)和局部淘汰策略。假设 (1) TLB 初始为空; (2) 地址转换时</p><p>先访问 TLB，若 TLB 未命中，再访问页表(忽略访问页表之后的 TLB 更新时间); (3) 有效</p><p>位为 0 表⽰页⾯不在内存，产⽣缺页中断，缺页中断处理后，返回到产⽣缺页中断的指令</p><p>处重新执⾏。设有虚地址访问序列 2362H、1565H、25A5H，请问:</p><p>\1) 依次访问上述三个虚地址，各需多少时间?给出计算过程。</p><p>\2) 基于上述访问序列，虚地址 1565H 的物理地址是多少?请说明理由。</p><p>\2. 某系统的页⾯淘汰算法采⽤⽼化(Aging)算法，每个页⾯分配⼀个8位⼆进制数的计数器。</p><p>某进程共有 6 个页⾯，在时刻 0 之前所有页⾯均未被引⽤过。下表是前 5 个 clock tick 中10</p><p>各页⾯的被引⽤情况，被引⽤者标 1，未被引⽤者标 0。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225628323.png" alt="image-20231227225628323"></p><p>1） 在 clock tick 4 过后，需要淘汰⼀个页⾯，应选择哪个页⾯进⾏淘汰？为什么？</p><p>2） 为什么说⽼化(Aging)算法是⼀种简单有效的算法，但只是 LRU 的⼀个近似实现？</p><p>\3. 设某计算机的逻辑地址空间和物理地址空间均为 64KB,按字节编址。若某进程最多需要</p><p>6 页(Page)数据存储空间,页的⼤⼩为 1KB,操作系统采⽤固定分配局部置换策略为此进</p><p>程分配 4 个页框(Page Frame)。在时刻 260 前的该进程访问情况如下表所⽰(访问位即</p><p>使⽤位)。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225614727.png" alt="image-20231227225614727"></p><p>当该进程执⾏到时刻 260 时,要访问逻辑地址为 17CAH 的数据。请回答下列问题:</p><p>(1) 该逻辑地址对应的页号是多少?</p><p>(2) 若采⽤最近最少使⽤(LRU)置换算法,该逻辑地址对应的物理地址是多少?要求给出计</p><p>算过程。</p><p>\4. 已知某系统页⾯长 4KB，页表项 4B，虚拟地址空间为 64 位，物理地址空间 4GB。</p><p>（1）如采⽤多层分页策略，限定各分层页表最多占 1 页⼤⼩，请问可以采⽤⼏层分页</p><p>策略？</p><p>（2）如采⽤倒排页表⽅式，请问倒排页表的⼤⼩？是每个进程⼀张倒排页表还是系统</p><p>维护⼀张倒排页表？如何解决倒排页表不便于逻辑地址向物理地址转换的问题？11</p><h2 id="五、-简答题"><a href="#五、-简答题" class="headerlink" title="五、 简答题"></a>五、 简答题</h2><p>1、 在虚拟存储管理中，分段式内存管理⽅式解决了分页式内存管理中的什么问题，又</p><p>带来了什么问题呢？</p><p>2、 Intel IA32体系结构中的保护模式是将逻辑地址转成线性地址再转成物理地址，这</p><p>种内存管理⽅式是段页式内存管理⽅式吗，为什么？</p><p>3、 LRU页⾯置换算法是⼀种⽐较优秀的算法但是较难实现，为什么？试给出⼀种可⾏</p><p>的近似算法作为LRU的取代⽅案。</p><p>4、 单纯的分段式和分页式内存管理各有什么缺点？为什么段页式可以避免这些缺点？</p><p>为什么段页式内存管理没有被⼴泛采⽤呢？</p><p>5、 为什么内存管理⽅式中，可变分区管理中有最差适应（worst fit)分配算法，⽽固定</p><p>分区管理中没有这个算法？分区管理中的交换技术（swap）和段式管理中的请求式</p><p>分段技术有什么区别？请求式分段与覆盖技术（overlay）又有什么区别？</p><p>6、 页⾯置换（淘汰）的时机是什么？哪种算法最理想同时也不可能实现？为什么说</p><p>LRU算法很有效但是很难实现？什么是Belady异常？哪种算法存在Belady异常现</p><p>象？</p><p>7、 请讨论⼀下页⾯置换算法中⼯作集（Working Set）置换算法的⼯作原理。</p><p>8、 在内存管理的⽅法中，分段式管理⽐分页式管理有什么优势？段页式与其他⽅式相</p><p>⽐有什么好处？</p><p>9、 为了同时抢占⾼端和中低端市场，CPU ⼚商常常在同⼀⽣产线上⽣产主频和制作⼯</p><p>艺相同的⾼端和低端 CPU，如 Intel 曾经同时⽣产相同主频和制作⼯艺的“奔腾 4”和</p><p>“赛扬”，价格上相差很⼤，据称主要区别在⼆级缓存的⼤⼩。请问缓存（Cache）有</p><p>什么⽤，什么地⽅会⽤到它？12</p><p>10、 为什么要使⽤倒排页表？倒排页表⾯临的最⼤的问题是什么？如何解决？</p><p>11、 内存分区管理中的交换技术与请求式分段技术相⽐，有什么相同点和不同点？</p><p>12、 在页⾯淘汰算法中，为什么说⽼化(Aging)算法只是 LRU 的⼀个近似实现？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存管理习题&quot;&gt;&lt;a href=&quot;#内存管理习题&quot; class=&quot;headerlink&quot; title=&quot;内存管理习题&quot;&gt;&lt;/a&gt;内存管理习题&lt;/h1&gt;&lt;h2 id=&quot;⼀、-选择题&quot;&gt;&lt;a href=&quot;#⼀、-选择题&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些常见加密</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/08/29/++++++m/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/08/29/++++++m/</id>
    <published>2023-08-28T16:00:00.000Z</published>
    <updated>2024-01-18T14:37:50.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Base加密"><a href="#Base加密" class="headerlink" title="Base加密"></a>Base加密</h3><h4 id="Hex-base16"><a href="#Hex-base16" class="headerlink" title="Hex(base16)"></a>Hex(base16)</h4><p>8位二进制–&gt;2个4位字节，长度是源数据的两倍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///encode</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> charset[] = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">convert</span> <span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;<span class="number">0xA</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>+val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>+(val<span class="number">-0xA</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">hex_encode</span><span class="params">(<span class="type">char</span>*<span class="built_in">array</span>,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span>*encode;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">array</span>||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    encode=(<span class="type">char</span>*)<span class="built_in">malloc</span>(size*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        encoded[<span class="number">2</span>*i]=convert((<span class="built_in">array</span>[i]&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xF</span>);</span><br><span class="line">        encode[w*i+<span class="number">1</span>]=convert(<span class="built_in">array</span>[i]&amp;<span class="number">0xF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encode[size*<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> encode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//decode</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">re_convert</span> <span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;<span class="number">0xA</span>)</span><br><span class="line">        <span class="keyword">return</span> val-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> val+<span class="number">0xA</span>-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">hex_decode</span><span class="params">(<span class="type">char</span>*<span class="built_in">array</span>,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span>*decode;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">array</span>||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     encode=(<span class="type">char</span>*)<span class="built_in">malloc</span>((size+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        encoded[<span class="number">2</span>*i]=convert((<span class="built_in">array</span>[i]&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xF</span>);</span><br><span class="line">        encode[w*i+<span class="number">1</span>]=convert(<span class="built_in">array</span>[i]&amp;<span class="number">0xF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encode[size/<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> decode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> test1[] = &#123;<span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAB</span>, <span class="number">0xCD</span>, <span class="number">0xEF</span>&#125;;</span><br><span class="line"><span class="type">char</span> test2[] = &#123;<span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0x3B</span>, <span class="number">0x5C</span>, <span class="number">0xB9</span>, <span class="number">0xF9</span>, <span class="number">0x0F</span>, <span class="number">0x69</span>, <span class="number">0x61</span>, <span class="number">0x8F</span>,</span><br><span class="line"><span class="number">0x5D</span>, <span class="number">0xE6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *m1t1, *m1t2;</span><br><span class="line">    m1t1 = hex_encode(test1, <span class="keyword">sizeof</span>(test1));</span><br><span class="line">m1t2 = hex_encode(test2, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">    m1t3 = hex_decode(test1, <span class="keyword">sizeof</span>(test1));</span><br><span class="line">m1t4 = hex_decode(test2, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t1: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t2: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t3: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t4: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">free</span>(m1t1);</span><br><span class="line"><span class="built_in">free</span>(m1t2);</span><br><span class="line"><span class="built_in">free</span>(m1t3);</span><br><span class="line"><span class="built_in">free</span>(m1t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>编码表长度为64</p><p>编码后的字节数组长度为4的倍数、编码前的4&#x2F;3倍</p><p>编码得到的字符串常以“&#x3D;”结尾（</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</span><br></pre></td></tr></table></figure><p>#变种：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">encoded = <span class="string">&quot;zCN7zTJP3hj71C3BxSj72SuSnhQ=&quot;</span></span><br><span class="line">old = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">new = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ+/&quot;</span></span><br><span class="line">mapper = <span class="built_in">str</span>.maketrans(new, old)</span><br><span class="line">tmp = encoded.translate(mapper)</span><br><span class="line">flag = base64.b64decode(tmp)</span><br><span class="line"><span class="built_in">print</span> (flag.decode())</span><br></pre></td></tr></table></figure><h4 id="Base58"><a href="#Base58" class="headerlink" title="Base58"></a>Base58</h4><p>(少了0,o.l,I,+,&#x2F;)密文不断对58取模（得商和模），直到商为零（辗转相除），模逆向存入</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install base58</span></span><br><span class="line"><span class="keyword">import</span> base58</span><br><span class="line">enflag = <span class="string">&quot;2NEpo7TZRRrLZSi2U&quot;</span></span><br><span class="line"><span class="built_in">print</span>(base58.b58decode(enflag))</span><br></pre></td></tr></table></figure><h3 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h3><p>流加密，密钥长度变，加解密使用相同密钥，<strong>属于对称加密</strong>，<strong>有线等效加密</strong>（WEP）中使用得加密算法，</p><h5 id="S盒初始化"><a href="#S盒初始化" class="headerlink" title="S盒初始化"></a>S盒初始化</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">S[i]:=i <span class="comment">#?</span></span><br><span class="line">endfor</span><br><span class="line"></span><br><span class="line">j:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">j:=(j+S[i]+KEY[i mod key_len]) mod <span class="number">256</span>  <span class="comment">#256次for循环 #根据密钥打乱S盒</span></span><br><span class="line">    swap(S[i],S[j])</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h5 id="密钥流生成"><a href="#密钥流生成" class="headerlink" title="密钥流生成"></a>密钥流生成</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> GeneratingOutput</span><br><span class="line">i := (i + <span class="number">1</span>) mod <span class="number">256</span></span><br><span class="line">j := (j + S[i]) mod <span class="number">256</span></span><br><span class="line">swap(S[i], S[j])</span><br><span class="line">send(S[S[i]+S[j]mod <span class="number">256</span>]) to stream</span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure><h5 id="流加密"><a href="#流加密" class="headerlink" title="流加密"></a>流加密</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to plain_len  <span class="comment">#便利输入明文的每个字节，从s盒中去一个字节与之亦或，完成加密</span></span><br><span class="line">plain[i]^=stream[i]</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&quot;hello world&quot;</span></span><br><span class="line">cipher = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;A0 E2 BA F4 B5 02 ED 9B 41 2F E6 23&quot;</span>)</span><br><span class="line">rc4 = ARC4.new(key)</span><br><span class="line">plain = rc4.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span>(plain)</span><br></pre></td></tr></table></figure><p>特点：<br>前期准备很多很长</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>一般有两种形式的调用，一种是直接封装成一个函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8_t digest[<span class="number">16</span>];</span><br><span class="line">uint8_t <span class="built_in">input</span>[] = <span class="string">&quot;xxxxxxx&quot;</span>;</span><br><span class="line">MD5_hash(<span class="built_in">input</span>, sizeof(<span class="built_in">input</span>) - <span class="number">1</span>, digest);</span><br></pre></td></tr></table></figure><p>另一种是分三步完成哈希：</p><p>openssl</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MD5_CTX ctx;</span><br><span class="line">uint8_t digest[<span class="number">16</span>];</span><br><span class="line">uint8_t <span class="built_in">input</span>[] = <span class="string">&quot;xxxxxxx&quot;</span>;</span><br><span class="line">MD5_Init(&amp;ctx);</span><br><span class="line">MD5_Update(&amp;ctx, <span class="built_in">input</span>, sizeof(<span class="built_in">input</span>) - <span class="number">1</span>);</span><br><span class="line">MD5_Final(&amp;ctx, digest);</span><br></pre></td></tr></table></figure><p>在函数实现中，可以在靠近开头的位置看到几个特殊的常量</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0x67452301</span>;</span><br><span class="line">B = <span class="number">0xEFCDAB89</span>;</span><br><span class="line">C = <span class="number">0x98BADCFE</span>;</span><br><span class="line">D = <span class="number">0X10325476</span>;</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><p><strong>四个</strong>固定的常量（初始化向量）</p></li><li><p>不论输入是多长，输出永远是 <strong>16</strong> 字节</p></li><li><p>符合上述两种调用方式之一</p></li></ul><p><strong>逆向方式：</strong></p><ul><li><p>脚本爆破</p></li><li><p>查询网站：</p><ul><li>cmd5</li><li>[somd5][<a href="https://www.somd5.com/]">https://www.somd5.com/]</a></li></ul></li><li><p>hashcat 使用</p></li></ul><h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h4><p>五个常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H0 = 0x67452301</span><br><span class="line">H1 = 0xEFCDAB89</span><br><span class="line">H2 = 0x98BADCFE</span><br><span class="line">H3 = 0x10325476</span><br><span class="line">H4 = 0xC3D2E1F0</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><strong>五个</strong>固定的常量（初始化向量）</li><li>不论输入是多长，输出永远是 <strong>20</strong> 字节</li><li>符合上述两种调用方式之一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">target = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;ee 93 50 b8 86 a1 ba be c0 26 39 e4 7f 8b d2 a2 c1 22 3e a7&quot;</span>)</span><br><span class="line">charset = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(charset.repeat=<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> hashlib.sha1(<span class="built_in">bytes</span>(i)).digest()==tarfet:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">bytes</span>(i))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="sha-224-28个字节"><a href="#sha-224-28个字节" class="headerlink" title="sha_224 28个字节"></a>sha_224 28个字节</h4><h4 id="SHA-256"><a href="#SHA-256" class="headerlink" title="SHA-256"></a>SHA-256</h4><p>256&#x2F;8&#x3D;32</p><p>八个常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H0 = 0x6a09e667</span><br><span class="line">H1 = 0xbb67ae85</span><br><span class="line">H2 = 0x3c6ef372</span><br><span class="line">H3 = 0xa54ff53a</span><br><span class="line">H4 = 0x510e527f</span><br><span class="line">H5 = 0x9b05688c</span><br><span class="line">H6 = 0x1f83d9ab</span><br><span class="line">H7 = 0x5be0cd19</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><p>八个固定的常量（初始化向量）</p></li><li><p>不论输入是多长，输出永远是 <strong>32</strong> 字节</p></li><li><p>符合上述两种调用方式之一</p></li></ul><h3 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h3><p>[0x9e3779B9和0x61c88647]</p><p>识别特征：</p><p>标准 DELTA 常数（魔数）</p><p>密钥为 16 字节（4 个 DWORD）</p><p>加密轮数为 16&#x2F;32&#x2F;64 轮</p><p>加密结构中存在左 4 右 5 移位及异或运算</p><p>加密结构中存在轮加&#x2F;减相同常数的语句</p><p>对抗方式：</p><p>修改魔数</p><p>修改轮数</p><p>修改轮加&#x2F;减魔数的位置</p><h4 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h4><p>识别特征：</p><p>同 TEA</p><p>加密结构中存在右移 11 位并 &amp; 3 的运算</p><h4 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a><strong>XXTEA</strong></h4><p>XXTEA 是 XTEA 的升级版，其实现过程比前两种算法要略显复杂些，加密的明文数据可以不再是</p><p>64bit（两个 32 位无符号整数），并且其加密轮数是由 n，即待加密数据个数决定的。</p><p>识别特征基本同 TEA，但是加密轮数通过计算求得（6 + 52&#x2F;n）</p><h2 id="分组加密算法"><a href="#分组加密算法" class="headerlink" title="分组加密算法"></a>分组加密算法</h2><h3 id="常见工作模式"><a href="#常见工作模式" class="headerlink" title="常见工作模式"></a>常见工作模式</h3><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171156586.png" alt="image-20231112171156586"></p><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171208459.png" alt="image-20231112171208459"></p><h3 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171319806.png" alt="image-20231112171319806"></p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171443392.png" alt="image-20231112171443392"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171507346.png" alt="image-20231112171507346"></p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171515871.png" alt="image-20231112171515871"></h3><p>S：637c77 </p><p>16-10</p><p>24-12</p><p>32-14</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Base加密&quot;&gt;&lt;a href=&quot;#Base加密&quot; class=&quot;headerlink&quot; title=&quot;Base加密&quot;&gt;&lt;/a&gt;Base加密&lt;/h3&gt;&lt;h4 id=&quot;Hex-base16&quot;&gt;&lt;a href=&quot;#Hex-base16&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="密码 特征" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E5%AF%86%E7%A0%81-%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/06/25/Misc%EF%BC%9AMiscMasc%EF%BC%81/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/06/25/Misc%EF%BC%9AMiscMasc%EF%BC%81/</id>
    <published>2023-06-24T16:28:47.159Z</published>
    <updated>2023-07-05T14:29:52.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Misc：MiscMasc！"><a href="#Misc：MiscMasc！" class="headerlink" title="Misc：MiscMasc！"></a>Misc：MiscMasc！</h1><h2 id="适合作为桌面"><a href="#适合作为桌面" class="headerlink" title="适合作为桌面"></a>适合作为桌面</h2><p><a href="http://t.csdn.cn/XsnrR">http://t.csdn.cn/XsnrR</a></p><p>题解</p><pre><code>单纯从图片观察，未发现线索；右键使用记事本打开，依然未发现 flag 字样；考虑图片隐写，启动 Stegsolve ，加载图片；直接切换图片，在 red plane 1 中，可以看到，图片左上角出现了一个二维码。（图片隐写大概率可能还会涉及到数据提取，这道题比较基础，所以直接切换就可以看到）识别该二维码，在线条码解析，记得选择二维码，然后 read 读取；扫描结果是一串十六进制的数字；启动 winhex 进行解码，选择 AscII Hex虽然解析出来是乱码，但是根据这些关键字可以推断出，这应该是一个 python 被编译之后的 pyc 文件将其保存为 pyc 文件启动 easy python decompiler 对其进行反编译反编译会在 pyc 文件所在目录下生成这个文件将其后缀改为 py 使用 vscode 打开，发现实际上是一个名为 flag 的 python 方法，但并无调用语句，于是自己加上一行代码，调用这个方法找到 flag</code></pre><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>拿题目</p><p>首先还是分析题目，看看从题目中能发现什么蛛丝马迹。这是一道“13掌”打架题。先下载附加看看。</p><p> 与佛论禅</p><p>附件里面是一段看不懂的文字，但是正常的应该能看出这应该是一段佛文。</p><p>立马想到【与佛论禅】</p><p>复制解密一下：注意格式一定要加上：【佛曰：】进行解密，得到密文：{MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9}</p><p>十三掌解密</p><p>上面的第一步解密完成，但是输入进去是一个错误的flag，继续分析题干。题干上有一个比较明显的提示：【如来十三掌】。</p><p>必须很快的想到要进行rot13解码：解码得到{ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9}</p><p>输入依然不是正确的flag。</p><p>Base64解密</p><p>从13掌中得到的密文后，我们再进行一个Base64解密得到最终flag。flag{bdscjhbkzmnfrdhbvckijndskvbkjdsab}<br>————————————————<br>版权声明：本文为CSDN博主「Jum朱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_22903531/article/details/117768461">https://blog.csdn.net/qq_22903531/article/details/117768461</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Misc：MiscMasc！&quot;&gt;&lt;a href=&quot;#Misc：MiscMasc！&quot; class=&quot;headerlink&quot; title=&quot;Misc：MiscMasc！&quot;&gt;&lt;/a&gt;Misc：MiscMasc！&lt;/h1&gt;&lt;h2 id=&quot;适合作为桌面&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/06/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/06/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89/</id>
    <published>2023-06-21T14:12:23.277Z</published>
    <updated>2023-07-24T13:37:04.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言（王爽）"><a href="#汇编语言（王爽）" class="headerlink" title="汇编语言（王爽）"></a>汇编语言（王爽）</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>机器语言与机器指令 ：（eg）1000100111011000</p><p>汇编语言的主体是汇编指令</p><h4 id="CPU对存储器的读写："><a href="#CPU对存储器的读写：" class="headerlink" title="CPU对存储器的读写："></a>CPU对存储器的读写：</h4><ul><li>CPU想要进行数据的读写，必须和外部器件进行三类信息的交互：<ul><li>存储单元的地址（地址信息）</li><li>期间的选择、读或写命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul></li></ul><p> 将各类存储器看作一个逻辑存储器——统一编址</p><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><ul><li><p>主存储器地址空间</p><ul><li>RAM主存储器</li><li>ROM装有系统BIOS（来自最后一点）</li><li>RAM主存储器</li></ul></li><li><p>显存地址空间</p><ul><li>RAM显存</li></ul></li><li><p>显卡BIOS ROM地址空间</p><ul><li>ROM装有显卡BIOS</li></ul></li><li><p>网卡BIOS ROM地址空间</p><ul><li>ROM装有网卡BIOS</li></ul></li><li><p>系统BIOS ROM地址空间</p></li></ul><p>物理地址&#x3D;短地址*16+偏移地址</p><p>内存没有分段，段的划分来自于CPU </p><h2 id="汇编语言程序"><a href="#汇编语言程序" class="headerlink" title="汇编语言程序"></a>汇编语言程序</h2><h2 id="内存寻址方式"><a href="#内存寻址方式" class="headerlink" title="内存寻址方式"></a>内存寻址方式</h2><h2 id="流程转移与子程序"><a href="#流程转移与子程序" class="headerlink" title="流程转移与子程序"></a>流程转移与子程序</h2><h2 id="中断及其应用"><a href="#中断及其应用" class="headerlink" title="中断及其应用"></a>中断及其应用</h2><h2 id="高级汇编语言技术"><a href="#高级汇编语言技术" class="headerlink" title="高级汇编语言技术"></a>高级汇编语言技术</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编语言（王爽）&quot;&gt;&lt;a href=&quot;#汇编语言（王爽）&quot; class=&quot;headerlink&quot; title=&quot;汇编语言（王爽）&quot;&gt;&lt;/a&gt;汇编语言（王爽）&lt;/h1&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>程序设计综合实践练习</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/04/13/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/04/13/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0/</id>
    <published>2023-04-12T16:00:00.000Z</published>
    <updated>2023-04-15T08:56:13.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序设计综合实践练习"><a href="#程序设计综合实践练习" class="headerlink" title="程序设计综合实践练习"></a>程序设计综合实践练习</h1><p>[TOC]</p><h2 id="一，基础算法1"><a href="#一，基础算法1" class="headerlink" title="一，基础算法1"></a>一，基础算法1</h2><h3 id="1249-士兵队列训练问题"><a href="#1249-士兵队列训练问题" class="headerlink" title="1249: 士兵队列训练问题"></a>1249: 士兵队列训练问题</h3><p><strong>题目描述</strong></p><p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。</p><p><strong>输入</strong></p><p>​本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。</p><p><strong>输出</strong></p><p>​共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。</p><p><strong>样例输入</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">20</span><br><span class="line">40</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 7 19</span><br><span class="line">1 19 37</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解决</strong></p><p>tmp的vector不断更新，count根据奇偶性改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, count = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">soldiers</span>(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">soldiers[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (soldiers.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line"><span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; soldiers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(soldiers[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; soldiers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(soldiers[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">soldiers = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; soldiers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; soldiers[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1198-斐波那契数列"><a href="#1198-斐波那契数列" class="headerlink" title="1198: 斐波那契数列"></a>1198: 斐波那契数列</h3><p><strong>题目描述</strong></p><p>斐波那契数列中, a0&#x3D;0, a1&#x3D;1, ,对于k &gt; 1,  ak &#x3D; ak-1 + ak-2 求出斐波那契数列的第n项。</p><p><strong>输入</strong></p><p>第一行输入一个整数T表示样例个数,对于每个样例,输入一个整数n表示需要求出第n项斐波那契数字。</p><p><strong>输出</strong></p><p><strong>对</strong>于每个样例,输出一个数字num表示第n项斐波那契数字。</p><p><strong>样例输入</strong>             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>n &lt;&#x3D; 60</p><p><strong>思路&amp;解答</strong></p><p>dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fib</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        fib[<span class="number">0</span>] = <span class="number">0</span>, fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; fib[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1544-数值问题-高精度加法"><a href="#1544-数值问题-高精度加法" class="headerlink" title="1544: [数值问题]高精度加法"></a>1544: [数值问题]高精度加法</h3><p><strong>题目描述</strong></p><p>​ 输入两个高精度正整数a和b（a，b的位数&lt;&#x3D;200），求这两个数的和 </p><p><strong>输入</strong></p><p>输入共两行，分别为a和b</p><p><strong>输出</strong></p><p>输出共一行，表示两个数的和。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1111111111111111111111111111111111</span><br><span class="line">9999999999999999999999999999999999</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111111110</span><br></pre></td></tr></table></figure><p><strong>思考&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">reverse</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">size</span>(), len2 = b.<span class="built_in">size</span>();</span><br><span class="line">    a = <span class="built_in">reverse</span>(a); b = <span class="built_in">reverse</span>(b);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1||j&lt;len2)&#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1) &#123;</span><br><span class="line">            sum += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; len2) &#123;</span><br><span class="line">            sum += b[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        sum %= <span class="number">10</span>;</span><br><span class="line">        res += (sum + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        res += carry + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverse</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(a,b) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1237-三角形个数"><a href="#1237-三角形个数" class="headerlink" title="1237: 三角形个数"></a>1237: 三角形个数</h3><p><strong>题目描述</strong></p><p>​ 小b有一个仅包含非负整数的数组a，她想知道有多少个三元组(i,j,k)，满足i&lt;j&lt;k且a[i],a[j],a[k]可能作为某个三角形的三条边的边长。 </p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个正整数n，表示数组a中元素个数；</span><br><span class="line">第二行n个非负整数，表示a中元素，以空格隔开；</span><br><span class="line">其中0＜n≤1000，a中任意元素a[i]满足0≤a[i]≤1000。</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个数，表示满足题意的三元组个数</span><br></pre></td></tr></table></figure><p><strong>样例输入</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>               </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>思考&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; n &amp;&amp; a[i] + a[j] &gt; a[k]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += k - j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1234-找零"><a href="#1234-找零" class="headerlink" title="1234: 找零"></a>1234: 找零</h3><p><strong>题目描述</strong></p><p>​假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？如果无法支付K元，则输出-1。  </p><p><strong>输入</strong></p><p>输入第一行为一个整数T，表示样例个数。<br> 对于每个样例，第一行输入一个整数N表示需要找零的钱数，第二行输入7个整数表示每个纸币拥有的数量，分别表示1,2,5,10,20,50,100纸币的个数。</p><p><strong>输出</strong></p><p>对于每个样例，输出一个数字表示最少找零个数，输出-1表示无法找开。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">107</span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">200</span><br><span class="line">1 1 1 1 1 0 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>数据保证贪心可解。</p><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### <span class="number">1199</span>: 汉诺塔      </span><br><span class="line"></span><br><span class="line">**题目描述**</span><br><span class="line"></span><br><span class="line">汉诺塔(又称河内塔)问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子,在一根柱子上从下往上按照大小顺序摞着<span class="number">64</span>片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定,在小圆盘上不能放大圆盘,在三根柱子之间一次只能移动一个圆盘。</span><br><span class="line"></span><br><span class="line">**输入**</span><br><span class="line"></span><br><span class="line">第一行包含一个整数T表示样例数。</span><br><span class="line"> 对于每个样例,输入一个n表示汉诺塔的级数。</span><br><span class="line"></span><br><span class="line">**输出**</span><br><span class="line"></span><br><span class="line">对于每个样例,输出一个整数表示最少需要移动的次数。</span><br><span class="line"></span><br><span class="line">**样例输入**           复制          </span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">**样例输出**          复制          </span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">**提示**</span><br><span class="line"></span><br><span class="line">n &lt;= <span class="number">40</span></span><br><span class="line"></span><br><span class="line">**思路&amp;解答**</span><br><span class="line"></span><br><span class="line">~~~C++</span><br></pre></td></tr></table></figure><h3 id="1219-绝对值排序"><a href="#1219-绝对值排序" class="headerlink" title="1219: 绝对值排序"></a>1219: 绝对值排序</h3><p><strong>题目描述</strong></p><p>输入n(n&lt;&#x3D;100)个整数，按照绝对值从大到小排序后输出。题目保证对于每一个测试实例，所有的数的绝对值都不相等。</p><p><strong>输入</strong></p><p>输入数据有多组，每组占一行，每行的第一个数字为n,接着是n个整数，n&#x3D;0表示输入数据的结束，不做处理。</p><p><strong>输出</strong></p><p>​对于每个测试实例，输出排序后的结果，两个数之间用一个空格隔开。每个测试实例占一行。</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 3 -4 2</span><br><span class="line">4 0 1 2 -3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-4 3 2</span><br><span class="line">-3 2 1 0</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ssort</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(b) &gt; <span class="built_in">abs</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">1010</span>];</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b,b+a,ssort);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二，基础算法2"><a href="#二，基础算法2" class="headerlink" title="二，基础算法2"></a>二，基础算法2</h2><h3 id="1110-最多水容器"><a href="#1110-最多水容器" class="headerlink" title="1110: 最多水容器"></a>1110: 最多水容器</h3><p><strong>题目描述</strong></p><p>给定一个数组, 每个数值代表柱子的高度, 那么求出这些柱子最多可以装多少水. 水的体积由较短的长度乘以两个柱子的距离.<br><img src="https://justyy.com/wp-content/uploads/2018/07/container-with-most-water-leetcode-puzzle-coding-exercise.jpg" alt="container-with-most-water-leetcode-puzzle-coding-exercise C++ 编程练习题 - 最多水容器 (递归) ACM题解 程序设计 " style="zoom:50%;" /></p><p><strong>输入</strong></p><p>第一行输入一个数字N表示容器个数。第二行输入N个使用空格间隔的整数，表示容器高度。 </p><p><strong>输出</strong></p><p>输出一个数字表示最多装水量。</p><p><strong>样例输入</strong>                     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1 8 6 2 5 4 8 3 7</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>2 &lt;&#x3D; N &lt;&#x3D; 10</p><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];<span class="comment">//放外面不需要赋零</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j+<span class="number">1</span>; k &lt; m; k++) &#123;</span><br><span class="line"><span class="type">int</span> tmp = (<span class="built_in">min</span>(a[j], a[k]) * (k - j));</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; sum)sum = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1197-区间和统计"><a href="#1197-区间和统计" class="headerlink" title="1197: 区间和统计"></a>1197: 区间和统计</h3><p><strong>题目描述</strong></p><p>给定一个包含n个元素的数组,数组中元素ai保证 -1000 &lt; ai &lt; 1000。在数组中,从l到r(l &lt;&#x3D; r)的所有数叫做数组的一个[l, r]子区间,你需要求出,所有子区间中,和为k的区间一共有多少个。</p><p><strong>输入</strong></p><p>第一行包含一个整数T表示样例个数。<br> 对于每一个样例,第一行输入两个数字,n, p其中n表示数组的长度, p代表区间和。<br> 第二行包含n个数字表示数组的元素。</p><p><strong>输出</strong></p><p>对于每一个样例,输出一个数字表示和为p的子区间个数。</p><p><strong>样例输入</strong>                     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 8</span><br><span class="line">4 4 4 4 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>所有的ai均为整数。<br> 保证 n &lt;&#x3D; 1000</p><p><strong>思路&amp;解答</strong></p><p><strong>遍历数组，计算前缀和</strong></p><p>用哈希表记录前缀和出现的次数，对于i，如果前缀和prefix_sum[i]-p在哈希表中已经出现过了，说明从上一个出现该前缀和的位置到当前位置的子数组和为p，将这些子数组的数量累加到res中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],prefix_sum[<span class="number">1010</span>];<span class="comment">//放外面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, p;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">//哈希表记录前缀和出现的次数</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            prefix_sum[i + <span class="number">1</span>] = prefix_sum[i] + a[i];</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(prefix_sum[i + <span class="number">1</span>] - p)) &#123; </span><br><span class="line">                res += mp[prefix_sum[i + <span class="number">1</span>] - p]; </span><br><span class="line"><span class="comment">//将上一个出现该前缀和的位置到当前位置的子数组和为p的数量累加到结果中 &#125;</span></span><br><span class="line">            mp[prefix_sum[i + <span class="number">1</span>]]++; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1125-子矩阵求和"><a href="#1125-子矩阵求和" class="headerlink" title="1125:子矩阵求和"></a>1125:子矩阵求和</h3><p><strong>思路&amp;解答</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> M, N, Q;</span><br><span class="line">cin &gt;&gt; M &gt;&gt; N &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; Q; k++) &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num1, num2, num3, num4;</span><br><span class="line">cin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3 &gt;&gt; num4;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i1 = <span class="built_in">min</span>(num1, num3); i1 &lt;= <span class="built_in">max</span>(num1, num3); i1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j1 = <span class="built_in">min</span>(num2, num4); j1 &lt;= <span class="built_in">max</span>(num2, num4); j1++)</span><br><span class="line">sum += a[i1][j1];<span class="comment">//最大值最小值转化为标准型去计算</span></span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1126-选择排序"><a href="#1126-选择排序" class="headerlink" title="1126: 选择排序"></a>1126: 选择排序</h3><p><strong>题目描述</strong></p><p>给你一个序列，按照从小到大的顺序重新排列，要求使用选择排序</p><p><strong>输入</strong></p><p>​第一行是一个正整数m，代表测试样例的个数<br>     对于每组测试样例，输入一行数字，第一个数字m，代表这组样例中数字的个数，接下来的m个数字代表所给序列 </p><p><strong>输出</strong></p><p>对于每组输出样例，输出一行，输出按照从小到大顺序排列的结果</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2 1</span><br><span class="line">5</span><br><span class="line">9 5 1 4 3</span><br><span class="line">6</span><br><span class="line">2 3 8 1 5 6</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3 4 5 9</span><br><span class="line">1 2 3 5 6 8</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[min_idx]);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="type">int</span> arr[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">selectionSort</span>(arr, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1257-前m大的数"><a href="#1257-前m大的数" class="headerlink" title="1257: 前m大的数"></a>1257: 前m大的数</h3><p><strong>题目描述</strong></p><p>还记得Gardon给小希布置的那个作业么？其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。<br>     给定一个包含N(N&lt;&#x3D;3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)&#x2F;2个和，求出其中前M大的数(M&lt;&#x3D;1000)并按从大到小的顺序排列。 </p><p><strong>输入</strong></p><p>输入可能包含多组数据，其中每组数据包括两行：<br> 第一行两个数N和M，<br> 第二行N个数，表示该序列。 </p><p><strong>输出</strong></p><p>对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 3 4</span><br><span class="line">4 5</span><br><span class="line">5 3 6 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 6 5 5</span><br><span class="line">11 10 9 9 8</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3010</span>]; <span class="type">int</span> b[<span class="number">5000000</span>];<span class="comment">//注意开对数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; a;<span class="comment">//从大到小是&lt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> uu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; m; k++) &#123;</span><br><span class="line">b[uu] = a[j] + a[k];</span><br><span class="line">uu++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b, b + m*(m<span class="number">-1</span>)/<span class="number">2</span>, tmp);<span class="comment">//先出结果再排序，放心，够用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">cout &lt;&lt; b[u] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1238-Greed"><a href="#1238-Greed" class="headerlink" title="1238: Greed"></a>1238: Greed</h3><p><strong>题目描述</strong></p><p>​Jafar has <em>n</em> cans of cola. Each can is described by two integers: remaining volume of cola <em>ai</em> and can’s capacity <em>bi</em> (<em>ai</em> ≤  <em>bi</em>). </p><p>​Jafar has decided to pour all remaining cola into just 2 cans, determine if he can do this or not! </p><p> Jafar has n cans of cola. Each can is described by two integers: remaining volume of cola ai and can’s capacity bi (ai  ≤    ≤  bi). Jafar has decided to pour all remaining cola into just 2 cans, determine if he can do this or not! </p><p> 贾法尔有n罐可乐。每个罐由两个整数描述：可乐的剩余体积ai和罐的容量bi（ai ≤    ≤ bi）。 贾法尔决定把所有剩下的可乐倒进两个罐子里，看看他能不能做到！ </p><p><strong>输入</strong></p><p>​The first line of the input contains one integer <em>n</em> (2 ≤ <em>n</em> ≤ 100 000) — number of cola cans. </p><p>​The second line contains <em>n</em> space-separated integers <em>a, *a, …, *an</em>* (0 ≤ *ai*) — volume of remaining cola in cans.<br>*</p><p>​The third line contains <em>n</em> space-separated integers that <em>b, *b, …, *bn</em>* (*ai** ≤ <em>bi</em>) — capacities of the cans. </p><p>输入的第一行包含一个整数n（2 ≤（2 ≤ n ≤ 100 000）-可乐罐的数量。 第二行包含n个空格分隔的整数a，a，… an（0 ≤ ai）-罐中剩余可乐的体积。 第三行包含n个空格分隔的整数，B，…，B，…bn（ai彡bi）-罐的容量。 </p><p><strong>输出</strong></p><p>​Print “YES” (without quotes) if it is possible to pour all remaining cola in 2 cans. Otherwise print “NO” (without quotes). </p><p>​You can print each letter in any case (upper or lower). </p><p>如果可以将剩余的可乐倒入2罐，请打印“YES”（不带引号）。否则打印“NO”（不带引号）。 您可以在任何情况下打印每个字母（上部或下部）。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><p><strong>思路解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">int</span> cans[<span class="number">1009</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//vecctor存储每个罐子信息</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cans</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; cans[i].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; cans[i].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(cans.<span class="built_in">begin</span>(), cans.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> total_vol = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    total_vol += cans[i].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_vol &lt;= cans[<span class="number">0</span>].second + cans[<span class="number">1</span>].second) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1239-珠心算测验"><a href="#1239-珠心算测验" class="headerlink" title="1239: 珠心算测验"></a>1239: 珠心算测验</h3><p><strong>题目描述</strong></p><p>​珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。 </p><p>​某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？ </p><p>​最近老师出了一些测验题，请你帮忙求出答案。 </p><p>​</p><p><strong>输入</strong></p><p>共两行，第一行包含一个整数n<em>n</em>，表示测试题中给出的正整数个数。 第二行有n<em>n</em>个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。 </p><p><strong>输出</strong></p><p>一个整数，表示测验题答案。</p><p><strong>样例输入</strong>                    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>由1+2&#x3D;3,1+3&#x3D;41+2&#x3D;3,1+3&#x3D;4，故满足测试要求的答案为22。 注意，加数和被加数必须是集合中的两个不同的数。 </p><p> n &lt;&#x3D; 1000，集合中所有的数字保证小于等于1e7.</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> a[<span class="number">10000009</span>]; <span class="type">int</span> b[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">cin &gt;&gt; b[i]; a[b[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[b[i] + b[j]] == <span class="number">1</span>) &#123; ans++; a[b[i] + b[j]] = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1236-Monthly-Expense"><a href="#1236-Monthly-Expense" class="headerlink" title="1236: Monthly Expense"></a>1236: Monthly Expense</h3><p><strong>题目描述</strong></p><p>​给出n天中每天的花费，需要将这些天分成m组，每组包含连续的一或多天，若第i组的花费为Ki，求一种分组方法使得K&#x3D;max{Ki}最小。 </p><p><strong>输入</strong></p><p>​输入数据第一行为两个正整数N和M，之后输入N个正整数，分别表示第i天的费用。输出包含一行，表示上面描述的K。 </p><p><strong>输出</strong></p><p>对于每组数据，输出一个数表示最小的花费。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 5</span><br><span class="line">100</span><br><span class="line">400</span><br><span class="line">300</span><br><span class="line">100</span><br><span class="line">500</span><br><span class="line">101</span><br><span class="line">400</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>n &lt;&#x3D; 100. </p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], sum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum[i] - sum[pre] &gt; x) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            pre = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">            r += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，数据结构"><a href="#三，数据结构" class="headerlink" title="三，数据结构"></a>三，数据结构</h2><h3 id="1330-ip转换"><a href="#1330-ip转换" class="headerlink" title="1330: ip转换"></a>1330: ip转换</h3><p><strong>题目描述</strong></p><p>在进行基于ipv4协议的网络通讯时，用长度为32的信号表示ip地址。为了便于使用，通常会将32位信号转换为4个长度为8的信号。<br> 例如: 01111111000000000000000000000001会被转化为 127.0.0.1</p><p> 现在给出一系列ip地址的二进制表示，需要转化为它的对应十进制便于阅读的表示方式，即a.b.c.d形式。</p><p><strong>输入</strong></p><p>第一行包含一个整数T表示样例个数<br> 对于每个样例，输入一个长度为32的二进制串表示ip地址。 </p><p><strong>输出</strong></p><p>对于每个样例，输出一行字符串表示便于阅读的ip地址。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="function">bitset&lt;32&gt; <span class="title">bs</span><span class="params">(s)</span></span>; <span class="comment">// 将二进制串转换为位集</span></span><br><span class="line">        <span class="comment">// 通过位运算获取四个字节的值</span></span><br><span class="line">        <span class="type">int</span> a = (bs.<span class="built_in">to_ulong</span>() &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> b = (bs.<span class="built_in">to_ulong</span>() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> c = (bs.<span class="built_in">to_ulong</span>() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> d = bs.<span class="built_in">to_ulong</span>() &amp; <span class="number">0xFF</span>;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; d &lt;&lt; endl; <span class="comment">// 输出点分十进制表示的 IP 地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1337-进制转换"><a href="#1337-进制转换" class="headerlink" title="1337: 进制转换"></a>1337: 进制转换</h3><p><strong>题目描述</strong></p><p>输入一个十进制数N，将它转换成R进制数输出。</p><p><strong>输入</strong></p><p>输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;&#x3D;R&lt;&#x3D;16, R&lt;&gt;10）。</p><p><strong>输出</strong></p><p>为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> is_negative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        is_negative = <span class="literal">true</span>;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> digit = n % r;</span><br><span class="line">        <span class="keyword">if</span> (digit &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            result += <span class="built_in">to_string</span>(digit);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">&#x27;A&#x27;</span> + digit - <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n /= r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (is_negative) &#123;</span><br><span class="line">        result = <span class="string">&quot;-&quot;</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; r) &#123;</span><br><span class="line">        string result = <span class="built_in">convert</span>(n, r);</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1206-简单计算器"><a href="#1206-简单计算器" class="headerlink" title="1206: 简单计算器"></a>1206: 简单计算器</h3><p><strong>题目描述</strong></p><p>读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。 </p><p><strong>输入</strong></p><p>测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 </p><p><strong>输出</strong></p><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_priority</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span> || op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">do_operation</span><span class="params">(<span class="type">double</span> left, <span class="type">double</span> right, <span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left - right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left * right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluate_expression</span><span class="params">(<span class="type">const</span> string&amp; expr)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; num_stack;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; op_stack;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = expr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// Skip spaces</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; expr[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read a number</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[i])) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; (<span class="built_in">isdigit</span>(expr[j]) || expr[j] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> num = <span class="built_in">stod</span>(expr.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">            num_stack.<span class="built_in">push</span>(num);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Read an operator</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;+&#x27;</span> || expr[i] == <span class="string">&#x27;-&#x27;</span> || expr[i] == <span class="string">&#x27;*&#x27;</span> || expr[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">char</span> op = expr[i];</span><br><span class="line">            <span class="keyword">while</span> (!op_stack.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">get_priority</span>(op_stack.<span class="built_in">top</span>()) &gt;= <span class="built_in">get_priority</span>(op)) &#123;</span><br><span class="line">                <span class="type">double</span> right = num_stack.<span class="built_in">top</span>();</span><br><span class="line">                num_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">double</span> left = num_stack.<span class="built_in">top</span>();</span><br><span class="line">                num_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">char</span> prev_op = op_stack.<span class="built_in">top</span>();</span><br><span class="line">                op_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">double</span> result = <span class="built_in">do_operation</span>(left, right, prev_op);</span><br><span class="line">                num_stack.<span class="built_in">push</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">            op_stack.<span class="built_in">push</span>(op);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Skip other characters</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!op_stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">double</span> right = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">double</span> left = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">char</span> op = op_stack.<span class="built_in">top</span>();</span><br><span class="line">        op_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">do_operation</span>(left, right, op);</span><br><span class="line">        num_stack.<span class="built_in">push</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num_stack.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string expr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, expr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">evaluate_expression</span>(expr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1207-队列和栈"><a href="#1207-队列和栈" class="headerlink" title="1207: 队列和栈"></a>1207: 队列和栈</h3><p><strong>题目描述</strong></p><p>​ 队列和栈是两种重要的数据结构，它们具有push k和pop操作。push k是将数字k加入到队列或栈中，pop则是从队列和栈取一个数出来。队列和栈的区别在于取数的位置是不同的。</p><pre><code>  队列是先进先出的：把队列看成横向的一个通道，则push k是将k放到队列的最右边，而pop则是从队列的最左边取出一个数。    栈是后进先出的：把栈也看成横向的一个通道，则push k是将k放到栈的最右边，而pop也是从栈的最右边取出一个数。    假设队列和栈当前从左至右都含有1和2两个数，则执行push 5和pop操作示例图如下：         push 5     pop    队列 1 2 -------&gt; 1 2 5 ------&gt; 2 5         push 5     pop    栈  1 2 -------&gt; 1 2 5 ------&gt; 1 2   现在，假设队列和栈都是空的。给定一系列push k和pop操作之后，输出队列和栈中存的数字。若队列或栈已经空了，仍然接收到pop操作，则输出error。  </code></pre><p><strong>输入</strong></p><p>第一行为m，表示有m组测试输入，m&lt;100。<br> 每组第一行为n，表示下列有n行push k或pop操作。（n&lt;150）<br> 接下来n行，每行是push k或者pop，其中k是一个整数。<br>     （输入保证同时在队列或栈中的数不会超过100个） </p><p><strong>输出</strong></p><p>​对每组测试数据输出两行，正常情况下，第一行是队列中从左到右存的数字，第二行是栈中从左到右存的数字。若操作过程中队列或栈已空仍然收到pop，则输出error。输出应该共2*m行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            string op;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> k;</span><br><span class="line">                cin &gt;&gt; k;</span><br><span class="line">                q.<span class="built_in">push</span>(k);</span><br><span class="line">                s.<span class="built_in">push</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">empty</span>() || s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出队列中的数字</span></span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;error&quot;</span>&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出栈中的数字</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1325-报数"><a href="#1325-报数" class="headerlink" title="1325: 报数"></a>1325: 报数</h3><p><strong>题目描述</strong></p><p>今天一共n位同学参加了TIEI期末考试，大家计划在期末考试后在教室玩一个游戏，n个同学编号1-n后围成一圈报数，报到7的倍数的同学将被移出队伍，然后下一位同学继续现在的报数。当剩余人数少于7时结束游戏。<br> 请你输出剩余同学的原始编号。</p><p><strong>输入</strong></p><p>第一行包含一个整数T，表示样例个数。<br> 对于每个样例，包含一个单独的整数n表示同学的编号。</p><p><strong>输出</strong></p><p>对于每个样例，在一行输出剩余同学的编号，使用空格分隔。</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造循环链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">createCircleList</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = head; <span class="comment">// 将最后一个节点指向头节点，形成循环</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个节点，并返回下一个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">deleteKthNode</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 找到要删除的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除该节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">        prev-&gt;next = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        head = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cur);</span><br><span class="line">    <span class="comment">// 返回下一个节点</span></span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环报数并删除节点，直到剩余人数少于7</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countAndDelete</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> an[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        head = <span class="built_in">deleteKthNode</span>(head, <span class="number">7</span>);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出剩余同学的原始编号</span></span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            an[i] = cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(an, an + <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            cout &lt;&lt; an[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ListNode* head = <span class="built_in">createCircleList</span>(n);</span><br><span class="line">        <span class="built_in">countAndDelete</span>(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4442-二叉树遍历1"><a href="#4442-二叉树遍历1" class="headerlink" title="4442: 二叉树遍历1"></a>4442: 二叉树遍历1</h3><p><strong>题目描述</strong></p><p>​编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。<br> 例如如下的先序遍历字符串：<br> ABC##DE#G##F###<br> 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p><p><strong>输入</strong></p><p>​</p><p>​输入包括1行字符串，长度不超过100。</p><p>​</p><p><strong>输出</strong></p><p>​</p><p>​可能有多组测试数据，对于每组数据，<br> 输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。<br> 每个输出结果占一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树的节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">char</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归建立二叉树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(string s, <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= s.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s[i++]);</span><br><span class="line">    root-&gt;left = <span class="built_in">buildTree</span>(s, i);</span><br><span class="line">    root-&gt;right = <span class="built_in">buildTree</span>(s, i);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归中序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123; <span class="comment">// 循环读入多组测试数据</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        TreeNode* root = <span class="built_in">buildTree</span>(s, i); <span class="comment">// 建立二叉树</span></span><br><span class="line">        <span class="built_in">inorder</span>(root); <span class="comment">// 中序遍历二叉树并输出结果</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4440-复原二叉树"><a href="#4440-复原二叉树" class="headerlink" title="4440: 复原二叉树"></a>4440: 复原二叉树</h3><p><strong>题目描述</strong></p><p>小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。</p><p><strong>输入</strong></p><p>输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。</p><p><strong>输出</strong></p><p>对于每组输入，输出对应的二叉树的后续遍历结果。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DBACEGF ABCDEFG</span><br><span class="line">BCAD CBAD</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACBFGED</span><br><span class="line">CDAB</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">string pre, in, post;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> prel, <span class="type">int</span> inl, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">post += pre[prel];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> root = in.<span class="built_in">find</span>(pre[prel]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(prel + <span class="number">1</span>, inl, root - inl);</span><br><span class="line"><span class="built_in">dfs</span>(prel + root - inl + <span class="number">1</span>, root + <span class="number">1</span>, len - (root - inl) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">post += pre[prel];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">post = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> n = pre.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">cout &lt;&lt; post &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4441-合并果子（堆）"><a href="#4441-合并果子（堆）" class="headerlink" title="4441: 合并果子（堆）"></a>4441: 合并果子（堆）</h3><p><strong>题目描述</strong></p><p>​ 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。     每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。     因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。     例如有3种果子，数目依次为1，2，9。可以先将 1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为 12。所以多多总共耗费体力&#x3D;3+12&#x3D;15。可以证明15为最小的体力耗费值。   </p><p><strong>输入</strong></p><p>​ 输入文件fruit.in包括两行，第一行是一个整数n（1 &lt;&#x3D; n &lt;&#x3D; 30000），表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai（1 &lt;&#x3D; ai &lt;&#x3D; 20000）是第i种果子的数目。   </p><p><strong>输出</strong></p><p>​ 输出文件fruit.out包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于231。   </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 5 1 7 6 4 2 5 4 1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, ai;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>; <span class="comment">// 需要使用 long long 类型存储结果，避免溢出</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q; <span class="comment">// 小根堆</span></span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; ai;</span><br><span class="line">    q.<span class="built_in">push</span>(ai);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 只要堆中还有两个及以上的元素，就一直合并</span></span><br><span class="line">    <span class="type">int</span> a = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    ans += a + b;</span><br><span class="line">    q.<span class="built_in">push</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四，搜索算法"><a href="#四，搜索算法" class="headerlink" title="四，搜索算法"></a>四，搜索算法</h2><h3 id="1264-正方形"><a href="#1264-正方形" class="headerlink" title="1264: 正方形"></a>1264: 正方形</h3><p><strong>题目描述</strong></p><p>有n个木棒，需要用上所有木棒，围成一个正方形，如果可以围成正方形，则输出”yes”, 否则输出”no”。 </p><p><strong>输入</strong></p><p>第一行输入一个整数T表示样例个数。<br> 对于每个样例，第一行输入一个整数N表示木棍的个数，第二行输入N个数字表示木棒的长度。 </p><p><strong>输出</strong></p><p>对于每个样例，如果可以则输出”yes”, 否则输出”no”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> idx, <span class="type">int</span> sum, <span class="type">int</span>* visited, <span class="type">int</span> n, <span class="type">int</span> cnt, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(a, <span class="number">0</span>, target, visited, n, cnt + <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] || a[i] &gt; sum) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, i + <span class="number">1</span>, sum - a[i], visited, n, cnt, target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当已经找到三组数字之和等于目标和时，还需要判断最后一组是否符合要求</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">2</span> &amp;&amp; sum == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> visited[<span class="number">25</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(a, <span class="number">0</span>, sum / <span class="number">4</span>, visited, n, <span class="number">0</span>, sum / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">25</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(a, n)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1265-prime-circle"><a href="#1265-prime-circle" class="headerlink" title="1265: prime circle"></a>1265: prime circle</h3><p><strong>题目描述</strong></p><p>A ring is compose of n circles as shown in diagram. Put natural number 1, 2, …, n into each circle separately, and the sum of numbers in two  adjacent circles should be a prime.</p><p> Note: the number of first circle should always be 1.</p><p><strong>输入</strong></p><p>n (0 &lt; n &lt; 20).<br> (multi test case) </p><p><strong>输出</strong></p><p>The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and  anticlockwisely. The order of numbers must satisfy the above  requirements. Print solutions in lexicographical order.</p><p> You are to write a program that completes above process.</p><p> Print a blank line after each case.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目描述</span><br><span class="line">A ring is compose of n circles as shown in diagram. Put natural number <span class="number">1</span>, <span class="number">2</span>, ..., n into each circle separately, <span class="keyword">and</span> the sum of numbers in two adjacent circles should be a prime.</span><br><span class="line"></span><br><span class="line">Note: the number of first circle should always be <span class="number">1.</span></span><br><span class="line">输入</span><br><span class="line"><span class="built_in">n</span> (<span class="number">0</span> &lt; n &lt; <span class="number">20</span>).</span><br><span class="line">(multi test <span class="keyword">case</span>)</span><br><span class="line">输出</span><br><span class="line">The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from <span class="number">1</span> clockwisely <span class="keyword">and</span> anticlockwisely. The order of numbers must satisfy the above requirements. Print solutions in lexicographical order.</span><br><span class="line"></span><br><span class="line">You are to write a program that completes above process.</span><br><span class="line"></span><br><span class="line">Print a blank line after each <span class="keyword">case</span>.</span><br><span class="line">样例输入 复制</span><br><span class="line"></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">样例输出 复制</span><br><span class="line"></span><br><span class="line">Case <span class="number">1</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Case <span class="number">2</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">8</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1266-棋盘问题"><a href="#1266-棋盘问题" class="headerlink" title="1266: 棋盘问题"></a>1266: 棋盘问题</h3><p><strong>题目描述</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><p><strong>输入</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;输入含有多组测试数据。 </p><p><strong>输出</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b &lt; other.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">char</span> a[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> last_b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].b &gt;= last_b) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = p[i].b;</span><br><span class="line">            p[i].b = last_b;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, tmp);</span><br><span class="line">            p[i].b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((cin &gt;&gt; m &gt;&gt; n)&amp;&amp;(m != <span class="number">-1</span>) &amp;&amp; (n != <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>,q=<span class="number">0</span>; j &lt; m; j++,q++) &#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == <span class="string">&#x27;#&#x27;</span>)p[q].a = i, p[q].b = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(p, p + m);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1268-迷宫问题-题目描述"><a href="#1268-迷宫问题-题目描述" class="headerlink" title="1268: 迷宫问题   题目描述"></a>1268: 迷宫问题   <strong>题目描述</strong></h3><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;定义一个二维数组： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int maze[5][5] = &#123;</span><br><span class="line"></span><br><span class="line">0, 1, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 1, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>输入</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;一个5 ×  5的二维数组，表示一个迷宫。数据保证有唯一解。</p><p><strong>输出</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;左上角到右下角的最短路径，格式如样例所示。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(0, 0)</span><br><span class="line">(1, 0)</span><br><span class="line">(2, 0)</span><br><span class="line">(2, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(2, 3)</span><br><span class="line">(2, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(4, 4)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> maze[MAXN][MAXN];</span><br><span class="line"><span class="type">bool</span> visited[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> pre[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125; &#125;; <span class="comment">// 上右下左</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in">sizeof</span>(visited));</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    Node start = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> x = cur.x, y = cur.y, step = cur.step;</span><br><span class="line">        <span class="keyword">if</span> (x == MAXN - <span class="number">1</span> &amp;&amp; y == MAXN - <span class="number">1</span>) &#123; <span class="comment">// 到达终点，结束搜索</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(0, 0)&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="type">int</span> pre_x = MAXN - <span class="number">1</span>, pre_y = MAXN - <span class="number">1</span>;</span><br><span class="line">            vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; path; <span class="comment">// 记录路径</span></span><br><span class="line">            <span class="keyword">while</span> (pre_x != <span class="number">0</span> || pre_y != <span class="number">0</span>) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(&#123; pre_x, pre_y &#125;);</span><br><span class="line">                <span class="type">int</span> tmp_x = pre_x, tmp_y = pre_y;</span><br><span class="line">                pre_x = pre[pre_x][pre_y][<span class="number">0</span>];</span><br><span class="line">                pre_y = pre[tmp_x][tmp_y][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; path[i].first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path[i].second &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> next_x = x + dir[i][<span class="number">0</span>], next_y = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= MAXN || next_y &lt; <span class="number">0</span> || next_y &gt;= MAXN) <span class="keyword">continue</span>; <span class="comment">// 越界</span></span><br><span class="line">            <span class="keyword">if</span> (maze[next_x][next_y] == <span class="number">1</span> || visited[next_x][next_y]) <span class="keyword">continue</span>; <span class="comment">// 墙或者已访问过</span></span><br><span class="line">            Node next_node = &#123; next_x, next_y, step + <span class="number">1</span> &#125;;</span><br><span class="line">            pre[next_x][next_y][<span class="number">0</span>] = x; <span class="comment">// 记录路径</span></span><br><span class="line">            pre[next_x][next_y][<span class="number">1</span>] = y;</span><br><span class="line">            q.<span class="built_in">push</span>(next_node);</span><br><span class="line">            visited[next_x][next_y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MAXN; j++) &#123;</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1270-Find-a-way"><a href="#1270-Find-a-way" class="headerlink" title="1270: Find a way"></a>1270: Find a way</h3><p><strong>题目描述</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;Pass a  year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally.  Leave Ningbo one year, yifenfei have many people to meet. Especially a  good friend Merceki. </p><p><strong>输入</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;The input contains multiple test cases. </p><p><strong>输出</strong></p><p>​&lt;span style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;For each  test case output the minimum total time that both yifenfei and Merceki  to arrival one of KFC.You may sure there is always have a KFC that can  let them meet. </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">Y.#@</span><br><span class="line">....</span><br><span class="line">.#..</span><br><span class="line">@..M</span><br><span class="line">4 4</span><br><span class="line">Y.#@</span><br><span class="line">....</span><br><span class="line">.#..</span><br><span class="line">@#.M</span><br><span class="line">5 5</span><br><span class="line">Y..@.</span><br><span class="line">.#...</span><br><span class="line">.#...</span><br><span class="line">@..M.</span><br><span class="line">#...#</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">66</span><br><span class="line">88</span><br><span class="line">66</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">int</span> tx, <span class="type">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx, sy, <span class="number">0</span>&#125;);</span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    dist[sx][sy] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b] || g[a][b] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            dist[a][b] = t.t + <span class="number">1</span>;</span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b, dist[a][b]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[tx][ty];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sy, sx, ty, tx, res = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;Y&#x27;</span>) sx = i, sy = j;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;M&#x27;</span>) tx = i, ty = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> d1 = <span class="built_in">bfs</span>(sx, sy, i, j);</span><br><span class="line">                    <span class="type">int</span> d2 = <span class="built_in">bfs</span>(tx, ty, i, j);</span><br><span class="line">                    res = <span class="built_in">min</span>(res, d1 + d2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res * <span class="number">11</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1282-马的遍历"><a href="#1282-马的遍历" class="headerlink" title="1282: 马的遍历"></a>1282: 马的遍历</h3><p><strong>题目描述</strong></p><p>有一个n*m的棋盘(1&lt;n,m&lt;&#x3D;400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步</p><p><strong>输入</strong></p><p>一行四个数据，棋盘的大小和马的坐标</p><p><strong>输出</strong></p><p>​一个n*m的矩阵，同一行元素之间用空格分离。代表马到达某个点最少要走几步。不能到达则输出-1。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3 1 1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 3 2</span><br><span class="line">3 -1 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">405</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m, sx, sy;</span><br><span class="line"><span class="type">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx, sy&#125;);</span><br><span class="line">    dis[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>().x, y = q.<span class="built_in">front</span>().y;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(nx, ny) &amp;&amp; dis[nx][ny] == INF) &#123;</span><br><span class="line">                dis[nx][ny] = dis[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dis[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i][j] == INF) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; dis[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1283-求细胞数量"><a href="#1283-求细胞数量" class="headerlink" title="1283: 求细胞数量"></a>1283: 求细胞数量</h3><p><strong>题目描述</strong></p><p>一矩形阵列由数字 0 到 9 组成，数字 1 到 9 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。</p><p><strong>输入</strong></p><p>第一行两个整数代表矩阵大小 n 和 m。 接下来 n 行，每行一个长度为 m 的只含字符 0 到 9 的字符串，代表这个n×m 的矩阵。 </p><p><strong>输出</strong></p><p>​一行一个整数代表细胞个数。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 10</span><br><span class="line">0234500067</span><br><span class="line">1034560500</span><br><span class="line">2045600671</span><br><span class="line">0000000089</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>; <span class="comment">// 最大矩阵大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;; <span class="comment">// 上下左右四个方向的坐标变化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> matrix[MAXN][MAXN]; <span class="comment">// 输入的矩阵</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN][MAXN]; <span class="comment">// 标记每个点是否访问过</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 细胞数量计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个点是否在矩阵内</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inMatrix</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n&amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS遍历整个细胞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; sx, sy &#125;);</span><br><span class="line">    vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> x = p.first, y = p.second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 四个方向搜索</span></span><br><span class="line">            <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inMatrix</span>(nx, ny) &amp;&amp; !vis[nx][ny] &amp;&amp; matrix[nx][ny] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; nx, ny &#125;);</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; matrix[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; !vis[i][j]) &#123; <span class="comment">// 如果是细胞且未访问过</span></span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j); <span class="comment">// BFS搜索整个细胞</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1284-01迷宫"><a href="#1284-01迷宫" class="headerlink" title="1284: 01迷宫"></a>1284: 01迷宫</h3><p><strong>题目描述</strong></p><p>有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 </p><p><strong>输入</strong></p><p>第1行为两个正整数n,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。<br> 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 </p><p><strong>输出</strong></p><p>​m行，对于每个询问输出相应答案。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>n &lt;&#x3D; 400</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> maze[MAXN][MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;  <span class="comment">// 上右下左</span></span><br><span class="line"><span class="type">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; sx, sy &#125;);</span><br><span class="line">    vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> x = p.first, y = p.second;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (maze[x][y] != maze[nx][ny]) &#123;</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; nx, ny &#125;);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        x--; y--;  <span class="comment">// 转换成从0开始编号的坐标</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">bfs</span>(x, y) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));  <span class="comment">// 注意清空标记数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五，图论"><a href="#五，图论" class="headerlink" title="五，图论"></a>五，图论</h2><h3 id="4444-dfs"><a href="#4444-dfs" class="headerlink" title="4444: dfs"></a>4444: dfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];  <span class="comment">// 存储图</span></span><br><span class="line"><span class="type">bool</span> vis[N];       <span class="comment">// 标记是否已经访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 输出当前节点编号</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;     <span class="comment">// 标记已经访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;  <span class="comment">// 如果节点v还没有被访问</span></span><br><span class="line">            <span class="built_in">dfs</span>(v);      <span class="comment">// 继续访问节点v</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);  <span class="comment">// 添加无向边</span></span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);  <span class="comment">// 从节点1开始遍历</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4445-bfs"><a href="#4445-bfs" class="headerlink" title="4445: bfs"></a>4445: bfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);  <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1298-蜜罐"><a href="#1298-蜜罐" class="headerlink" title="1298: 蜜罐"></a>1298: 蜜罐</h3><p><strong>题目描述</strong></p><p>​蜜蜂乔治在采蜂蜜的时候，会把蜜放进N个蜜罐中，现在需要把这N个不相邻的蜜罐构建一些双向边把它们连接起来。即有N个分立的点，同时给出M个不同的边，需要你求出这张图的最小生成树。或许你会觉得这种描述有些奇怪，不过使用如此描述完全由于出题人喜欢吃蜂蜜。 </p><p><strong>输入</strong></p><p>​第一行输入一个T，表示样例个数。<br>     对于每一个样例，第二行输入N, M，表示蜜罐数与边的数量。<br>     第三行输入三个数字 s, t, w表示双向边的两个端点和权重。 </p><p><strong>输出</strong></p><p>​对于每个样例，输出一个数字res表示生成树的权重。如果无法构成生成树，则输出-1. </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3  3</span><br><span class="line">1 2 3</span><br><span class="line">2 3 3</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>​1 &lt; N, M &lt; 2000<br>     w &lt; 10000</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, t, w;</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> v = G[u][i].first, w = G[u][i].second;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; w) &#123;</span><br><span class="line">                dis[v] = w;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v], v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans += dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;</span><br><span class="line">            G[s].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(t, w));</span><br><span class="line">            G[t].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(s, w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">prim</span>();</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1310-村村通"><a href="#1310-村村通" class="headerlink" title="1310: 村村通"></a>1310: 村村通</h3><p><strong>题目描述</strong></p><p>某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 “村村通工程” 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？</p><p><strong>输入</strong></p><p>​ 输入包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目n 和道路数目 m ；随后的 m 行对应 m 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 1 到 n 编号。<br>      注意：两个城市间可以有多条道路相通。 </p><p><strong>输出</strong></p><p>​ 对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent; <span class="comment">// 存储节点的父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123; <span class="comment">// 初始化</span></span><br><span class="line">        parent.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 查找节点所在集合的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// 合并两个集合</span></span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="comment">// 统计集合的数量</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; parent.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>; <span class="comment">// 初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            uf.<span class="built_in">merge</span>(u, v); <span class="comment">// 合并u和v所在的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; uf.<span class="built_in">count</span>() - <span class="number">1</span> &lt;&lt; endl; <span class="comment">// 输出最少需要的道路数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1297-一个人的旅行"><a href="#1297-一个人的旅行" class="headerlink" title="1297: 一个人的旅行"></a>1297: 一个人的旅行</h3><p><strong>题目描述</strong></p><p>​ 虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗<del>),但是草儿仍然很喜欢旅行，因为在旅途中  会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊</del>）。 </p><p><strong>输入</strong></p><p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br> 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1&#x3D;&lt;(a,b)&lt;&#x3D;1000;a,b 之间可能有多条路)<br> 接着的第T+1行有S个数，表示和草儿家相连的城市；<br> 接着的第T+2行有D个数，表示草儿想去地方。</p><p><strong>输出</strong></p><p>​输出草儿能去某个喜欢的城市的最短时间 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 2 3</span><br><span class="line">1 3 5</span><br><span class="line">1 4 7</span><br><span class="line">2 8 12</span><br><span class="line">3 8 4</span><br><span class="line">4 9 12</span><br><span class="line">9 10 2</span><br><span class="line">1 2</span><br><span class="line">8 9 10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w, nxt;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dist[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> s[MAXN], d[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, t, S, D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, INF, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;S, &amp;D) == <span class="number">3</span>) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            <span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">            <span class="built_in">addEdge</span>(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= D; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) &#123;</span><br><span class="line">            <span class="built_in">SPFA</span>(s[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= D; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[d[j]] &lt; ans) &#123;</span><br><span class="line">                    ans = dist[d[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1312-文化之旅"><a href="#1312-文化之旅" class="headerlink" title="1312: 文化之旅"></a>1312: 文化之旅</h3><p><strong>题目描述</strong></p><p>有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。<br> 现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。 </p><p><strong>输入</strong></p><p>每组输入数据的第一行为五个整数N，K，M，S，T，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为1到N），文化种数（文化编号为1到K），道路的条数，以及起点和终点的编号（保证S不等于T）；<br> 第二行为N个整数，每两个整数之间用一个空格隔开，其中第i个数Ci，表示国家i的文化为Ci。<br> 接下来的K行，每行K个整数，每两个整数之间用一个空格隔开，记第i行的第j个数为aij，aij&#x3D;1表示文化i排斥外来文化j（i等于j时表示排斥相同文化的外来人），aij&#x3D;0表示不排斥（注意i排斥j并不保证j 一定也排斥i）。<br> 接下来的M行，每行三个整数u，v，d，每两个整数之间用一个空格隔开，表示国家u与国家v有一条距离为d的可双向通行的道路（保证u不等于v，两个国家之间可能有多条道路）。 </p><p> 数据规模：<br> 对于20%的数据，有2≤N≤8，K≤5；<br> 对于30%的数据，有2≤N≤10，K≤5；<br> 对于50%的数据，有2≤N≤20，K≤8；<br> 对于100%的数据，有2≤N≤100，1≤K≤10，1≤M≤N2，1≤ki≤K，1≤u, v≤N，1≤d≤1000，S≠T，1≤S, T≤N。 </p><p><strong>输出</strong></p><p>每组输出只有一行，一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出-1）。 </p><p> 下面是对样例数据的解释：<br> 样例一：<br> 由于到国家2必须要经过国家1，而国家2的文明却排斥国家1的文明，所以不可能到达国家2。<br> 样例二：<br> 路线为1-&gt;2。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 2 1 1 2</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">1 2 10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>-———–<br> 2 2 1 1 2<br> 1 2<br> 0 1<br> 0 0<br> 1 2 10<br> -———-<br> 10 </p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, K = <span class="number">105</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, k, m, s, t;</span><br><span class="line"><span class="type">int</span> c[N], dist[N];      <span class="comment">//某个国家的文化，到某个国家的距离 </span></span><br><span class="line"><span class="type">int</span> a[K][K], e[N][N];   <span class="comment">//两国之间是否排斥，两国之间的距离 </span></span><br><span class="line"><span class="type">bool</span> h[K];              <span class="comment">//已经学过的文化 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//到国家x的距离是d </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= dist[x] || d &gt;= dist[t]) <span class="keyword">return</span>;</span><br><span class="line">    dist[x] = d;</span><br><span class="line">    <span class="keyword">if</span> (x == t) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;             <span class="comment">//i国 </span></span><br><span class="line">        <span class="keyword">if</span> (e[x][i] == INF) <span class="keyword">continue</span>;           <span class="comment">//x,i两国之间没有路</span></span><br><span class="line">        <span class="keyword">if</span> (h[c[i]]) <span class="keyword">continue</span>;                  <span class="comment">//已学过该国文化 </span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j ++) &#123;         <span class="comment">//j文化 </span></span><br><span class="line">            <span class="keyword">if</span> (h[j] &amp;&amp; a[c[i]][j] == <span class="number">1</span>) &#123;      <span class="comment">//学过j文化且i国的文化排斥j文化 </span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        h[c[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, d + e[x][i]);</span><br><span class="line">        h[c[i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;n, &amp;k, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;             </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);                     <span class="comment">//国家 i的文化为 Ci</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);              <span class="comment">//a[i][j] = 1 表示文化 i 排斥外来文化 j</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));           <span class="comment">//初始化 </span></span><br><span class="line">    <span class="built_in">memset</span>(e, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(e));                 </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;d);</span><br><span class="line">        e[u][v] = e[v][u] = <span class="built_in">min</span>(e[u][v], d);    <span class="comment">//邻接矩阵，去掉重复的边 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h[c[s]] = <span class="literal">true</span>;                             <span class="comment">//学习起点国家的文化  </span></span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[t] == <span class="number">0x3f3f3f3f</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[t]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1320-公交线路"><a href="#1320-公交线路" class="headerlink" title="1320: 公交线路"></a>1320: 公交线路</h3><p><strong>题目描述</strong></p><p>​P市有n个公交站，之间连接着m条道路。P市计划新开设一条公交线路，该线路从城市的东站（s点）修建到西站（t点），请为P市设计一条满足上述条件并且最短的公交线路图。  </p><p><strong>输入</strong></p><p>第一行有5个正整数n，m，s，t。</p><p> 接下来m行，每行3个数a,b,v描述一条无向道路a——b，长度为v。</p><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果有解，输出一行，表示满足条件的最短公交线路的长度c。</span><br><span class="line"></span><br><span class="line">否则，输出“-1”</span><br></pre></td></tr></table></figure><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 1 2</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>1 ≤ s,t ≤ n ≤ 1000<br> 1 ≤ m ≤ 10000<br> 1 ≤ 道路的长度 ≤ 10000</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, t; <span class="comment">// n: 点的数量，m: 边的数量，s: 起点，t: 终点</span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">105</span>]; <span class="comment">// dis[i] 表示从起点 s 到 i 的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">105</span>]; <span class="comment">// vis[i] 表示 i 是否已经访问过</span></span><br><span class="line"><span class="type">int</span> G[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">// G[i][j] 表示 i 到 j 的边的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="built_in">sizeof</span>(dis)); <span class="comment">// 初始化 dis 数组为 INF</span></span><br><span class="line">    dis[s] = <span class="number">0</span>; <span class="comment">// 起点 s 到自己的距离为 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">-1</span>, min_dis = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; min_dis) &#123;</span><br><span class="line">                    u = j;</span><br><span class="line">                    min_dis = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有点都已经访问过</span></span><br><span class="line">            vis[u] = <span class="literal">true</span>; <span class="comment">// 标记 u 已经访问过</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF &amp;&amp; dis[u] + G[u][v] &lt; dis[v]) &#123;</span><br><span class="line">                    dis[v] = dis[u] + G[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="built_in">memset</span>(G, INF, <span class="built_in">sizeof</span>(G)); <span class="comment">// 初始化 G 数组为 INF</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i][i] = <span class="number">0</span>; <span class="comment">// 自己到自己的距离为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u][v] = G[v][u] = w; <span class="comment">// 无向图，所以需要同时更新 G[u][v] 和 G[v][u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>(); <span class="comment">// 求解最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dis[t] != INF) cout &lt;&lt; dis[t] &lt;&lt; endl; <span class="comment">// 如果有解，输出最短距离</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 否则输出 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4443-弗洛伊德"><a href="#4443-弗洛伊德" class="headerlink" title="4443: 弗洛伊德"></a>4443: 弗洛伊德</h3><p><strong>题目描述</strong></p><p>​在带权有向图G中，求G中的任意一对顶点间的最短路径问题，也是十分常见的一种问题。 解决这个问题的一个方法是执行n次迪杰斯特拉算法，这样就可以求出每一对顶点间的最短路径，执行的时间复杂度为O(n3)。 而另一种算法是由弗洛伊德提出的，时间复杂度同样是O(n3)，但算法的形式简单很多。 </p><p>​在本题中，读入一个有向图的带权邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法求出每一对顶点间的最短路径长度。</p><p>​ </p><p><strong>输入</strong></p><p>输入的第一行包含1个正整数n，表示图中共有n个顶点。其中n不超过50。 以后的n行中每行有n个用空格隔开的整数。对于第i行的第j个整数，如果大于0，则表示第i个顶点有指向第j个顶点的有向边，且权值为对应的整数值；如果这个整数为0，则表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。</p><p><strong>输出</strong></p><p>共有n行，每行有n个整数，表示源点至每一个顶点的最短路径长度。如果不存在从源点至相应顶点的路径，输出-1。对于某个顶点到其本身的最短路径长度，输出0。 请在每个整数后输出一个空格，并请注意行尾输出换行。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 3 0 1</span><br><span class="line">0 0 4 0</span><br><span class="line">2 0 0 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 3 2 1 </span><br><span class="line">6 0 4 7 </span><br><span class="line">2 5 0 3 </span><br><span class="line">3 6 1 0 </span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>在本题中，需要按照题目描述中的算法完成弗洛伊德算法，并在计算最短路径的过程中将每个顶点是否可达记录下来，直到求出每一对顶点的最短路径之后，算法才能够结束。 相对于迪杰斯特拉算法，弗洛伊德算法的形式更为简单。通过一个三重循环，弗洛伊德算法可以方便的求出每一对顶点间的最短距离。 另外需要注意的是，为了更方便的表示顶点间的不可达状态，可以使用一个十分大的值作为标记。而在题目描述中的算法示例使用了另外一个三维数组对其进行表示，这使原本的O(n3)时间复杂度增长到了O(n4)，这也是需要自行修改的部分。</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> graph[MAXN][MAXN]; <span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph[i][k] != INF &amp;&amp; graph[k][j] != INF) &#123;</span><br><span class="line">graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="built_in">memset</span>(graph, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(graph));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="type">int</span> w;</span><br><span class="line">cin &gt;&gt; w;</span><br><span class="line"><span class="keyword">if</span> (w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">graph[i][j] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">graph[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行弗洛伊德算法</span></span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph[i][j] == INF) &#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; graph[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4446-奖学金-reward"><a href="#4446-奖学金-reward" class="headerlink" title="4446: 奖学金(reward)"></a>4446: 奖学金(reward)</h3><p><strong>题目描述</strong></p><p>期末考试终于完了，老班决定召开班委会，内容嘛，则是可爱的奖学金的问题（(<em>^__^</em>)），她叫来了一些班委，每位班委提出了自己的意见：“我认为同学a的奖学金应该比b多！”老班决定要找出一种奖学金方案，满足各位班委的意见，且同时使得总奖学金数最少。每位同学奖学金最少为100元且都为整数。</p><p><strong>输入</strong></p><p>​第一行两个整数n,m，表示同学总数和班委意见数；</p><p>以下m行，每行2个整数a,b，表示某个班委认为第a号同学奖学金应该比第b号同学高。</p><p><strong>输出</strong></p><p>若无法找到合法方案，则输出“impossible”(不含引号）；否则输出一个数表示最少总奖学金。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">201</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;<span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(),ch&lt;<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(x=<span class="number">10</span>*x+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>(),ch&gt;<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cat_max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">return</span> a&gt;b ? a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cat_min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">return</span> a&lt;b ? a:b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> mon; </span><br><span class="line">    <span class="built_in">node</span> ():<span class="built_in">num</span>(<span class="number">0</span>),<span class="built_in">mon</span>(<span class="number">100</span>)&#123;&#125;;  </span><br><span class="line">&#125;G[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next;</span><br><span class="line">&#125;g[<span class="number">20000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> head[maxn],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">g[++tot].to = v;</span><br><span class="line">g[tot].next = head[u];</span><br><span class="line">head[u] = tot; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> q[maxn],l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;reward.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;reward.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="type">int</span> n,m;<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;<span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a),<span class="built_in">read</span>(b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        G[a].num++;<span class="comment">//纪录每一个点的入度 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i].num == <span class="number">0</span>)&#123;</span><br><span class="line">            q[r] = i;</span><br><span class="line"> ++r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        tmp = q[l];++l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[tmp]; i ; i = g[i].next)&#123;</span><br><span class="line">            G[g[i].to].num--;</span><br><span class="line">            <span class="keyword">if</span>(G[g[i].to].mon &lt;= G[tmp].mon)</span><br><span class="line">               G[g[i].to].mon = G[tmp].mon + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(G[g[i].to].num == <span class="number">0</span>)&#123;<span class="comment">//入度为零则不可能再一次被更新了 </span></span><br><span class="line">                q[r] = g[i].to ; ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i].num != <span class="number">0</span>)&#123;</span><br><span class="line">           flag = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">break</span>;<span class="comment">//判环 </span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt += G[i].mon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt);</span><br><span class="line">    <span class="built_in">fclose</span>(stdin);<span class="built_in">fclose</span>(stdout);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="六，动态规划"><a href="#六，动态规划" class="headerlink" title="六，动态规划"></a>六，动态规划</h2><h3 id="4447-冬冬爬楼梯"><a href="#4447-冬冬爬楼梯" class="headerlink" title="4447: 冬冬爬楼梯"></a>4447: 冬冬爬楼梯</h3><p><strong>题目描述</strong></p><p>冬冬爬楼梯，一步可以1级，也可以爬2级、3级。冬冬很可爱，每到一处楼梯处，他都想知道直完这个楼梯有多少种走法。但由于有的时候楼梯级数太多，可能是个天文数字，很显然，对于还处于小学5年级的冬冬是不太现实的。聪明的你，能帮冬冬实现这个愿望吗？</p><p><strong>输入</strong></p><p>多组测试数据，每组测试数据一行一个整数n (1&lt;&#x3D;n&lt;&#x3D;3000)</p><p><strong>输出</strong></p><p>对于每组测试数据，输出一个整数，为n级楼梯冬冬走完的方法数。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3005</span>;</span><br><span class="line">string dp[MAXN];</span><br><span class="line"><span class="function">string <span class="title">reverseStr</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[n - i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">size</span>(), len2 = b.<span class="built_in">size</span>();</span><br><span class="line">    a = <span class="built_in">reverseStr</span>(a); b = <span class="built_in">reverseStr</span>(b);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 || j &lt; len2) &#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1) &#123;</span><br><span class="line">            sum += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; len2) &#123;</span><br><span class="line">            sum += b[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        sum %= <span class="number">10</span>;</span><br><span class="line">        res += (sum + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; carry &lt;&lt; &quot; &quot; &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        res += (carry + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverseStr</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; add(&quot;13&quot;, &quot;11&quot;) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : dp) i = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="string">&quot;4&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">add</span>(dp[i - <span class="number">1</span>], <span class="built_in">add</span>(dp[i - <span class="number">2</span>], dp[i - <span class="number">3</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; dp[n - 1] &lt;&lt; &quot; &quot; &lt;&lt; dp[n - 2] &lt;&lt; &quot; &quot; &lt;&lt; dp[n - 3] &lt;&lt; endl;</span></span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4450-最大子段和"><a href="#4450-最大子段和" class="headerlink" title="4450: 最大子段和"></a>4450: 最大子段和</h3><p><strong>题目描述</strong></p><p>​输入若干个整数，有正有负，要求用动态规划算法计算最大子段和，并输出这个和。注意子段为一段连续的数，同时规定全是负数的子段其和为0。</p><p><strong>输入</strong></p><p>​第一行为一个整数M，代表有M组测试数据。<br> 随后每组测试数据的第一行为N，代表该组数据有N个数。(0&lt;n&lt;&#x3D;100000) &lt;br&#x3D;””&gt;接下来一行给出用空格隔开的这N个整数。&lt;&#x2F;n&lt;&#x3D;100000)&gt;</p><p><strong>输出</strong></p><p>每组测试数据输出一行，即最大子段和。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">-2 10 8 -4 7 5 -29 10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">b += a[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = a[i];</span><br><span class="line"><span class="keyword">if</span> (b &gt; sum)</span><br><span class="line">sum = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> M; cin &gt;&gt; M;</span><br><span class="line"><span class="keyword">while</span> (M--) &#123;</span><br><span class="line"><span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">maxSum</span>(a, N) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4454-最大子阵和"><a href="#4454-最大子阵和" class="headerlink" title="4454: 最大子阵和"></a>4454: 最大子阵和</h3><p><strong>题目描述</strong></p><p>有一个包含正数和负数的二维数组。一个子矩阵是指在该二维数组里，任意相邻的下标是1*1或更大的子数组。一个子矩阵的和是指该子矩阵中所有元素的和。本题中，把具有最大和的子矩阵称为最大子矩阵。<br> 例如：<br> 0 -2 -7 0<br> 9 2 -6 2<br> -4 1 -4 1<br> -1 8 0 -2<br> 这个数组的最大子矩阵为：<br> 9 2<br> -4 1<br> -1 8<br> 其和为15。</p><p><strong>输入</strong></p><p>输入包含多组测试数据。每组输入的第一行是一个正整数N（1&lt;&#x3D;N&lt;&#x3D;100），表示二维方阵的大小。接下来N行每行输入N个整数，表示数组元素，范围为[-127，127]。</p><p><strong>输出</strong></p><p>输出最大子阵和。</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line">9 2 -6 2</span><br><span class="line">-4 1 -4 1</span><br><span class="line">-1 8 0 -2</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], sum[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kadane</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_sum = arr[<span class="number">0</span>], cur_sum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur_sum = <span class="built_in">max</span>(cur_sum + arr[i], arr[i]);</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, cur_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) sum[i][j] = a[i][j];</span><br><span class="line">                <span class="keyword">else</span> sum[i][j] = sum[i - <span class="number">1</span>][j] + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) arr[k] = sum[j][k];</span><br><span class="line">                    <span class="keyword">else</span> arr[k] = sum[j][k] - sum[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">kadane</span>(n, arr));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] arr;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4449-最长上升子序列"><a href="#4449-最长上升子序列" class="headerlink" title="4449: 最长上升子序列"></a>4449: 最长上升子序列</h3><p><strong>题目描述</strong></p><p>给出一个由n个数组成的序列A[1..n]，求最长单调上升子序列（LIS)的长度。LIS即求最大的一个子序列长度m，使得a1&lt;a2&lt;……&lt;am且A[a1]&lt;A[a2]&lt;……&lt;A[am]。</p><p><strong>输入</strong></p><p>​两行：</p><p>​第1行：整数n (1&lt;&#x3D;n&lt;&#x3D;1000)</p><p>​第2行：n个整数 （int范围内），空格隔开。</p><p><strong>输出</strong></p><p>一行：一个整数，即最长上升子序列长度。</p><p><strong>样例输入</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6311213628205737824</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>               </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN], dp[MAXN];  <span class="comment">// dp[i]表示以a[i]为结尾的最长上升子序列长度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;  <span class="comment">// LIS长度至少为1</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;    <span class="comment">// 第一个元素自成长度为1的LIS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;  <span class="comment">// 初始化dp[i]为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;  <span class="comment">// 如果a[j]&lt;a[i]，则a[i]可以接在以a[j]结尾的LIS之后形成更长的LIS</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);  <span class="comment">// 更新最长上升子序列的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4453-最小乘车费用"><a href="#4453-最小乘车费用" class="headerlink" title="4453: 最小乘车费用"></a>4453: 最小乘车费用</h3><p><strong>题目描述</strong></p><p>​某条街上每一公里就有一汽车站，乘车费用如下表： </p><table><thead><tr><th>公里数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>费用</td><td>12</td><td>21</td><td>31</td><td>40</td><td>49</td><td>58</td><td>69</td><td>79</td><td>90</td><td>101</td></tr></tbody></table><p>​而一辆汽车从不行驶超过10公里。某人想行驶n公里，假设他可以任意次换车，请你帮他找到一种乘车方案使费用最小（10公里的费用比1公里小的情况是允许的）。 </p><p><strong>输入</strong></p><p>​第一行为10个不超过100的整数，依次表示行驶1～10公里的费用，相邻两数间用空格隔开； </p><p>​第二行为某人想要行驶的公里数(1000以内)。 </p><p><strong>输出</strong></p><p>包含一个整数，表示该测试点的最小费用。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 21 31 40 49 58 69 79 90 101 </span><br><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">147</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> f[<span class="number">25</span>],dp[<span class="number">205</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line">        cin&gt;&gt;f[i];</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=f[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+f[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">10</span> &amp;&amp; j&lt;=i; j++)</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i],dp[i-j]+f[j]);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dp[i]&lt;&lt;&quot;  &quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4448-方格取数"><a href="#4448-方格取数" class="headerlink" title="4448: 方格取数"></a>4448: 方格取数</h3><p><strong>题目描述</strong></p><p>​在n*n的方格阵中，从左上角出发，每次只能往正下方或右边走，找出一种路线方案，使得所经历方格中数字和最大，输出这个值。 </p><p>​（下图n&#x3D;5) </p><p>​  </p><table><thead><tr><th>0</th><th>5</th><th>37</th><th>53</th><th>9</th></tr></thead><tbody><tr><td>55</td><td>10</td><td>19</td><td>23</td><td>8</td></tr><tr><td>65</td><td>58</td><td>82</td><td>89</td><td>9</td></tr><tr><td>8</td><td>0</td><td>14</td><td>50</td><td>68</td></tr><tr><td>89</td><td>5</td><td>10</td><td>41</td><td>0</td></tr></tbody></table><p><strong>输入</strong></p><p>​第1行：一个整数n  (1&lt;&#x3D;n&lt;&#x3D;1000)</p><p>​第2-n+1行：每行n个非负整数 （整型范围）</p><p><strong>输出</strong></p><p>一行：一个整数</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">0537539</span><br><span class="line">551019238</span><br><span class="line">655882899</span><br><span class="line">80145068</span><br><span class="line">89510410</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">467</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4451-01背包"><a href="#4451-01背包" class="headerlink" title="4451: 01背包"></a>4451: 01背包</h3><p><strong>题目描述</strong></p><p>一个旅行者有一个最多能用M公斤的背包，现在有N件物品，<br> 它们的重量分别是W1，W2，…,Wn,<br> 它们的价值分别为P1,P2,…,Pn.<br> 若每种物品只有一件求旅行者能获得最大总价值。</p><p><strong>输入</strong></p><p>M,N<br> W1,P1<br> W2,P2<br> ……</p><p><strong>输出</strong></p><p>最大总价值。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 4</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">4 5</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; j) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]] + p[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4452-完全背包"><a href="#4452-完全背包" class="headerlink" title="4452: 完全背包"></a>4452: 完全背包</h3><p><strong>题目描述</strong></p><p>完全背包定义有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是c，价值是w。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。本题要求是背包恰好装满背包时，求出最大价值总和是多少。如果不能恰好装满背包，输出NO</p><p><strong>输入</strong></p><p>第一行： N 表示有多少组测试数据（N&lt;7）。 </p><p> 接下来每组测试数据的第一行有两个整数M，V。 M表示物品种类的数目，V表示背包的总容量。(0&lt;M&lt;&#x3D;2000，0&lt;V&lt;&#x3D;50000)<br> 接下来的M行每行有两个整数c，w分别表示每种物品的重量和价值(0&lt;c&lt;100000，0&lt;w&lt;100000)</p><p><strong>输出</strong></p><p>对应每组测试数据输出结果（如果能恰好装满背包，输出装满背包时背包内物品的最大价值总和。 如果不能恰好装满背包，输出NO）</p><p><strong>样例输入</strong>         </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 5</span><br><span class="line">2 2</span><br><span class="line">2 5</span><br><span class="line">2 2</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>           </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">999999</span>; <span class="comment">// 物品数量的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MAXV = <span class="number">999999</span>; <span class="comment">// 背包容量的最大值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> w[MAXN], v[MAXN]; <span class="comment">// w[i]表示第i件物品的体积，v[i]表示第i件物品的价值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXV]; <span class="comment">// f[j]表示背包容量为j时的最大价值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(f)); <span class="comment">// 初值为负无穷大</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 容量为0时，最大价值为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        &#123; <span class="comment">// 枚举物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = w[i]; j &lt;= m; j++) </span><br><span class="line">            &#123; <span class="comment">// 枚举容量</span></span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + v[i]); <span class="comment">// 转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f[m] &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七，字符串和数学实验"><a href="#七，字符串和数学实验" class="headerlink" title="七，字符串和数学实验"></a>七，字符串和数学实验</h2><h3 id="问题-A-字符串"><a href="#问题-A-字符串" class="headerlink" title="问题 A: 字符串"></a>问题 A: 字符串</h3><p><strong>题目描述</strong></p><p>给定连个字符串a和 b,求出b在a中第一次出现的位置。如果b没有在a中出现过,则输出-1。</p><p><strong>输入</strong></p><p>第一行包含一个数字T表示样例个数,对于每组样例,包含两个用空格分隔的字符串a,只包含小写字母。</p><p><strong>输出</strong></p><p>对于每组样例,输出b在a中第一次出现的位置。</p><p><strong>样例输入</strong>           复制          ****</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">abc b</span><br><span class="line">aaaab ab</span><br><span class="line">ab d</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><p>简单查找，（基础查找）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;cin &gt;&gt; T;  <span class="comment">// 输入样例个数</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        string a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;  <span class="comment">// 输入两个字符串</span></span><br><span class="line">        <span class="comment">// 在a中查找b</span></span><br><span class="line">        <span class="type">int</span> pos = a.<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (pos != string::npos) &#123;</span><br><span class="line">            cout &lt;&lt; pos &lt;&lt; endl;  <span class="comment">// 输出第一次出现的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;  <span class="comment">// 如果b没有在a中出现过，则输出-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法：（next数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算字符串s的前缀函数（即next数组）</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_prefix</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用KMP算法在a中查找b的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">compute_prefix</span>(b);</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] != b[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;  <span class="comment">// 输入样例个数</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        string a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;  <span class="comment">// 输入两个字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">kmp</span>(a, b);  <span class="comment">// 在a中查找b</span></span><br><span class="line">        cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="问题-B-Oulipo"><a href="#问题-B-Oulipo" class="headerlink" title="问题 B: Oulipo"></a>问题 B: Oulipo</h3><p><strong>题目描述</strong></p><p>The French author Georges Perec (1936–1982) once wrote a book, La  disparition, without the letter ‘e’. He was a member of the Oulipo  group. A quote from the book:</p><p> Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal,  d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir  où s’articulait l’association qui l’unissait au roman : stir son tapis,  assaillant à tout instant son imagination, l’intuition d’un tabou, la  vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision,  l’avision d’un oubli commandant tout, où s’abolissait la raison : tout  avait l’air normal mais…</p><p> Perec would probably have scored high (or rather, low) in the following  contest. People are asked to write a perhaps even meaningful text on  some subject with as few occurrences of a given “word” as possible. Our  task is to provide the jury with a program that counts these  occurrences, in order to obtain a ranking of the competitors. These  competitors often write very long texts with nonsense meaning; a  sequence of 500,000 consecutive ‘T’s is not unusual. And they never use  spaces.</p><p> So we want to quickly find out how often a word, i.e., a given string,  occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …,  ‘Z’} and two finite strings over that alphabet, a word W and a text T,  count the number of occurrences of W in T. All the consecutive  characters of W must exactly match consecutive characters of T.  Occurrences may overlap.</p><p><strong>输入</strong></p><p>The first line of the input file contains a single number: the number of  test cases to follow. Each test case has the following format:</p><p> One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤  |W| ≤ 20,000 (here |W| denotes the length of the string W).<br> One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 2,000,000.</p><p><strong>输出</strong></p><p>For every test case in the input file, the output should contain a single  number, on a single line: the number of occurrences of the word W in the text T.</p><p><strong>样例输入</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">BAPC</span><br><span class="line">BAPC</span><br><span class="line">AZA</span><br><span class="line">AZAZAZA</span><br><span class="line">VERDI</span><br><span class="line">AVERDXIVYERDIAN</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><p>依旧是KMP（next数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算模式串（pattern）的前缀函数（也称为最长前缀后缀）</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_prefix_function</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    pi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; pattern[k] != pattern[i]) &#123;</span><br><span class="line">            k = pi[k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[k] == pattern[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文本串（text）中查找模式串（pattern）的出现次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pi = <span class="built_in">compute_prefix_function</span>(pattern);</span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; pattern[q] != text[i]) &#123;</span><br><span class="line">            q = pi[q<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[q] == text[i]) &#123;</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == m) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            q = pi[q<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        string pattern, text;</span><br><span class="line">        cin &gt;&gt; pattern &gt;&gt; text;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">kmp</span>(pattern, text) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-C-本质不同的子串"><a href="#问题-C-本质不同的子串" class="headerlink" title="问题 C: 本质不同的子串"></a>问题 C: 本质不同的子串</h3><p><strong>题目描述</strong></p><p>​    mfc是一个很优秀的同学，他学习认真，经常刷题。这天，他正好学习到了字符串的相关知识。为了巩固知识，他在网上找到了这样一个题目：给定n(n&lt;&#x3D;10)个字符串环，每个字符串的长度为m(m&lt;&#x3D;500)，保证每个字符串中只有小写字母，求出每个字符串环有多少个本质不同的子串（两个字符串不相同则认为本质不同）。 </p><p>​    求解本质不同的子串是一个经典的问题，mfc提出了三种效率不同的做法，最简单但是最慢的方法mfc不屑于去讲（你可以去写），当然你也可以使用字典树来记录所有的子串，时间复杂度O(m^2)，如果你也想像m队长一样厉害，也可以学习后缀自动机来求解该问题，时间复杂度O(m)。如果你可以使用效率较高的程序来解决这个问题，就可以到acm实验室与m队长一较高下！ </p><p><strong>输入</strong></p><blockquote><p>​一共有n+1行输入  </p><p>​第一行输入n，表示测试实例的个数  </p><p>​接下来的n行，每行包括一个测试实例  </p></blockquote><p><strong>输出</strong></p><blockquote><p>​对于每个测试实例，输出该字符串环中本质不同的子串个数，每个输出占一行。 </p></blockquote><p><strong>样例输入</strong>            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">aaa</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>​字符串环是指一种形成环的字符串，例如abc，字符a后面跟着b，b后面跟着c，c后面跟着a。如下图所示  </p><p>​<img src="http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221202/20221202230513_20658.png" alt="img">  </p><p>​ </p><p>​对于第一个测试实例aaa，它有a，aa，aaa三个本质不同的子串。  </p><p>​对于第二个测试实例abc，它有a，b，c，ab，bc，ca，abc，bca，cab九个本质不同的子串。  </p></blockquote><p> <strong>思路&amp;解答：</strong></p><p>模仿字符串“环”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">set&lt;string&gt; str;</span><br><span class="line">string s, ss;</span><br><span class="line"><span class="type">int</span> m;cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> q = <span class="number">0</span>; q &lt; m; q++) &#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">ss = s + s;<span class="comment">//拼接</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ss.<span class="built_in">length</span>(); i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ss.<span class="built_in">length</span>() - i; j++)</span><br><span class="line"><span class="keyword">if</span> (j &lt;= s.<span class="built_in">length</span>())</span><br><span class="line">str.<span class="built_in">insert</span>(ss.<span class="built_in">substr</span>(i, j));<span class="comment">//键值对存储</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">clear</span>();<span class="comment">//清空准备下次使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动机</p><p>字典树</p><h3 id="问题-D-最小公倍数"><a href="#问题-D-最小公倍数" class="headerlink" title="问题 D: 最小公倍数"></a>问题 D: 最小公倍数</h3><p><strong>题目描述</strong></p><p>给定两个正整数，计算这两个数的最小公倍数。</p><p><strong>输入</strong></p><p>输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.</p><p><strong>输出</strong></p><p>对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。</p><p><strong>样例输入</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 14</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">        <span class="type">int</span> g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">        cout &lt;&lt; a / g * b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="问题-E-素数求和"><a href="#问题-E-素数求和" class="headerlink" title="问题 E: 素数求和"></a>问题 E: 素数求和</h3><p><strong>题目描述</strong></p><p>输入一个正整数N，求N以内所有的素数之和对于unsigned long long自然溢出后的结果。 </p><p><strong>输入</strong></p><p>第一行一个整数N </p><p><strong>输出</strong></p><p>一行一个素数 </p><p><strong>样例输入</strong>      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>​数据范围：10≤N≤10^7 </p><p><strong>思路&amp;解答</strong></p><p>使用筛法+is_prime判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n, sum = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;<span class="built_in">is_prime</span>(n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>筛：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inc(i,j,k) for(re int i=j;i&lt;=k;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(i,j,k) for(re int i=j;i&gt;=k;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> re <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"> <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+(ch^<span class="number">48</span>); ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"> <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>;</span><br><span class="line"><span class="type">bool</span> notprime[N+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> pri[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(notprime,<span class="number">0</span>,<span class="built_in">sizeof</span>(notprime));</span><br><span class="line"> notprime[<span class="number">0</span>]=notprime[<span class="number">1</span>]=<span class="number">1</span>; tot=<span class="number">0</span>;</span><br><span class="line"> <span class="built_in">inc</span>(i,<span class="number">2</span>,N)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!notprime[i]) pri[++tot]=i;</span><br><span class="line">  <span class="keyword">for</span>(re <span class="type">int</span> j=<span class="number">1</span>; j&lt;=tot &amp;&amp; i*pri[j]&lt;=N; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   notprime[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(!(i%pri[j])) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">prim</span>();</span><br><span class="line"> <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">inc</span>(i,<span class="number">1</span>,tot)&#123;</span><br><span class="line">  <span class="keyword">if</span>(pri[i]&lt;=n)&#123;</span><br><span class="line">   sum+=pri[i];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-F-人见人爱A-B"><a href="#问题-F-人见人爱A-B" class="headerlink" title="问题 F: 人见人爱A^B"></a>问题 F: 人见人爱A^B</h3><p><strong>题目描述</strong></p><p>求A^B的最后三位数表示的整数。<br> 说明：A^B的含义是“A的B次方”</p><p><strong>输入</strong></p><p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;&#x3D;A,B&lt;&#x3D;10000），如果A&#x3D;0, B&#x3D;0，则表示输入数据的结束，不做处理。</p><p><strong>输出</strong></p><p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</p><p><strong>样例输入</strong>            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">12 6</span><br><span class="line">6789 10000</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">984</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><p>因为只要最后三位，如果多余三位，只保留后三位（%1000）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> A, B;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; A &gt;&gt; B &amp;&amp; !(A == <span class="number">0</span> &amp;&amp; B == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (B &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (B &amp; <span class="number">1</span>) &#123;</span><br><span class="line">ans = (ans * A) % <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line">A = (A * A) % <span class="number">1000</span>;</span><br><span class="line">B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">a %= m;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)res = res * a % m;</span><br><span class="line">a = a * a % m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, p;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">Pow</span>(a,b,p);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-G-XORinacci"><a href="#问题-G-XORinacci" class="headerlink" title="问题 G: XORinacci"></a>问题 G: XORinacci</h3><p><strong>题目描述</strong></p><p>​Cengiz recently learned Fibonacci numbers and now he is studying  different algorithms to find them. After getting bored of reading them,  he came with his own new type of numbers that he named XORinacci numbers. He defined them as follows:</p><ul><li>​f(0)&#x3D;a </li><li>​f(1)&#x3D;b </li><li>​f(n)&#x3D;f(n−1)⊕f(n−2) when n&gt;1, where ⊕ denotes the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR">bitwise XOR operation</a>.</li></ul><p>​You are given three integers a, b, and n, calculate f(n).</p><p>​You have to answer for T independent test cases.</p><p><strong>输入</strong></p><p>​The input contains one or more independent test cases.</p><p>​The first line of input contains a single integer T (1≤T≤1000), the number of test cases.</p><p>​Each of the T following lines contains three space-separated integers a, b, and n (0≤a,b,n≤10^9) respectively.</p><p><strong>输出</strong></p><p>For each test case, output f(n).</p><p><strong>样例输入</strong>             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 2</span><br><span class="line">4 5 0</span><br><span class="line">325 265 1231232</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">4</span><br><span class="line">76</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>In the first example, f(2)&#x3D;f(0)⊕f(1)&#x3D;3⊕4&#x3D;7</p><p><strong>思路&amp;解答</strong></p><p>找规律得结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, INF_BIT = <span class="number">0x3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> a, b, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a ^ b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="问题-H-不同的n-x2F-i"><a href="#问题-H-不同的n-x2F-i" class="headerlink" title="问题 H: 不同的n&#x2F;i"></a>问题 H: 不同的n&#x2F;i</h3><p><strong>题目描述</strong></p><p>给定一个n，对于i从1到n，找出有多少个不同的n&#x2F;i<br> 如：n&#x3D;6<br> 有4个不同的n&#x2F;i：6，3，2，1 </p><p><strong>输入</strong></p><p>第一行一个T，表示有T组数据(T &lt; 100000)<br> 之后T行，每行一个n(n &lt;&#x3D; 10^18) </p><p><strong>输出</strong></p><p>每行输出一个数，表示不同的个数 </p><p><strong>样例输入</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>               </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>对于50%的数据：n &lt;&#x3D; 100000, T &lt;&#x3D; 10<br> 对于100%的数据：n &lt;&#x3D; 10^18, T &lt; 100000</p><p><strong>思路&amp;解答</strong></p><p>依旧是找规律写代码</p><table><thead><tr><th>i&#x3D;1</th><th>1(1)</th><th></th></tr></thead><tbody><tr><td>i&#x3D;2</td><td>2(2,3)</td><td>3(4,5)</td></tr><tr><td>i&#x3D;3</td><td>4(6,7,8)</td><td>5(9,10,11)</td></tr><tr><td>i&#x3D;4</td><td>6(12,13,14,15)</td><td>7(16,17,18,19)</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line">        <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            cin &gt;&gt; i;</span><br><span class="line">            <span class="type">int</span> n = (<span class="type">int</span>)((<span class="number">-1</span> + <span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">4</span> * i)) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> k = (<span class="type">int</span>)((<span class="number">-1</span> + <span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">4</span> * (i - n))) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n==k+<span class="number">1</span>)cout &lt;&lt; <span class="number">2</span> * n - <span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="number">2</span> * n<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序设计综合实践练习&quot;&gt;&lt;a href=&quot;#程序设计综合实践练习&quot; class=&quot;headerlink&quot; title=&quot;程序设计综合实践练习&quot;&gt;&lt;/a&gt;程序设计综合实践练习&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一，基础算法1&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    
    <category term="程序设计 OJ" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-OJ/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-07T10:49:47.452Z</published>
    <updated>2023-04-07T10:49:47.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机系统基础"><a href="#计算机系统基础" class="headerlink" title="计算机系统基础"></a>计算机系统基础</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><p>一种将程序指令存储器和数据存储器合并在一起的一种计算机组织结构</p><ul><li>运算器（ALU）</li><li>控制器（Controller）</li></ul><p>（前两个称为CPU（MPU</p><ul><li><p>存储器（Memory）</p></li><li><p>输入设备（Input device）</p></li><li><p>输出设备（Output Device）</p></li></ul><p>后两个叫IO设备</p><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\697508b76e3781cdd09216f282dce4d.png" alt="697508b76e3781cdd09216f282dce4d" style="zoom:67%;" /><ul><li>数据总线（Data Bus）：在CPU与RAM之间来回传送需要处理或是需要储存的数据。</li><li>地址总线（Address Bus）：用来指定在RAM（Random Access Memory）之中储存的数据的地址。</li><li>控制总线（Control Bus）：将微处理器控制单元（Control Unit）的信号，传送到周边设备。</li><li>扩展总线（Expansion Bus）：外部设备和计算机主机进行数据通信的总线，例如ISA总线，PCI总线。</li><li>局部总线（Local Bus）：取代更高速数据传输的扩展总线。</li></ul><p>其中的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF/272650?fromModule=lemma_inlink">数据总线</a>DB（Data Bus）、<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF/4307936?fromModule=lemma_inlink">地址总线</a>AB（Address Bus）和<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF/272568?fromModule=lemma_inlink">控制总线</a>CB（Control Bus），也统称为<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF?fromModule=lemma_inlink">系统总线</a>，即通常意义上所说的总线。</p><h2 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h2><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h3 id="addressing-and-Byte-Ordering（字节序（大小端））"><a href="#addressing-and-Byte-Ordering（字节序（大小端））" class="headerlink" title="addressing and Byte Ordering（字节序（大小端））"></a>addressing and Byte Ordering（字节序（大小端））</h3><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\45d407b6c4cf35fd989a1e533eb67d7.png" alt="45d407b6c4cf35fd989a1e533eb67d7" style="zoom:50%;" /><p>（上：大端；下：小端）</p><p>（endian：（查不到）《格列佛游记》无所谓之争）</p><p>x86小端多，网络协议大端多</p><h3 id="Word-Size（字长）"><a href="#Word-Size（字长）" class="headerlink" title="Word Size（字长）"></a>Word Size（字长）</h3><p>Until recently，most machines used 32bits（4bytes）as word size</p><p>Limits addresses to 4GB(2^32 bytes)</p><p>TiB更精确，TB小点（不同单位不一样）<img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\36c50892cbd27aee0ae0fe7808306ac.png" alt="36c50892cbd27aee0ae0fe7808306ac" style="zoom:50%;" /></p><h3 id="Representing-Pointers"><a href="#Representing-Pointers" class="headerlink" title="Representing Pointers"></a>Representing Pointers</h3><h3 id="Representing-Code"><a href="#Representing-Code" class="headerlink" title="Representing Code"></a>Representing Code</h3><p>指令集不同，跨平台能力不同</p><h4 id="封装格式：PE（可移zhi），ELF"><a href="#封装格式：PE（可移zhi），ELF" class="headerlink" title="封装格式：PE（可移zhi），ELF"></a>封装格式：PE（可移zhi），ELF</h4><h3 id="Boolean-Algebra"><a href="#Boolean-Algebra" class="headerlink" title="Boolean Algebra"></a>Boolean Algebra</h3><h4 id="And-amp-；Or-；“Not-”；Xor-（异或）；"><a href="#And-amp-；Or-；“Not-”；Xor-（异或）；" class="headerlink" title="And&amp;；Or|；“Not~”；Xor^（异或）；"></a>And&amp;；Or|；“Not~”；Xor^（异或）；</h4><p>异或异或太重要了！！！！</p><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\81680077440ffe2b18d57c076c5854d.png" alt="81680077440ffe2b18d57c076c5854d" style="zoom:50%;" /><h3 id="Logical-Operations-in-C（逻辑）"><a href="#Logical-Operations-in-C（逻辑）" class="headerlink" title="Logical Operations in C（逻辑）"></a>Logical Operations in C（逻辑）</h3><p>||（或；&amp;&amp;（与；！（非；</p><p><strong>short Circuit</strong>前成立后不执行</p><p>有效防止除零和空指针运算</p><h3 id="Shift-Operations-in-C-位移"><a href="#Shift-Operations-in-C-位移" class="headerlink" title="Shift Operations in C(位移)"></a>Shift Operations in C(位移)</h3><p>&lt;&lt;;&gt;&gt;(算术右移（补数据最高位）；逻辑右移)</p><h3 id="Undefined-Behavior（未定义行为）"><a href="#Undefined-Behavior（未定义行为）" class="headerlink" title="Undefined Behavior（未定义行为）"></a>Undefined Behavior（未定义行为）</h3><p>可读性</p><h3 id="Operator-precedence-issues"><a href="#Operator-precedence-issues" class="headerlink" title="Operator precedence issues"></a>Operator precedence issues</h3><p>加减大于位移</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>底层实现</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>gcc -o1 p1.c p2.c -o p</p><p>-o1优化，p1.c,p2.c编译为p文件</p><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\a2d70754da27d5fd6f1c7350bd0b254.png" alt="a2d70754da27d5fd6f1c7350bd0b254" style="zoom:50%;" /><p>linker链接部分错误更隐蔽</p><h5 id="汇编转换"><a href="#汇编转换" class="headerlink" title="汇编转换"></a>汇编转换</h5><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\34d396975b427229df4709a9b91c51f.png" alt="34d396975b427229df4709a9b91c51f" style="zoom:50%;" /><h5 id="反汇编工具（linux）："><a href="#反汇编工具（linux）：" class="headerlink" title="反汇编工具（linux）："></a>反汇编工具（linux）：</h5><p>objdump -d winword.exe</p><p>gdb sum</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机系统基础&quot;&gt;&lt;a href=&quot;#计算机系统基础&quot; class=&quot;headerlink&quot; title=&quot;计算机系统基础&quot;&gt;&lt;/a&gt;计算机系统基础&lt;/h1&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/03/15/%E4%B8%8A%E7%BD%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/03/15/%E4%B8%8A%E7%BD%91/</id>
    <published>2023-03-14T16:00:00.000Z</published>
    <updated>2023-05-25T04:28:10.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="超简单教你科学上网"><a href="#超简单教你科学上网" class="headerlink" title="超简单教你科学上网"></a>超简单教你科学上网</h1><h2 id="一，科学上网"><a href="#一，科学上网" class="headerlink" title="一，科学上网"></a>一，科学上网</h2><h3 id="1-下载Clash（承载vpn的工具）（这个简洁很多我感觉"><a href="#1-下载Clash（承载vpn的工具）（这个简洁很多我感觉" class="headerlink" title="1.下载Clash（承载vpn的工具）（这个简洁很多我感觉"></a>1.下载Clash（承载vpn的工具）（这个简洁很多我感觉</h3><p>链接：<a href="https://pan.baidu.com/s/1l96-P0hxq3mVgVBocy_vEw?pwd=l7rs">https://pan.baidu.com/s/1l96-P0hxq3mVgVBocy_vEw?pwd=l7rs</a><br>提取码：l7rs</p><p>解压后(密码wind)打开文件夹里的猫猫头像（Clash for Windows.exe)</p><h3 id="这两个用哪个都可以"><a href="#这两个用哪个都可以" class="headerlink" title="这两个用哪个都可以"></a>这两个用哪个都可以</h3><p>只要学会加配置+选择结点，两个都一样</p><h3 id="2-购买订阅"><a href="#2-购买订阅" class="headerlink" title="2.购买订阅"></a>2.购买订阅</h3><p><a href="https://w1.v2free.top/auth/register?code=VXqA">https://w1.v2free.top/auth/register?code=VXqA</a><br><a href="https://v02.fl-aff.com/auth/register?code=qeNM">https://v02.fl-aff.com/auth/register?code=qeNM</a><br>这两个机场都不错<br>（一直在换着用）（</p><h3 id="3-导入订阅，使用Clash："><a href="#3-导入订阅，使用Clash：" class="headerlink" title="3.导入订阅，使用Clash："></a>3.导入订阅，使用Clash：</h3><p><strong>如果上面选了第一个：</strong></p><p>主页往下面一点有【Clash】[ 配置一键导入]，</p><p>但是这个网站的自己的教程我放这里：</p><p><a href="https://go.runba.cyou/doc/#/Windows/V2RayN">https://go.runba.cyou/doc/#/Windows/V2RayN</a></p><p>（这个是V2rayN（另一个承载工具的名字）但是方法我觉得用下面那个就可以（</p><p><strong>如果选第二个</strong></p><p>主要是会导入配置文件就ok（推荐下面这个配置方式</p><p><a href="https://help.fastlink.digital/clash_for_windows">https://help.fastlink.digital/clash_for_windows</a></p><p>（笔者建议，购买选第一个，然后承载容器选clash的</p><p>我粘这里</p><p><a href="https://w1.v2free.top/auth/register?code=VXqA">https://w1.v2free.top/auth/register?code=VXqA</a></p><p><a href="https://help.fastlink.digital/clash_for_windows">https://help.fastlink.digital/clash_for_windows</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;超简单教你科学上网&quot;&gt;&lt;a href=&quot;#超简单教你科学上网&quot; class=&quot;headerlink&quot; title=&quot;超简单教你科学上网&quot;&gt;&lt;/a&gt;超简单教你科学上网&lt;/h1&gt;&lt;h2 id=&quot;一，科学上网&quot;&gt;&lt;a href=&quot;#一，科学上网&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="科学上网" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
</feed>
