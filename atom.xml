<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习生活手账本</title>
  <icon>https://www.gravatar.com/avatar/260de78781b3355b5fcbb52d09a7a2a9</icon>
  
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/"/>
  <updated>2024-01-23T16:56:30.326Z</updated>
  <id>https://github.com/xyy9233/xyy9233.github.io.git/</id>
  
  <author>
    <name>wind_9233</name>
    <email>1768765226@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>指令虚拟化</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2024-01-22T16:00:00.000Z</published>
    <updated>2024-01-23T16:56:30.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令虚拟化"><a href="#指令虚拟化" class="headerlink" title="指令虚拟化"></a>指令虚拟化</h1><p>虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数和结构来解析自定义的指令并执行相应的功能。</p><p>虚拟化是一种基于虚拟机的代码保护技术。他将硬件支持的机器码转化为字节码指令系统，来达到不被轻易篡改和逆向的目的。</p><p>简单来说就是出题人通过实现一个小型的虚拟机，自定义一些操作码（opcode），然后在程序执行时通过解释操作码，执行对应的函数，从而实现程序原有的功能。</p><p>下图是常见的虚拟机结构：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123191130428.png" alt="image-20240123191130428"></p><p>虚拟机的主程序其实就是一个循环，这个循环不断的去读取指令（伪机器码 opcode），然后执行指令opcode 所对应的一些函数，这样下来就可以与真实的程序执行相差无几。</p><h2 id="正向实现"><a href="#正向实现" class="headerlink" title="正向实现"></a><strong>正向实现</strong></h2><p>想要对抗虚拟化，首先要搞清楚用于保护的虚拟机是如何实现的要想实现虚拟机，需要完成两个目标：</p><ol><li><p>定义一套指令集</p></li><li><p>实现对应的解释器</p></li></ol><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h3><p>真实赛题中的 VM 通常会实现一个类似如下的结构体，用于保存虚拟机状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r1; <span class="comment">// 虚拟寄存器 r1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r2; <span class="comment">// 虚拟寄存器 r2</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> eip; <span class="comment">// 指向正在解释的 opcode 地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mem[<span class="number">256</span>]; <span class="comment">// 虚拟内存</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[<span class="number">1024</span>]; <span class="comment">// 存放自定义机器码</span></span><br><span class="line">&#125; VM;</span><br></pre></td></tr></table></figure><h3 id="opcode-定义"><a href="#opcode-定义" class="headerlink" title="opcode 定义"></a><strong>opcode</strong> <strong>定义</strong></h3><p>接着自定义一些指令，需要决定该指令集是<strong>定长</strong>的还是<strong>变长</strong>的。</p><p>这里以变长指令集为例，先列出一个表来：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123194824707.png" alt="image-20240123194824707"></p><h3 id="书写机器码"><a href="#书写机器码" class="headerlink" title="书写机器码"></a><strong>书写机器码</strong></h3><p>假定希望实现的语义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> input[<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> target[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, input);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">input[i] ^= <span class="number">0x21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(input, target, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们定义的指令对其进行拆分和重构，可以得到如下机器码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[] = &#123;</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="comment">// mem[0x10] = &#x27;H&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="comment">// mem[0x11] = &#x27;e&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x12] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x13] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="comment">// mem[0x14] = &#x27;o&#x27;</span></span><br><span class="line"><span class="number">0x40</span>, <span class="comment">// scanf(&quot;%5s&quot;, &amp;mem[0]);</span></span><br><span class="line"><span class="number">0x11</span>, <span class="number">0x21</span>, <span class="comment">// r2 = 0x21</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x0</span>, <span class="comment">// r1 = 0</span></span><br><span class="line"><span class="number">0x30</span>, <span class="comment">// mem[r1] ^= r2</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x1</span>, <span class="comment">// r1 = 1</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x2</span>, <span class="comment">// r1 = 2</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x3</span>, <span class="comment">// r1 = 3</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x4</span>, <span class="comment">// r1 = 4</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span> <span class="comment">// return memcmp(&amp;mem[0], &amp;mem[0x10], 5);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化虚拟机"><a href="#初始化虚拟机" class="headerlink" title="初始化虚拟机"></a><strong>初始化虚拟机</strong></h3><p>在实际运行虚拟机之前，需要先对 VM 结构体进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM* <span class="title function_">vm_new</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = (VM*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(VM)); <span class="comment">// 申请内存</span></span><br><span class="line"><span class="built_in">memset</span>(vm, <span class="number">0</span>, <span class="keyword">sizeof</span>(VM)); <span class="comment">// 清空结构体字段</span></span><br><span class="line"><span class="built_in">memcpy</span>(vm-&gt;code, code, <span class="keyword">sizeof</span>(code)); <span class="comment">// 拷贝机器码</span></span><br><span class="line"><span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释器编写"><a href="#解释器编写" class="headerlink" title="解释器编写"></a><strong>解释器编写</strong></h3><p>现在就可以来实现每条指令的 handle 以及 dispatcher 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vm_run</span><span class="params">(VM* vm)</span> &#123;</span><br><span class="line"><span class="type">char</span> opcode;</span><br><span class="line"><span class="type">char</span> operand_1, operand_2;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">opcode = vm-&gt;code[vm-&gt;eip];</span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r1 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r2 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line">vm-&gt;mem[operand_1] = operand_2;</span><br><span class="line">vm-&gt;eip += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2;</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, &amp;vm-&gt;mem[<span class="number">0</span>]);</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">memcmp</span>(&amp;vm-&gt;mem[<span class="number">0</span>], &amp;vm-&gt;mem[operand_1], operand_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><p>于是 main 函数可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = vm_new();</span><br><span class="line"><span class="keyword">if</span> (!vm_run(vm))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a><strong>解题步骤</strong></h2><p>遇到 VM 类的赛题，我们一般按照如下的步骤来解题：</p><ul><li><p>分析 VM 结构</p><ul><li>结构体大小</li><li>有哪些字段（内存、寄存器）</li></ul></li><li><p>分析指令集</p><ul><li>指令长度是否可变</li><li>每种指令的构成</li><li>每种指令的含义（伪汇编）</li><li>VM 的退出条件</li></ul></li><li><p>编写 Python 版解释器，输出伪汇编代码</p></li><li><p>阅读伪代码，分析程序流程，写出去虚拟化的原始代码</p></li><li><p>书写解题脚本</p></li></ul><p>本例中的 Python 版解释器如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>,</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="number">0x40</span>, <span class="number">0x11</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0x0</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x1</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x2</span>,</span><br><span class="line"><span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x3</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x4</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span>]</span><br><span class="line">ip = <span class="number">0</span></span><br><span class="line">r1 = r2 = <span class="number">0</span></span><br><span class="line">mem = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">opcode = code[ip]</span><br><span class="line"><span class="keyword">if</span> opcode == <span class="number">0x10</span> :</span><br><span class="line">r1 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r1, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x11</span> :</span><br><span class="line">r2 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r2, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x20</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">mem[op1] = op2</span><br><span class="line">print(f<span class="string">&quot;mov [&#123;hex(op1)&#125;], &#123;hex(op2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">3</span></span><br><span class="line">elif opcode == <span class="number">0x30</span> :</span><br><span class="line">mem[r1] ^= r2</span><br><span class="line">print(f<span class="string">&quot;xor [&#123;hex(r1)&#125;], &#123;hex(r2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x40</span> :</span><br><span class="line"><span class="meta"># flag = input().encode()</span></span><br><span class="line">flag = b<span class="string">&quot;iDMMN&quot;</span></span><br><span class="line"><span class="keyword">for</span> i in range(len(flag)) :</span><br><span class="line">mem[i] = flag[i]</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x50</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">print(mem[<span class="number">0</span>:op2] == mem[op1:op1 + op2])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">raise ValueError(<span class="string">&quot;unknown opcode&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指令虚拟化&quot;&gt;&lt;a href=&quot;#指令虚拟化&quot; class=&quot;headerlink&quot; title=&quot;指令虚拟化&quot;&gt;&lt;/a&gt;指令虚拟化&lt;/h1&gt;&lt;p&gt;虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数</summary>
      
    
    
    
    
    <category term="指令虚拟化 VM" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96-VM/"/>
    
  </entry>
  
  <entry>
    <title>自修改代码</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/</id>
    <published>2024-01-21T16:00:00.000Z</published>
    <updated>2024-01-22T16:06:59.822Z</updated>
    
    <content type="html"><![CDATA[<p>PE文件结构&#x2F;&#x2F;</p><h1 id="自修改代码"><a href="#自修改代码" class="headerlink" title="自修改代码"></a>自修改代码</h1><p>Self-Modifying Code</p><p>自修改代码（Self-Modifying Code），指在一段代码执行前对它进行修改。把代码以加密的形式保存在可执行文件中（或静态资源中），然后在程序执行的时候进行动态解密。这样我们在采用静态分析时，看到的都是加密的内容，从而减缓甚至阻止静态分析。</p><h2 id="原理与示例"><a href="#原理与示例" class="headerlink" title="原理与示例"></a>原理与示例</h2><p>SMC思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (运行条件满足) &#123;</span><br><span class="line">DecryptProc(Address of Check) <span class="comment">// 对 Check 代码解密</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">Check(); <span class="comment">// 调用 Check</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">EncryptProc(Address of Check) <span class="comment">// 再对代码进行加密，防止程序被 dump</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SMC静态分析对抗示例：</p><p>正常程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS 中 Release 32 位下编译（关闭随机基址），放入 IDA 中查看：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122225317272.png" alt="image-20240122225317272"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> _check__YAHH_Z[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x51</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xEB</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x8B</span>, <span class="number">0xE5</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们想把 check 函数保护起来，先把其机器码摘出来进行加密：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> check[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x33</span>, <span class="number">0xC0</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x94</span>, <span class="number">0xC0</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(check); i++)</span><br><span class="line">&#123;</span><br><span class="line">check[i] ^= <span class="number">0x90</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, check[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c5 1b 7c c1 11 ed 98 a9 a0 90 90 e5 99 57 d5 6c 91 90 90 90 7b 97 57 d5 6c 90 90 90 90 1b d5 6c 1b 75 cd 53</span><br></pre></td></tr></table></figure><p>修改初始代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line">DWORD old;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, PAGE_EXECUTE_READWRITE, &amp;old); <span class="comment">// 修改内存页权限</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, old, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt(); <span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译后，在 16 进制编辑器中找到并修改 check 函数的机器码为加密后的数据</p><p>一个具备 SMC 属性的可执行文件已经构造完成了，现在再用 IDA 进行分析：</p><p>发现原始逻辑已经被很好地隐藏了。</p><p>另一种常见的实现方法是通过新增一个具备 RWX 属性的程序段，将需要保护的代码书写在其中，这样就可以避免调用 VirtualAlloc &#x2F; VirtualProtect &#x2F; mprotect 这类 API 来暴露 SMC 的意图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg(<span class="string">&quot;.qaq&quot;</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:.qaq,ERW&quot;</span>)</span></span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt();</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 IDA 中看到新增了一个段：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122235013392.png" alt="image-20240122235013392"></p><h2 id="对抗思路"><a href="#对抗思路" class="headerlink" title="对抗思路"></a>对抗思路</h2><p>能动态调试最好直接动态调试，因为在程序运行的某一时刻，它一定是解密完成的，这时也就暴露了，使用<strong>动态分析运行到这一时刻即可过掉保护</strong>。</p><p>其次是根据静态分析获得解密算法，写出解密脚本提前解密这段代码。</p><p>解密得到的机器码可以通过 IDAPython 的 patch_byte 接口很方便地写回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PE文件结构&amp;#x2F;&amp;#x2F;&lt;/p&gt;
&lt;h1 id=&quot;自修改代码&quot;&gt;&lt;a href=&quot;#自修改代码&quot; class=&quot;headerlink&quot; title=&quot;自修改代码&quot;&gt;&lt;/a&gt;自修改代码&lt;/h1&gt;&lt;p&gt;Self-Modifying Code&lt;/p&gt;
&lt;p&gt;自修改代码</summary>
      
    
    
    
    
    <category term="逆向 子修改代码" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91-%E5%AD%90%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>花指令&amp;反调试</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/</id>
    <published>2024-01-18T16:00:00.000Z</published>
    <updated>2024-01-22T17:09:44.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="花指令-amp-反调试"><a href="#花指令-amp-反调试" class="headerlink" title="花指令&amp;反调试"></a>花指令&amp;反调试</h1><p>2024&#x2F;01&#x2F;17</p><p>好，做道upx练手，把sublime搞崩了。后来才知道是文件没有保存用不了。<br>现在还有个问题，就是文件git不上去。。。听天由命吧</p><p>2024&#x2F;01&#x2F;18</p><p>git上去了！</p><p>方法：更改了C:\Windows\System32\drivers\etc的hosts，加了IP表，好用！（呜呜呜）</p><p>2024&#x2F;01&#x2F;19</p><p>听伯尼学长说，修改系统配置的http_proxy和https_proxy为梯子的ip，这样就可以在ping的时候走梯子了</p><p>或者直接在cmd里<code>set http_proxy=http://127.0.0.1:7890 &amp; set https_proxy=http://127.0.0.1:7890</code></p><p>欸嘿，昨天玩儿了一天，今天继续学</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>解析失败，一般可能是花指令</p><h3 id="会被执行"><a href="#会被执行" class="headerlink" title="会被执行"></a>会被执行</h3><p>干扰静态分析*</p><h4 id="改变堆栈操作"><a href="#改变堆栈操作" class="headerlink" title="改变堆栈操作"></a>改变堆栈操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">add esp, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用call指令或jmp指令增加执行流程复杂度"><a href="#利用call指令或jmp指令增加执行流程复杂度" class="headerlink" title="利用call指令或jmp指令增加执行流程复杂度"></a>利用call指令或jmp指令增加执行流程复杂度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">call xxx</span><br><span class="line">xxx :</span><br><span class="line">add[esp], <span class="number">0x7</span></span><br><span class="line">retn</span><br><span class="line">_emit <span class="number">0x12</span></span><br><span class="line">_emit <span class="number">0x34</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wwwwww&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有0x12,0x34，push没识别出来，printf后没法执行。</p><p>call–&gt;结束</p><p>找到栈变化的地方（esp转向）按C重编译</p><h3 id="不会被执行"><a href="#不会被执行" class="headerlink" title="不会被执行"></a>不会被执行</h3><h4 id="插入机器码"><a href="#插入机器码" class="headerlink" title="插入机器码"></a>插入机器码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="keyword">xor</span> eax, eax;</span><br><span class="line">jz xxx;</span><br><span class="line">_emit <span class="number">0x11</span>;</span><br><span class="line">_emit <span class="number">0x22</span>;</span><br><span class="line">_emit <span class="number">0x33</span>; <span class="comment">// 0x33是 xor 指令的操作码，会导致后面正常的 push 指令被错误解析</span></span><br><span class="line">xxx:</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改变堆栈平衡"><a href="#改变堆栈平衡" class="headerlink" title="改变堆栈平衡"></a>改变堆栈平衡</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        <span class="keyword">xor</span> eax,eax;</span><br><span class="line">        jz s;</span><br><span class="line">        add esp,<span class="number">0x11</span>;</span><br><span class="line">    s:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA反编译报错，好像可以F5重编译。。。或者发现花指令地方nop！</p><p>xor eax，eax后有jz命令后有一个+1</p><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>检测调试的陷阱w~</p><h3 id="函数检测："><a href="#函数检测：" class="headerlink" title="函数检测："></a>函数检测：</h3><p>函数检测就是通过 Windows 自带的公开或未公开的函数直接检测程序是否处于调试状态。</p><h4 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a><strong>IsDebuggerPresent</strong></h4><p>最简单的调试器检测函数是 IsDebuggerPresent() ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">IsDebuggerPresent</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数查询进程环境块（PEB）中的 BeingDebugged 标志，如果进程处在调试上下文中，则返回一个非零值，否则返回零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> IsDebuggerPresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a><strong>CheckRemoteDebuggerPresent</strong></h4><p>CheckRemoteDebuggerPresent() 用于检测一个远程进程是否处于调试状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">CheckRemoteDebuggerPresent</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE hProcess,</span></span><br><span class="line"><span class="params">_Inout_ PBOOL pbDebuggerPresent</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>如果 hProcess 句柄表示的进程处于调试上下文，则设置 pbDebuggerPresent 变量被设置为TRUE ，否则被设置为 FALSE 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BOOL ret;</span><br><span class="line">CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a><strong>NtQueryInformationProcess</strong></h4><p>NtQueryInformationProcess 用于获取给定进程的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI <span class="title function_">NtQueryInformationProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">_In_ PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class="line"><span class="params">_Out_ PVOID ProcessInformation,</span></span><br><span class="line"><span class="params">_In_ ULONG ProcessInformationLength,</span></span><br><span class="line"><span class="params">_Out_opt_ PULONG ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>第二个参数 ProcessInformationClass 给定了需要查询的进程信息类型。当给定值为0 （ ProcessBasicInformation ）或 7 （ProcessDebugPort ）时，就能得到相关调试信息，返回信息会写到第三个参数 ProcessInformation 指向的缓冲区中。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dbgport = <span class="number">0</span>;</span><br><span class="line">HMODULE hModule = LoadLibrary(<span class="string">&quot;Ntdll.dll&quot;</span>);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess =(NtQueryInformationProcessPtr)GetProcAddress(hModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), <span class="number">7</span>, &amp;dbgPort,<span class="keyword">sizeof</span>(dbgPort),<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> dbgPort != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetLastError"><a href="#GetLastError" class="headerlink" title="GetLastError"></a><strong>GetLastError</strong></h4><p>编写应用程序时，经常需要涉及到错误处理问题。许多函数调用只用 TRUE 和 FALSE 来表明函数的运行结果。一旦出现错误，MSDN 中往往会指出请用 GetLastError 函数来获得错误原因。</p><p>恶意代码可以使用异常来破坏或者探测调试器。调试器捕获异常后，并不会立即将处理权返回被调试进程处理，大多数利用异常的反调试技术往往据此来检测调试器。</p><p>多数调试器默认的设置是捕获异常后不将异常传递给应用程序。如果调试器不能将异常结果正确返回到被调试进程，那么这种异常失效可以被进程内部的异常处理机制探测。</p><p>对于 OutputDebugString 函数，它的作用是在调试器中显示一个字符串，同时它也可以用来探测调试器的存在。使用 SetLastError 函数，将当前的错误码设置为一个任意值。</p><p>如果进程没有被调试器附加，调用 OutputDebugString 函数会失败，错误码会重新设置，因此GetLastError 获取的错误码应该不是我们设置的任意值。</p><p>但如果进程被调试器附加，调用 OutputDebugString 函数会成功，这时 GetLastError 获取的错误码应该没改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD errorValue = <span class="number">12345</span>;</span><br><span class="line"><span class="built_in">SetLastError</span>(errorValue);</span><br><span class="line"><span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Test for debugger!&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == errorValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 DeleteFiber 函数，如果给它传递一个无效的参数的话会抛出ERROR_INVALID_PARAMETER 异常。如果进程正在被调试的话，异常会被调试器捕获。所以，同样可以通过验证 LastError 值来检测调试器的存在。如代码所示，0x57 就是指 ERROR_INVALID_PARAMETER 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> fib[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">DeleteFiber</span>(fib);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">GetLastError</span>() != <span class="number">0x57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样还可以使用 CloseHandle 、 CloseWindow 产生异常，使得错误码改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseHandle((HANDLE)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseWindow((HWND)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_WINDOW_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据检测"><a href="#数据检测" class="headerlink" title="数据检测"></a><strong>数据检测</strong></h3><h4 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a><strong>BeingDebugged</strong></h4><p>数据检测是指程序通过测试一些与调试相关的关键位置的数据来判断是否处于调试状态。比如 PEB 中的 BeingDebugged 参数。数据检测就是直接定位到这些数据地址并测试其中的数据，从而避免调用函数，使程序的行为更加隐蔽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDebug = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h] ; 指向 PEB 基地址</span><br><span class="line">movzx eax, byte ptr [eax+<span class="number">2</span>]</span><br><span class="line">mov BeingDebug, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDebug != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fs:[30h]</strong></p><h4 id="NTGlobalFlag"><a href="#NTGlobalFlag" class="headerlink" title="NTGlobalFlag"></a><strong>NTGlobalFlag</strong></h4><p>由于调试器中启动的进程与正常启动的进程创建堆的方式有些不同，系统使用 PEB 结构偏移量 0x68 处的一个未公开的位置 NTGlobalFlag ，来决定如何创建堆结构。如果这个位置上的值为 0x70 ，则进程处于调试器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h]</span><br><span class="line">mov eax, dword ptr [eax + <span class="number">68</span>h]</span><br><span class="line">and eax, <span class="number">0x70</span></span><br><span class="line">mov BeingDbg, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDbg != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程检测"><a href="#进程检测" class="headerlink" title="进程检测"></a><strong>进程检测</strong></h3><p>进程检测通过检测当前桌面中是否存在特定的调试进程来判断是否存在调试器，但不能判断该调试器是否正在调试该程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FindWindowA(<span class="string">&quot;x32dbg&quot;</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD ID;</span><br><span class="line">    DWORD ret = <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;OllyDBG.EXE&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;OllyICE.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;x64_dbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;windbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;ImmunityDebugger.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特征码检测"><a href="#特征码检测" class="headerlink" title="特征码检测"></a><strong>特征码检测</strong></h3><p>特征码检测枚举当前正在运行的进程，并在进程的内存空间中搜索特定调试器的代码片段。</p><p>例如 OllyDbg 有这样一段特征码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x41, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00,</span><br><span class="line">0x20, 0x00, 0x4f, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x79, 0x00,</span><br><span class="line">0x44, 0x00, 0x62, 0x00, 0x67, 0x00, 0x00, 0x00, 0x4f, 0x00,</span><br><span class="line">0x4b, 0x00, 0x00, 0x00</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;BYTE sign[] = &#123; <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x6f</span>, <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x79</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x44</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x4b</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>; &#125;</span><br><span class="line">    PROCESSENTRY32 sentry32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">    HANDLE phsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    Process32First(phsnap, &amp;sentry32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HANDLE hps = OpenProcess(MAXIMUM_ALLOWED, FALSE,</span><br><span class="line">            sentry32.th32ProcessID);</span><br><span class="line">        <span class="keyword">if</span> (hps != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD szReaded = <span class="number">0</span>;</span><br><span class="line">            BYTE signRemote[<span class="keyword">sizeof</span>(sign)];</span><br><span class="line">            ReadProcessMemory(hps, (LPCVOID)<span class="number">0x4f632a</span>, signRemote,</span><br><span class="line">                <span class="keyword">sizeof</span>(signRemote), &amp;szReaded);</span><br><span class="line">            <span class="keyword">if</span> (szReaded &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span>(sign, signRemote, <span class="keyword">sizeof</span>(sign)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    CloseHandle(phsnap);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">&#125;<span class="keyword">while</span> (Process32Next(phsnap, &amp;sentry32));</span><br></pre></td></tr></table></figure><h3 id="时间检测"><a href="#时间检测" class="headerlink" title="时间检测"></a><strong>时间检测</strong></h3><p>时间检测是指在程序中通过代码感知程序处于调试时与未处于调试时的各种运行时间差异来判断程序是否处于调试状态。</p><p>例如我们在调试时步过两条指令所花费的时间远远超过 CPU 正常执行花费的时间，于是就可以通过rdtsc 指令或 GetTickCount 函数来进行测试。</p><p>注： rdtsc 指令用于将时间标签计数器读入 EDX:EAX 寄存器。 GetTickCount 返回从操作系统动</p><p>所经过的毫秒数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        rdtsc</span><br><span class="line">        mov ecx, edx</span><br><span class="line">        rdtsc</span><br><span class="line">        sub edx, ecx</span><br><span class="line">        mov BeingDbg, edx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BeingDbg &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD time1 = GetTickCount();</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">        mov edx, <span class="number">6</span></span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD time2 = GetTickCount();</span><br><span class="line">    <span class="keyword">if</span> (time2 - time1 &gt; <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断点检测"><a href="#断点检测" class="headerlink" title="断点检测"></a><strong>断点检测</strong></h3><p>断点检测是根据调试器设置断点的原理来检测软件代码中是否设置了断点。调试器一般使用两者方法设置代码断点：</p><ul><li><p>通过修改代码指令为 INT3（机器码为0xCC）触发软件异常</p></li><li><p>通过硬件调试寄存器设置硬件断点</p></li></ul><p>针对软件断点，检测系统会扫描比较重要的代码区域，看是否存在多余的 INT3 指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS32 pNtHeaders;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">DWORD dwBaseImage = (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;</span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader -</span><br><span class="line">&gt; e_lfanew);</span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders +</span><br><span class="line"><span class="keyword">sizeof</span>(pNtHeaders-&gt;Signature) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +</span><br><span class="line">(WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;</span><br><span class="line">DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">BOOL Found = FALSE;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">cld</span><br><span class="line">mov edi, dwAddr</span><br><span class="line">mov ecx, dwCodeSize</span><br><span class="line">mov al, <span class="number">0</span>CCH</span><br><span class="line">repne scasb; 在EDI指向大小为ECX的缓冲区中搜索AL包含的字节</span><br><span class="line">jnz NotFound</span><br><span class="line">mov Found, <span class="number">1</span></span><br><span class="line">NotFound:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于硬件断点，由于程序工作在保护模式下，无法访问硬件调试断点，所以一般需要构建异常程序来获取 DR 寄存器的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">CONTEXT context;</span><br><span class="line">HANDLE hThread = GetCurrentThread();</span><br><span class="line">context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">GetThreadContext(hThread, &amp;context);</span><br><span class="line"><span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> ||</span><br><span class="line">context.Dr3 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他检测"><a href="#其他检测" class="headerlink" title="其他检测"></a><strong>其他检测</strong></h3><h4 id="判断父进程是否为-explorer-exe"><a href="#判断父进程是否为-explorer-exe" class="headerlink" title="判断父进程是否为 explorer.exe"></a><strong>判断父进程是否为</strong> <strong>explorer.exe</strong></h4><p>一般双击运行的进程的父进程都是 explorer.exe，但是如果进程被调试父进程则是调试器进程。也就是说如果父进程不是 explorer.exe 则可以认为程序正在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LONG status;</span><br><span class="line">    DWORD dwParentPID = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    PROCESS_BASIC_INFORMATION pbi;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PNTQUERYINFORMATIONPROCESS NtQueryInformationProcess =</span><br><span class="line">        (PNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandleA(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtQueryInf</span></span><br><span class="line"><span class="string">            ormationProcess&quot;</span>);</span><br><span class="line">            status = NtQueryInformationProcess(hProcess, SystemBasicInformation,</span><br><span class="line">                (PVOID)&amp;pbi, <span class="keyword">sizeof</span>(PROCESS_BASIC_INFORMATION), <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pbi.InheritedFromUniqueProcessId == pe32.th32ProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;explorer.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-STARTUPINFO"><a href="#测试-STARTUPINFO" class="headerlink" title="测试 STARTUPINFO"></a><strong>测试</strong> <strong>STARTUPINFO</strong></h4><p>在使用 CreateProcess 创建进程时,需要传递 STARTUPINFO 的结构体指针，而常常我们并不会一个一个设置其结构的值，连把其他不用的值清 0 都会忽略。</p><p>故可以使用 GetStartupInfo 检查启动信息，如果很多值不为 0，那么就说明自己的父进程不是explorer（explorer.exe 使用 shell32 中 ShellExecute 来运行程序， ShellExecute 会清掉不用的值）</p><p>所以可以利用 STARTUPINFO 结构体中不用的字段来判断程序是否在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">STARTUPINFO si;</span><br><span class="line">GetStartupInfo(&amp;si);</span><br><span class="line"><span class="keyword">if</span> (si.dwX != <span class="number">0</span> || si.dwY != <span class="number">0</span> || si.dwFillAttribute != <span class="number">0</span> || si.dwXSize != <span class="number">0</span> ||</span><br><span class="line">si.dwYSize != <span class="number">0</span> || si.dwXCountChars != <span class="number">0</span> || si.dwYCountChars != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于异常的反调试"><a href="#基于异常的反调试" class="headerlink" title="基于异常的反调试"></a><strong>基于异常的反调试</strong></h4><p>进程中发生异常时若 SEH 未处理或注册的 SEH 不存在，会调用 UnhandledExceptionFilter ，它会运行系统最后的异常处理器。 UnhandledExceptionFilter 内部调用了前面提到过的NtQueryInformationProcess 以判断进程是否正在被调试。</p><p>若进程未被调试，则运行最后的异常处理器。若进程处于调试状态，则将异常派送给调试器。</p><p>SetUnhandledExceptionFilter 函数可以修改系统最后的异常处理器。</p><h4 id="Debug-Block"><a href="#Debug-Block" class="headerlink" title="Debug Block"></a><strong>Debug Block</strong></h4><p>Debug Block 是指在需要保护的程序中，程序自身将一些只能同时有 1 个实例的功能占为己用。比如一般情况下，一个进程只能同时被 1 个调试器调试，那么就可以设计一种模式，将程序以调试方式启动，然后利用系统的调试机制防止被其他调试器调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;花指令-amp-反调试&quot;&gt;&lt;a href=&quot;#花指令-amp-反调试&quot; class=&quot;headerlink&quot; title=&quot;花指令&amp;amp;反调试&quot;&gt;&lt;/a&gt;花指令&amp;amp;反调试&lt;/h1&gt;&lt;p&gt;2024&amp;#x2F;01&amp;#x2F;17&lt;/p&gt;
&lt;p&gt;好，做道up</summary>
      
    
    
    
    
    <category term="花指令 逆向学习 反调试" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4-%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>寄网</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/18/%E7%AE%80%E5%8D%95%E5%AF%84%E7%BD%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/18/%E7%AE%80%E5%8D%95%E5%AF%84%E7%BD%91/</id>
    <published>2024-01-17T16:00:00.000Z</published>
    <updated>2024-01-19T09:06:48.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker网络模式Linux-Bridge-Host-None"><a href="#Docker网络模式Linux-Bridge-Host-None" class="headerlink" title="Docker网络模式Linux-Bridge|Host|None"></a>Docker网络模式Linux-Bridge|Host|None</h2><p> 如果假设Linux是宿主，有一个enp0s3的以太网接口，当有了docker后，会多一个docker0接口，这个docker0是默认Brigade网络的网关，容器的数据要出去需要经过docker0。</p><p>如果创建新的模式（eth0），会默认加入这个docker0网络里，此时docker0下面会多了一个附属的接口，并且通过veth的方式和容器的eth0接口进行连接，如果有新的容器也是会发生同样的事情，这个网络模式叫做Bridge；而“桥”就是docker0，veth可以想象为容器各自通往桥的路，正因为有docker0这座桥，容器里的数据才可以抵达宿主的enp0s3接口，也就是说容器是可以访问外部网络的。</p><p>在Bridge网络中，可以进行容器间、容器与宿主间，容器向互联网的访问，但是互联网-&gt;容器需要端口关联</p><table><thead><tr><th></th><th>默认Bridge</th><th>自定义Bridge</th><th>Host</th><th>None</th></tr></thead><tbody><tr><td>优点</td><td>自动加入</td><td>自动DNS隔离</td><td>网络性能佳</td><td>隔离</td></tr><tr><td>缺点</td><td>无自动DNS</td><td>NAT</td><td>安全问题<br />仅Linux</td><td>不能联网</td></tr><tr><td>场景</td><td>不建议</td><td>单宿主多容器</td><td>单容器多端口</td><td>备份<br />一次性操作</td></tr></tbody></table><h2 id="【虚拟机网络模式】NAT-NAT网络-桥接Bridged-内部网络Internal-仅主机-Host-Only"><a href="#【虚拟机网络模式】NAT-NAT网络-桥接Bridged-内部网络Internal-仅主机-Host-Only" class="headerlink" title="【虚拟机网络模式】NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)"></a>【虚拟机网络模式】NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)</h2><p>ping 的实质：发送一个icmp回显请求报文给目的的主机，并等待回显的icmp应答。然后打印出回显报文。</p><p>回显的结果包括：字节数  、 反应时间、TTL（生存时间）</p><p>Tracert 的实质：利用ICMP数据报和IP数据报头部中的TTL值。TTL（Time To Live）是一个IP数据报的生存时间，当每个IP数据报经过路由器的时候都回把TTL值减去1或者减去在路由器中停留的时间，但是大多数数据报在路由器中停留的时间都小于1秒种，因此实际上就是在TTL值减去了1。这样，TTL值就相当于一个路由器的计数器。<br>当路由器接收到一个TTL为0或者1的IP数据报的时候，路由器就不再转发这个数据了，而直接丢弃，并且发送一个ICMP“超时”信息给源主机。Tracert程序的关键就是这个回显的ICMP报文的IP报头的信源地址就是这个路由器的IP地址。同时，如果到达了目的主机，我们并不能知道，于是，Tracert还同时发送一个UDP信息给目的主机，并且选择一个很大的值作为UDP的端口，使主机的任何一个应用程序都不使用这个端口。所以，当达到目的主机的时候，UDP模块就产生一个“端口不可到达”的错误，这样就能判断是否是到达目的地了。</p><p>原文链接：<a href="https://blog.csdn.net/u013078669/article/details/48437559">https://blog.csdn.net/u013078669/article/details/48437559</a></p><p><a href="http://t.csdnimg.cn/tx3ql">http://t.csdnimg.cn/tx3ql</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker网络模式Linux-Bridge-Host-None&quot;&gt;&lt;a href=&quot;#Docker网络模式Linux-Bridge-Host-None&quot; class=&quot;headerlink&quot; title=&quot;Docker网络模式Linux-Bridge|Host|</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>常用命令/快捷方式</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/16/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/16/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</id>
    <published>2024-01-15T16:00:00.000Z</published>
    <updated>2024-01-19T13:45:23.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令-x2F-快捷方式"><a href="#常用命令-x2F-快捷方式" class="headerlink" title="常用命令&#x2F;快捷方式"></a>常用命令&#x2F;快捷方式</h1><h2 id="IDA："><a href="#IDA：" class="headerlink" title="IDA："></a>IDA：</h2><h3 id="静态调试"><a href="#静态调试" class="headerlink" title="静态调试"></a>静态调试</h3><p>交叉引用：X</p><p>地址跳转：G</p><p>书写注释：&#x2F;（伪代码） ；（反编译窗口）</p><p>修改符号名：N</p><p>数据类型操作：Y</p><p>修改数据长度：D</p><p>函数操作：  </p><ul><li>定义函数：P</li><li>删除函数：Delete&#x2F;U</li><li>修改函数范围：Ctrl+E（函数窗口） Alt+P（反汇编）</li></ul><p>代码与数据转换：</p><ul><li>U取消已有数据</li><li>D变成数据</li><li>C变成指令</li><li>A以该位置为起点定义一个以\0结尾的字符串类型</li><li>O将此处定义为一个地址偏移</li></ul><p>创建数组：* </p><p>创建结构体：Shift+f1–local types–insert</p><p>提取数据：shift+E</p><p>函数调用图：View–Graphs–Function calls</p><p>常数搜索：Alt+I</p><p>Patch：Edit -&gt; Patch program -&gt; Change byte</p><p>要永久 Patch， Edit -&gt; Patch program -&gt; Apply patches to input file</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>选择 Debugger -&gt; Select debugger，选择合适的调试器：</p><p>如果是 exe，可以使用 Local Windows Debugger</p><p>如果是 ELF， 则选择 Remote Linux Debugger</p><p>选择 Debuugger -&gt; Start Process 或者按 F9 开始调试。</p><ul><li>继续运行：F9</li><li>单步步入：F7</li><li>单步步过：F8</li><li>执行到返回：Ctrl +F7</li><li>执行到光标处：F4</li><li>添加、删除断点：F2</li></ul><p>Ctrl+Alt+B 打开断点列表</p><p>Ctrl+E 进行编辑</p><p>F2改内存数据</p><p>选择了调试器之后，打开 Debugger -&gt; Process options，在 Parameters 一栏写入命令行参数即可。</p><h2 id="x96dbg"><a href="#x96dbg" class="headerlink" title="x96dbg"></a>x96dbg</h2><h3 id="常用调试快捷键："><a href="#常用调试快捷键：" class="headerlink" title="常用调试快捷键："></a>常用调试快捷键：</h3><ul><li>F4：运行到光标</li><li>F7：单步步入</li><li>F8：单步步过</li><li>F9：运行程序</li><li>Ctrl+F9：执行到函数返回处</li></ul><h2 id="UPX工具壳"><a href="#UPX工具壳" class="headerlink" title="UPX工具壳"></a>UPX工具壳</h2><p>加壳upx -o packed.exe xxx.exe</p><p>脱壳upx -d xxx.exe</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令-x2F-快捷方式&quot;&gt;&lt;a href=&quot;#常用命令-x2F-快捷方式&quot; class=&quot;headerlink&quot; title=&quot;常用命令&amp;#x2F;快捷方式&quot;&gt;&lt;/a&gt;常用命令&amp;#x2F;快捷方式&lt;/h1&gt;&lt;h2 id=&quot;IDA：&quot;&gt;&lt;a href=&quot;#IDA</summary>
      
    
    
    
    
    <category term="命令 快捷" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E5%91%BD%E4%BB%A4-%E5%BF%AB%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>2024寒假MISC小记录_更0122</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/2024%E5%AF%92%E5%81%87MISC%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/2024%E5%AF%92%E5%81%87MISC%E5%B0%8F%E8%AE%B0%E5%BD%95/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-01-23T17:46:31.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MISCMISC！"><a href="#MISCMISC！" class="headerlink" title="MISCMISC！"></a>MISCMISC！</h1><h2 id="2024-x2F-01-x2F-14"><a href="#2024-x2F-01-x2F-14" class="headerlink" title="2024&#x2F;01&#x2F;14"></a>2024&#x2F;01&#x2F;14</h2><h3 id="签到喵："><a href="#签到喵：" class="headerlink" title="签到喵："></a>签到喵：</h3><p>python库函数，喵语</p><h3 id="加密-A-宽宽-S-00-E："><a href="#加密-A-宽宽-S-00-E：" class="headerlink" title="加密 A 宽宽 S 00 E："></a>加密 A 宽宽 S 00 E：</h3><p>零宽字节，ASE加密 </p><h3 id="是uu吗："><a href="#是uu吗：" class="headerlink" title="是uu吗："></a>是uu吗：</h3><p>uuencode，steghide （感觉这几个隐写工具都得筛一次啊（悲</p><h3 id="机密："><a href="#机密：" class="headerlink" title="机密："></a>机密：</h3><p>文件隐藏，爆破 </p><h3 id="EZ签到："><a href="#EZ签到：" class="headerlink" title="EZ签到："></a>EZ签到：</h3><p>伪加密，imagemagick，gaps，f5加密，base家族 （ez））</p><h3 id="社会主义好："><a href="#社会主义好：" class="headerlink" title="社会主义好："></a>社会主义好：</h3><p>核心价值观解码，rabbit解码</p><h2 id="2024-x2F-01-x2F-15"><a href="#2024-x2F-01-x2F-15" class="headerlink" title="2024&#x2F;01&#x2F;15"></a>2024&#x2F;01&#x2F;15</h2><h3 id="签到（web混入）"><a href="#签到（web混入）" class="headerlink" title="签到（web混入）"></a>签到（web混入）</h3><p><strong>元素反应</strong></p><p>看到提交按钮不能用，先把元素里的disabled变成abled点击试试，弹框：</p><blockquote><p>小火汁提交“ilovejljcxy”就能的到flag了啊</p></blockquote><p>输入框只能输入9位，改成11位，提交”ilovejljcxy“，得到flag</p><h3 id="签到题（web再混入）"><a href="#签到题（web再混入）" class="headerlink" title="签到题（web再混入）"></a>签到题（web再混入）</h3><p><strong>cookie 绕过</strong></p><p>看cookie，didi&#x3D;no，用Editthiscookie插件改一下yes，刷新得</p><p>Li9kYXRhL2luZGV4LnBocA（补全&#x3D;&#x3D;后）解密.&#x2F;data&#x2F;index.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    $file = $_GET[&#x27;file&#x27;];</span><br><span class="line">    if(!isset($file))</span><br><span class="line">        $file = &#x27;1&#x27;;</span><br><span class="line">    $file = str_replace(&#x27;../&#x27;, &#x27;&#x27;, $file);</span><br><span class="line">    include_once($file.&quot;.php&quot;);</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>绕过-&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=..././..././..././..././flag</span><br></pre></td></tr></table></figure><p>PD9waHANCiAgICAkZmxhZyA9ICJmbGFnezkyZWI1ZmZlZTZhZTJmZWMzYWQ3MWM3Nzc1MzE1NzhmfSI7DQo&#x2F;Pg&#x3D;&#x3D;（base64）解密：</p><p>flag{92eb5ffee6ae2fec3ad71c777531578f}</p><h3 id="0和255"><a href="#0和255" class="headerlink" title="0和255"></a>0和255</h3><p><strong>程序逆向</strong> </p><p>小小的程序逆向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding = utf-8 -*-</span><br><span class="line"># @software:PyCharm</span><br><span class="line">from PIL import Image</span><br><span class="line">image = Image.open(&#x27;flag.png&#x27;)   #flag.png分辨率为33*33</span><br><span class="line">width = image.width</span><br><span class="line">height = image.height</span><br><span class="line">image_list = []</span><br><span class="line">for x in range(height):</span><br><span class="line">    scanline_list = []</span><br><span class="line">    for y in range(width):</span><br><span class="line">        pixel = image.getpixel((y, x))</span><br><span class="line">        scanline_list.append(pixel)</span><br><span class="line">    image_list.append(scanline_list)</span><br><span class="line">print(image_list)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding = utf-8 -*-</span><br><span class="line"># @software:PyCharm</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image_list =[...]</span><br><span class="line">width = len(image_list[0])</span><br><span class="line">height = len(image_list)</span><br><span class="line">new_image = Image.new(&#x27;RGB&#x27;, (width, height))</span><br><span class="line">for x in range(height):</span><br><span class="line">    for y in range(width):</span><br><span class="line">        pixel = image_list[x][y]</span><br><span class="line">        new_image.putpixel((y, x), pixel)</span><br><span class="line"></span><br><span class="line">new_image.save(&#x27;flag.png&#x27;)</span><br></pre></td></tr></table></figure><p>扫出来：Polar_Night</p><p>得到字符串MD5加密套上flag</p><h2 id="2024-x2F-01-x2F-16"><a href="#2024-x2F-01-x2F-16" class="headerlink" title="2024&#x2F;01&#x2F;16"></a>2024&#x2F;01&#x2F;16</h2><h3 id="docx隐写"><a href="#docx隐写" class="headerlink" title="docx隐写"></a>docx隐写</h3><p><strong>docx 隐写</strong></p><blockquote><p><code>docx</code>隐写的主要考察方式有：</p><p>​1.docx文件的本质是压缩包，其内可存储文件。</p><p>​2.docx内将文字颜色改透明实现隐藏。</p><p>​3.<code>office</code>和<code>wps</code>均支持<code>docx</code>文件的隐藏文字功能，通过设置可以看到隐藏的文字。</p></blockquote><p>猜到了1、2，但是没找到3</p><p>蛮好玩的。</p><h3 id="超级简单的流量"><a href="#超级简单的流量" class="headerlink" title="超级简单的流量"></a>超级简单的流量</h3><p>确实简单—追踪tcp流–<code>tcp.stream eq 2</code></p><h3 id="100RGB"><a href="#100RGB" class="headerlink" title="100RGB"></a>100RGB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">🐯🐩🐣🐮🐨🐣🐭🐭</span><br><span class="line">🐨🐧🐩🐣🐨🐧🐯🐣🐰🐮</span><br><span class="line">🐨🐧🐪🐣🐨🐩🐪🐣🐭🐬</span><br><span class="line">🐨🐨🐧🐣🐫🐰🐣🐨🐧🐰</span><br><span class="line">🐰🐮🐣🐫🐰🐣🐨🐨🐬</span><br><span class="line">🐪🐩🐣🐰🐬🐣🐰🐮</span><br><span class="line"> 🐨🐨🐫🐣🐬🐨🐣🐰🐬</span><br><span class="line">🐰🐰🐣🐨🐨🐮🐣🐫🐪</span><br><span class="line">🐨🐧🐨🐣🐨🐩🐬🐣🐧</span><br></pre></td></tr></table></figure><p>..我懂了，base100啊。base100是emoji加密</p><p>记得删除换行。</p><p>然后就是ascii解密（16进制</p><p>……</p><p>后面写了几道蚌埠住了，去画画了嘿嘿</p><h2 id="2024-x2F-01-x2F-17"><a href="#2024-x2F-01-x2F-17" class="headerlink" title="2024&#x2F;01&#x2F;17"></a>2024&#x2F;01&#x2F;17</h2><p>ctfshow做了几道（突然发现的小题库（好玩（（欸嘿</p><h3 id="杂项签到"><a href="#杂项签到" class="headerlink" title="杂项签到"></a>杂项签到</h3><p>直接拖winhex</p><h3 id="损坏的压缩包"><a href="#损坏的压缩包" class="headerlink" title="损坏的压缩包"></a>损坏的压缩包</h3><p>拖winhex–png–改了后缀–flag</p><h2 id="2024-x2F-01-x2F-19"><a href="#2024-x2F-01-x2F-19" class="headerlink" title="2024&#x2F;01&#x2F;19"></a>2024&#x2F;01&#x2F;19</h2><p>?做的题又没记录？</p><p>好像是什么。</p><h3 id="迷之栅栏"><a href="#迷之栅栏" class="headerlink" title="迷之栅栏"></a>迷之栅栏</h3><p><a href="http://t.csdnimg.cn/BtcMt">这里放个破解010的过程，有时间读读</a></p><p>使用010editor的文件比较功能找到两张图片的十六进制不同点，按顺序互相取一位数或者栅栏2位解得flag</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121000329395.png" alt="image-20240121000329395"></p><h3 id="你会数数吗"><a href="#你会数数吗" class="headerlink" title="你会数数吗"></a>你会数数吗</h3><p>使用010editor的 工具→直方图 统计计数解得flag，或者复制出来词频统计</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121000544233.png" alt="image-20240121000544233"></p><h2 id="2024-x2F-01-x2F-20"><a href="#2024-x2F-01-x2F-20" class="headerlink" title="2024&#x2F;01&#x2F;20"></a>2024&#x2F;01&#x2F;20</h2><h3 id="你会异或吗"><a href="#你会异或吗" class="headerlink" title="你会异或吗"></a>你会异或吗</h3><p>图片16进制0x50异或</p><h3 id="flag一分为二"><a href="#flag一分为二" class="headerlink" title="flag一分为二"></a>flag一分为二</h3><p>前半watermark，后半改高度</p><h3 id="打不开的图"><a href="#打不开的图" class="headerlink" title="打不开的图"></a>打不开的图</h3><p>png文件开头应该是89 50 4E 47，观察下题目给的png的开头是77 B0 B2 B9，会发现0x89+0x77&#x3D;0x100, 0x50+0xB0&#x3D;0x100, 0x4E+0xB2&#x3D;0x100, 0x47+0xB9&#x3D;0x100, 所以，只要用0x100减去现在png文件中的每个字节的16进制数即可恢复出可以预览的png图片。<br>但是要注意这里还有一个小坑，就是0x100是十进制数的256，而bytes格式最大只能表示到255，出现256会报错，所以题目原png文件中是0的位置，还是0，不能用0x100去减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ff=<span class="built_in">open</span>(<span class="string">&#x27;./misc5.5.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data=ff.read()</span><br><span class="line">l=[]</span><br><span class="line"><span class="keyword">for</span> dd <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> dd==<span class="number">0</span>:</span><br><span class="line">        l.append(dd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l.append(<span class="number">0x100</span>-dd) </span><br><span class="line">ff=<span class="built_in">open</span>(<span class="string">&#x27;./1234.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="comment">#会新建一个可写入的新文件1234.png</span></span><br><span class="line">ff.write(<span class="built_in">bytes</span>(l))</span><br><span class="line">ff.close()</span><br></pre></td></tr></table></figure><h2 id="2024-x2F-01-x2F-21"><a href="#2024-x2F-01-x2F-21" class="headerlink" title="2024&#x2F;01&#x2F;21"></a>2024&#x2F;01&#x2F;21</h2><h3 id="黑丝白丝还有什么丝？"><a href="#黑丝白丝还有什么丝？" class="headerlink" title="黑丝白丝还有什么丝？"></a>黑丝白丝还有什么丝？</h3><p>莫斯密码，白丝·，黑丝_，转场是空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.-- ....- -. - - ----- -... ...-- -- --- .-. . -.-. ..- - .</span><br></pre></td></tr></table></figure><h3 id="我吐了你随意"><a href="#我吐了你随意" class="headerlink" title="我吐了你随意"></a>我吐了你随意</h3><p>好题目。<a href="http://330k.github.io/misc_tools/unicode_steganography.html">零宽解密</a></p><h3 id="迅疾响应"><a href="#迅疾响应" class="headerlink" title="迅疾响应"></a>迅疾响应</h3><p>一道二维码题目，得学学了。。—&gt;<a href="http://t.csdnimg.cn/hNYjT">http://t.csdnimg.cn/hNYjT</a></p><p><a href="https://www.cnblogs.com/SanCai-Newbie/p/16979691.html">他写的好好。</a></p><p><a href="https://merri.cx/qrazybox/">QRazyBox</a></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240121223704858.png" alt="image-20240121223704858"></p><h3 id="You-and-me"><a href="#You-and-me" class="headerlink" title="You and me"></a>You and me</h3><p>盲水印，使用工具 BlindWaterMark-master</p><p>python3 bwmforpy3.py decode you.png you_and_me.png wm2.png</p><p><a href="https://ctf-show.feishu.cn/docx/UpC6dtDqgo7VuoxXlcvcLwzKnqh">https://ctf-show.feishu.cn/docx/UpC6dtDqgo7VuoxXlcvcLwzKnqh</a></p><h2 id="20240122"><a href="#20240122" class="headerlink" title="20240122"></a>20240122</h2><p>两个图片题，好像直接扔识图里就ok</p><p>还有一个re</p><p>简单rc4加密，密钥是DH<del>mqqvqxB^||zll@Jq</del>jkwpmvez{</p><p>密文：Ã‚£%öL6;YÌÄéñµ2±–®¿5</p><p>不想写了，chatpy</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_with_0x1F</span>(<span class="params">input_str</span>):</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> input_str:</span><br><span class="line">        <span class="comment"># 将每个字符与0x1F进行异或操作</span></span><br><span class="line">        xored_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="number">0x1F</span>)</span><br><span class="line">        result += xored_char</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">input_string = <span class="string">&quot;DH~mqqvqxB^||zll@Jq~jkwpmvez&#123;&quot;</span></span><br><span class="line">output_string = xor_with_0x1F(input_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入字符串:&quot;</span>, input_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异或操作后的字符串:&quot;</span>, output_string)</span><br></pre></td></tr></table></figure><h2 id="20240123"><a href="#20240123" class="headerlink" title="20240123"></a>20240123</h2><h3 id="crypto签到"><a href="#crypto签到" class="headerlink" title="crypto签到"></a>crypto签到</h3><p>63746673686f777b77656c636f6d655f325f636169676f755f6375707d</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;63746673686f777b77656c636f6d655f325f636169676f755f6375707d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.decode())</span><br></pre></td></tr></table></figure><p>16进制是ascii</p><h3 id="crypto签到2"><a href="#crypto签到2" class="headerlink" title="crypto签到2"></a>crypto签到2</h3><p>Ao(mgHX^E)AN2PSBOu3qI0o</p><p>wp：</p><p><strong>Ao(mg</strong>就是flag用base85编码之后的表示形式<br> base85还有各式各样的编码表。。这是ASCII</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">a=<span class="string">&quot;Ao(mgHX^E)AN2PSBOu3qI0o&quot;</span></span><br><span class="line">a=base64.a85decode(a).decode()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h3 id="Caesar"><a href="#Caesar" class="headerlink" title="Caesar"></a>Caesar</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Zhofrph wr FWIvkrz yhjhwdeoh grj fxs!</span><br></pre></td></tr></table></figure><p>#3 Welcome to CTFshow vegetable dog cup!</p><h3 id="0x36d"><a href="#0x36d" class="headerlink" title="0x36d"></a>0x36d</h3><p>密文： 😫🙄👰😰👣🙋😱👧👌👷👯👩😴👖👫👚🙃👹👏👏😶👳😫👕🙂🙊👵👶👨👰👮🙉👶👵👸👲👺👮👑😶👴😫🙊👫😴👬👹👤👑😱👗🙃👐😶 提示： 有没有一种可能，标题就是密码？</p><p>wp：熟悉的emoji解密，但是，，0x36d不行，换成877</p><h3 id="类型-7"><a href="#类型-7" class="headerlink" title="类型-7"></a>类型-7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">094F5A0F0A0D1805103B0B3D143117183B720438350A45550967674D1E064F2969784440455A460F1A1B</span><br></pre></td></tr></table></figure><p>ctfshow{Wow_u_Kn0w_Ci$c0_Type7_P@ssword!}</p><h3 id="base47"><a href="#base47" class="headerlink" title="base47"></a>base47</h3><p><a href="https://www.cnblogs.com/Guanz/p/17909958.html">写的很好</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"> </span><br><span class="line">ciper = <span class="string">&#x27;E9CV^T+HT5#X36RF4@LAU703+F$E-0N$@68LMXCVDRJJD5@MP#7MUZDTE?WWLG1S#L@+^66H@59KTWYK8TW0RV&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;0123456789ABCDEFGHJKLMNPQRSTUVWXYZ?!@#$%^&amp;*-+&#x27;</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">0</span>  <span class="comment"># 密文转十进制数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciper)):</span><br><span class="line">    p = key.index(ciper[i])  <span class="comment"># 找到每个密文字符对应字典的下标</span></span><br><span class="line">    num += p * (<span class="built_in">len</span>(key) ** (<span class="built_in">len</span>(ciper) - i - <span class="number">1</span>))  <span class="comment"># 45进制转十进制后求和</span></span><br><span class="line"> </span><br><span class="line">s = libnum.n2s(num)  <span class="comment"># 十进制数转字符串 ascii码表 256进制</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="PWN签到题"><a href="#PWN签到题" class="headerlink" title="PWN签到题"></a>PWN签到题</h3><p>欸嘿 nc过去就是</p><h3 id="PWN02"><a href="#PWN02" class="headerlink" title="PWN02"></a>PWN02</h3><p><a href="http://t.csdnimg.cn/GMR5G">http://t.csdnimg.cn/GMR5G</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MISCMISC！&quot;&gt;&lt;a href=&quot;#MISCMISC！&quot; class=&quot;headerlink&quot; title=&quot;MISCMISC！&quot;&gt;&lt;/a&gt;MISCMISC！&lt;/h1&gt;&lt;h2 id=&quot;2024-x2F-01-x2F-14&quot;&gt;&lt;a href=&quot;#2024-x2</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>修电脑杂记</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/%E4%BF%AE%E7%94%B5%E8%84%91%E6%9D%82%E8%AE%B0(win/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/15/%E4%BF%AE%E7%94%B5%E8%84%91%E6%9D%82%E8%AE%B0(win/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-01-21T02:34:41.369Z</updated>
    
    <content type="html"><![CDATA[<p>2024&#x2F;1&#x2F;14</p><h2 id="嘿嘿早上把家里的电脑修好了"><a href="#嘿嘿早上把家里的电脑修好了" class="headerlink" title="嘿嘿早上把家里的电脑修好了"></a>嘿嘿早上把家里的电脑修好了</h2><p>问题：ntfs.sys丢失或损坏蓝屏<br>原因：U盘在开机前启动，导致win7系统没起来，系统文件被修改了<br>解决：命令行：<code>chkdsk C: /f /r</code> ,然后<code>Y</code>，重启后修复就ok了</p><p>修改磁盘大小</p><p><a href="https://support.microsoft.com/zh-cn/topic/microsoft-%E6%94%AF%E6%8C%81-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%94%80%E6%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%8D%E6%96%B0%E5%88%86%E5%8C%BA-c3d64de0-4672-b21f-de4e-b4908fb35ae3">官方win7修改磁盘分区方法</a><br>差不多，还好要删除的F盘在C盘右侧，直接删除F盘，C盘扩展就ok了</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>Domain Name System</p><p>DNS服务器</p><p>2.4GHz频段具备强大的穿墙能力和广阔的覆盖范围，而5GHz频段则更注重速度和稳定性。</p><p>2024&#x2F;01&#x2F;20</p><h2 id="win7系统ip地址冲突"><a href="#win7系统ip地址冲突" class="headerlink" title="win7系统ip地址冲突"></a>win7系统ip地址冲突</h2><p>当同一网络上的两台或多台设备分配了相同的IP地址时，就会发生IP地址冲突</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">ipconfig</span>/release</span><br><span class="line">&gt;<span class="built_in">ipconfig</span>/renew</span><br></pre></td></tr></table></figure><h2 id="win7防火墙0x80070422问题"><a href="#win7防火墙0x80070422问题" class="headerlink" title="win7防火墙0x80070422问题"></a>win7防火墙0x80070422问题</h2><p>win+r–services.msc–windows firewall–启动类型为手动，应用后服务状态改启动，ok了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2024&amp;#x2F;1&amp;#x2F;14&lt;/p&gt;
&lt;h2 id=&quot;嘿嘿早上把家里的电脑修好了&quot;&gt;&lt;a href=&quot;#嘿嘿早上把家里的电脑修好了&quot; class=&quot;headerlink&quot; title=&quot;嘿嘿早上把家里的电脑修好了&quot;&gt;&lt;/a&gt;嘿嘿早上把家里的电脑修好了&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>20240114&amp;15&amp;16</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/14/20240114-15-16_%E5%A3%B3/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/14/20240114-15-16_%E5%A3%B3/</id>
    <published>2024-01-13T16:00:00.000Z</published>
    <updated>2024-01-18T06:16:44.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习x32dbg，x64dbg使用方法"><a href="#学习x32dbg，x64dbg使用方法" class="headerlink" title="学习x32dbg，x64dbg使用方法"></a>学习x32dbg，x64dbg使用方法</h1><h2 id="x64dbg工具使用"><a href="#x64dbg工具使用" class="headerlink" title="x64dbg工具使用"></a>x64dbg工具使用</h2><h3 id="常用调试快捷键："><a href="#常用调试快捷键：" class="headerlink" title="常用调试快捷键："></a>常用调试快捷键：</h3><ul><li>F4：运行到光标</li><li>F7：单步步入</li><li>F8：单步步过</li><li>F9：运行程序</li><li>Ctrl+F9：执行到函数返回处</li></ul><h2 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h2><p>常见压缩壳：upx，ASpack，PECompat<br>常见加密壳：ASProtector，Armadillo，EXECryptor，Themida，VMProtect</p><p>保存入口参数，通常用pushed&#x2F;popad、pushfd&#x2F;popfd指令对来保存喝回复现场环境</p><h3 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a><strong>壳的加载过程</strong></h3><h5 id="保存入口参数"><a href="#保存入口参数" class="headerlink" title="保存入口参数"></a><strong>保存入口参数</strong></h5><ol><li><p>加壳程序初始化时保存各寄存器的值</p></li><li><p>外壳执行完毕，恢复各寄存器值</p></li><li><p>最后再跳到原程序执行</p></li></ol><p>通常用 pushad &#x2F; popad 、 pushfd &#x2F; popfd 指令对来保存和恢复现场环境</p><h5 id="获取所需函数-API"><a href="#获取所需函数-API" class="headerlink" title="获取所需函数 API"></a><strong>获取所需函数</strong> <strong>API</strong></h5><ol><li><p>一般壳的输入表中只有 GetProcAddress 、 GetModuleHandle 和 LoadLibrary 这几个 API 函数</p></li><li><p>如果需要其他 API 函数，则通过 LoadLibraryA(W) 或 LoadLibraryExA(W) 将 DLL 文件映射到调用进程的地址空间中</p></li><li><p>如果 DLL 文件已被映射到调用进程的地址空间里，就可以调用 GetModuleHandleA(W) 函数获得DLL 模块句柄 </p></li><li><p>一旦 DLL 模块被加载，就可以调用 GetProcAddress 函数获取输入函数的地址</p></li></ol><h5 id="解密各区块数据"><a href="#解密各区块数据" class="headerlink" title="解密各区块数据"></a><strong>解密各区块数据</strong></h5><ol><li><p>处于保护源程序代码和数据的目的，一般会加密源程序文件的各个区块。在程序执行时外壳将这些区块数据解密，以让程序正常运行</p></li><li><p>外壳一般按区块加密，按区块解密，并将解密的数据放回在合适的内存位置</p></li></ol><h5 id="跳转回原程序入口点"><a href="#跳转回原程序入口点" class="headerlink" title="跳转回原程序入口点"></a><strong>跳转回原程序入口点</strong></h5><ol><li><p>在跳转回入口点之前，一般会恢复填写原 PE 文件输入表（IAT），并处理好重定位项（主要是DLL 文件）</p></li><li><p>因为加壳时外壳自己构造了一个输入表，因此在这里需要重新对每一个 DLL 引入的所有函数重新获取地址，并填写到 IAT 表中3. 做完上述工作后，会将控制权移交原程序，并继续执行</p></li></ol><p>*《程序员的自我修养》</p><h3 id="脱壳方法论"><a href="#脱壳方法论" class="headerlink" title="脱壳方法论"></a><strong>脱壳方法论</strong></h3><p>如今脱壳主要分为两种方式，第一种方式是：</p><h4 id="工具脱壳"><a href="#工具脱壳" class="headerlink" title="工具脱壳"></a><strong>工具脱壳</strong></h4><p>所谓脱壳机是针对特定的一种或一类壳开发出来的脱壳软件，它们是由他人在逆向完壳的相关原理后编写的一类自动化工具，具有一定的局限性。</p><p>对于无法使用工具成功脱壳的情况，便需要用到第二种方式：</p><h4 id="手动脱壳（手脱）"><a href="#手动脱壳（手脱）" class="headerlink" title="手动脱壳（手脱）"></a><strong>手动脱壳（手脱）</strong></h4><p>也就是通过一步步分析程序加壳原理，手动还原原始程序的过程，通过手动脱壳，我们可以加深对 PE 格式的理解，增长自己的脱壳水平。在手脱的过程中，我们一般会涉及如下几个概念：</p><ol><li><strong>查壳</strong>。遇到一个加壳程序，第一步应该去分析这是一个什么壳保护的程序，之后我们才能更加有针对性地进行分析与跟踪，遇到难以处理的问题也可以更方便地利用搜索引擎检索同类壳的技术贴。</li></ol><p>常用的查壳工具有 PEiD、Exeinfo PE、DIE 等。</p><ol start="2"><li><p><strong>寻找程序的原入口点（OEP）</strong>。通过单步跟踪、ESP 定律、内存断点等方法找到 OEP。</p></li><li><p><strong>Dump</strong> <strong>内存</strong>。所谓 Dump 内存，指的是将一个进程的内存镜像通过某种方式抓取下来，保存至本地磁盘中，之所以需要 Dump 内存，是因为<strong>在程序执行到</strong> <strong>OEP</strong> <strong>时，内存的状态往往就与未加壳前****的程序相同</strong>（因为壳段代码已经帮我们完成了解密、解压等工作），此时我们将这个状态保存出去，再加上一些后期的修复，就能完成整个脱壳操作了。</p></li><li><p><strong>输入表（IAT）重建</strong>。在 Dump 操作结束之后，程序并不能直接运行，很大程度上是因为输入表并没有被修复好。IAT 可以根据 PE 结构手动修复，也可以通过工具完成。</p></li><li><p><strong>关闭程序重定位</strong>。</p></li></ol><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h4><ul><li>查壳</li><li>识别函数少</li><li>Ctrl-s 段名UPX*</li></ul><h3 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h3><p>手工脱壳:hw1.exe</p><h4 id="寻找OEP-ESP定律-（好用）"><a href="#寻找OEP-ESP定律-（好用）" class="headerlink" title="寻找OEP(ESP定律)（好用）"></a>寻找OEP(ESP定律)（好用）</h4><p>原理利用程序中堆栈平衡来快速寻找OEP</p><h4 id="去重定位"><a href="#去重定位" class="headerlink" title="去重定位"></a>去重定位</h4><p>用CFF小辣椒或者010都可以</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习x32dbg，x64dbg使用方法&quot;&gt;&lt;a href=&quot;#学习x32dbg，x64dbg使用方法&quot; class=&quot;headerlink&quot; title=&quot;学习x32dbg，x64dbg使用方法&quot;&gt;&lt;/a&gt;学习x32dbg，x64dbg使用方法&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="逆向学习 UPX壳" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-UPX%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>操作系统_文件管理专题</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T16:00:00.000Z</published>
    <updated>2024-01-14T14:47:01.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件管理习题"><a href="#文件管理习题" class="headerlink" title="文件管理习题"></a><strong>文件管理习题</strong></h1><p><strong>共三个习题：</strong><br>进程管理、内存管理、文件管理</p><h2 id="一、-单项选择题"><a href="#一、-单项选择题" class="headerlink" title="一、 单项选择题"></a>一、 单项选择题</h2><p>1、下列选项中，用于提高RAID可靠性的措施有 <strong>B</strong></p><p>I.磁盘镜像 II.条带化 III. 奇偶校验 IV.增加Cache机制</p><p>A.仅I、II B.仅I、IIIC.仅I、III和IV D.仅II、III和IV</p><p><strong>&#x2F;&#x2F;提高RAID可靠性措施：eg：RAID0磁盘镜像，RAID5奇偶校验</strong></p><p><a href="http://t.csdnimg.cn/Y2JQw">RAID（磁盘阵列）学习参考</a></p><p>顺便学一下：（可用容量）<br><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227232806438.png" alt="image-20231227232806438"></p><p>2、某磁盘的转速为10000转&#x2F;分，平均寻道时间是6 ms，磁盘传输速率是20 MB&#x2F;s，磁盘控制器延迟为0.2 ms，读取一个4 KB的扇区所需的平均时间约为 <strong>B</strong></p><p>A. 9 ms B. 9.4 ms C. 12 ms D. 12.4 ms</p><p><strong>&#x2F;&#x2F; 平均时间为 9.4ms。</strong></p><p><strong>第一部分 找到磁道的时间 &#x3D; 平均寻道时间&#x3D; 6ms</strong></p><p><strong>第二部分 找到扇区的时间 &#x3D; 磁盘转一圈的时间÷2（平均）&#x3D;（60 秒）&#x2F;（2*10000 转&#x2F;分）&#x3D;3ms</strong></p><p><strong>第三部分 磁盘控制器延迟时间 &#x3D; 0.2ms</strong></p><p><strong>第四部分 数据传输时间 &#x3D; 传输字节数 &#x2F; 磁盘传输速度 &#x3D; 4K &#x2F; 20M &#x3D; 0.2ms（1K≈10 的 3 次方）</strong></p><p><strong>综上 6ms+3ms+0.2ms+0.2ms&#x3D;9.4ms。</strong></p><p>3、用户在删除某文件的过程中，操作系统不可能执行的操作是  <strong>A</strong></p><p>A.删除此文件所在的目录 B.删除与此文件关联的目录项</p><p>C.删除与此文件对应的文件控制块 D.释放与此文件关联的内存缓冲区</p><p><strong>&#x2F;&#x2F;删除此文件所在的目录</strong>（要是我删文件，连该文件目录也删了那太过分了吧啊喂！！！</p><p>4、为支持CD-ROM中视频文件的快速随机播放，播放性能最好的文件数据块组织方式是 <strong>A</strong></p><p>A.连续结构 B.链式结构 </p><p>C.直接索引结构 D.多级索引结构</p><p><strong>&#x2F;&#x2F;虽然是随机播放，但毕竟还是读取文件，播放性能好-&gt;内存离得近-&gt;连续结构</strong></p><p>5、若某文件系统索引结点（inode）中有直接地址项和间接地址项，则下列选项中，与单个文件长度无关的因素是 <strong>A</strong></p><p>A.索引结点的总数 B.间接地址索引的级数 C.地址项的个数 D.文件块大小</p><p><strong>&#x2F;&#x2F;与文件长度无关-&gt;索引结点的总数，怎么索引与文件无关</strong></p><p>6、设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是  <strong>C</strong></p><p>A. 3 B. 75 C. 80 D. 63</p><p><strong>&#x2F;&#x2F;文件大小512B，第1569字节在第1569&#x2F;512&#x3D;3.06-&gt;第四页，顺序在题目上，为80</strong></p><p>7、文件系统采用两级索引分配方式。如果每个磁盘块的大小为 1KB，每个盘块号占 4B，则该系统中单个文件的最大长度是 <strong>B</strong></p><p>A. 32MB B. 64MB C. 128MB D. 256MB</p><p>**&#x2F;&#x2F;单个文件最大长度：被两级索引：[(1KB&#x2F;4B)^2]<em>4B&#x3D;64MB</em>*</p><p>8、一个磁盘的转速为 7200 转&#x2F;分，每个磁道有 160 个扇区，每个扇区为 512B，那么理想情况下，其数据传输率为  <strong>C</strong></p><p>A. 576000KB&#x2F;s B. 7200KB&#x2F;s C. 9600KB&#x2F;s D. 19200KB&#x2F;s</p><p><strong>&#x2F;&#x2F;的转速为 7200r&#x2F;min&#x3D;120r&#x2F;s，转一圈经过 160 个扇区，每个扇区有 512B 所以数据传输率为 120×160×512&#x2F;1024&#x3D;9600KB&#x2F;s。</strong>  </p><p>9、现有容量为10GB的磁盘分区，磁盘空间以簇（cluster）为单位进行分配，簇的大小为4KB。若采用位图法管理该分区的空闲空间，即用一位（bit）标识一个簇是否被分配，则存放该位图所需要簇的个数为： <strong>A</strong></p><p>A. 80 B. 320 C. 80K D. 320K </p><p><strong>&#x2F;&#x2F;10GB&#x2F;4KB&#x3D;2.5M，共有2.5M个可分配的簇， 2.5M&#x2F;8&#x3D;320KB，需要320K的字节来标记可分配的簇， 320KB&#x2F;4KB&#x3D;80个，这320KB同样是按4KB一簇在硬盘上存储，所以需要除4K，得80个簇</strong></p><p>10、 某磁盘阵列中包含 15 块 SAS 硬盘，单一硬盘的容量为 1TB。采用 RAID技术提供具备高可靠性和高可用性的数据存储方案。使用 4 块硬盘组成一个RAID10 硬盘组，8 块硬盘组成一个 RAID 5 硬盘组，3 块硬盘作为热备份硬盘。此磁盘阵列的总可用空间约为 <strong>B</strong></p><p> A. 8TB B. 9TB C. 10TB D.11TB</p><p><strong>&#x2F;&#x2F;1题要记得那个表的最后一行，一一对应，RAID10-一半，2TB；RAID5一个-8-1&#x3D;7TB，3个热备份不算，共9TB</strong></p><p>11、 设某文件为索引顺序文件，由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，均为 512B，并依次存放在 50、121、75、80、63 号磁盘块上。若要存取文件的第 1569 逻辑字节处的信息，则要访问的磁盘块号是 <strong>C</strong></p><p>A. 3 B. 75 C. 80 D. 63</p><p><strong>&#x2F;&#x2F;怎么重复了</strong></p><p>12、 若磁盘转速为7200转&#x2F;分，平均寻道时间为8ms,每个磁道包含1000个扇区，则访问一个扇区的平均存取时间大约是 <strong>B</strong></p><p>A．8.1ms B．12.2ms C．16.3ms D．20.5ms</p><p>**&#x2F;&#x2F;磁盘的平均寻址时间包括平均寻道时间和平均等待时间。平均寻道时间为8ms，平均等待时间与磁盘转速有关，为[60s&#x2F;7200]<em>0.5  ≈4.165ms。磁盘的存取一个扇区的时间为60s&#x2F;(7200 * 1000) ≈ 0.0083ms。因此总的时间为：8   4.165    0.0083 &#x3D; 12.1733ms</em>*</p><p>13、 在文件的索引节点中存放直接索引指针10个，一级二级索引指针各1个，磁盘块大小为1KB。每个索引指针占4个字节。若某个文件的索引节点已在内存中，到把该文件的偏移量（按字节编址）为1234和307400处所在的磁盘块读入内存。需访问的磁盘块个数分别是（）</p><p>A．1，2 B．1，3 C．2，3 D．2，4</p><p><strong>&#x2F;&#x2F;直接索引指针所在位置大小 10*1KB ；一级 (1KB&#x2F;4B) *1KB&#x3D;256KB; 二级 [(1KB&#x2F;4B)^2] *1KB</strong></p><p><strong>1234B-&gt;小于10KB，磁盘块1</strong></p><p><strong>307400B-&gt;大于10KB+256KB-&gt;磁盘块3</strong></p><p>14、 假设磁头当前位于第 100 道,正在向磁道序号增加的方向移动。现有一3个磁道访问请求序列为 35,68,110,180,采用 SSTF （最近寻道优先）调度算法得到的磁道访问序列是 ______。<strong>D</strong></p><p>A. 35,68,110,180 B. 110,180,35,68 C. 110,180,68,35 D. 110,68,35,180</p><p><strong>&#x2F;&#x2F;学会（看大题2，3题），学最近寻道优先，很简单</strong></p><p>在某UNIX操作系统中，文件系统给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含13个直接块指针、1个一级间接块指针和1个二级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小一致，均为1KB，地址指针所占空间为4B。</p><p>15、 若某inode共有2个硬链接（hard link），分别为a和b，另有1个符号链接（symbolic link）x-&gt;a，则该inode的link counter为______。 <strong>C</strong></p><p>A．0 B．1 C．2 D．3</p><p><strong>&#x2F;&#x2F;不算符号链接，所以link counter 为 2</strong> </p><p><a href="http://t.csdnimg.cn/ZLrNn">硬链接和符号链接详解</a></p><p>16、 将a删除后，访问x，结果为______。 <strong>A</strong></p><p>A．提示文件不存在 B．打开文件b C．打开一个空文件 D．x已被删除</p><p><strong>&#x2F;&#x2F;提示文件不存在，实践经历（</strong></p><p>17、 假设该索引节点已经被加载进内存中，则若要读取文件的第1MB的内容，需要访问磁盘___3____次。</p><p>A．1 B．2 C．3 D．4 </p><p><strong>&#x2F;&#x2F;直接块指针13个：13KB</strong></p><p>*<em>一级1个，(1KB&#x2F;4B)<em>1KB&#x3D;256KB</em></em></p><p>*<em>二级1个，[(1KB&#x2F;4B)^2]<em>1KB&#x3D;64MB</em></em></p><p><strong>所以需要3次访问磁盘，需要访问二个索引块和一个数据块</strong></p><p>18、 该文件系统能支持的文件最大容量约为_______<strong>B</strong></p><p>A．64KB B．64MB C．4GB ．16GB</p><p><strong>&#x2F;&#x2F;根据上题，最大为64MB</strong></p><p>19、 若将数据块的大小修改为4KB，则该文件系统能支持的文件最大容量约为________。 <strong>C</strong></p><p>A．64KB B．64MB C．4GB ．16GB</p><p>**&#x2F;&#x2F; [(4KB&#x2F;4B)^2]<em>4KB&#x3D;4GB</em>*</p><p>20、 若保持数据块大小1KB不变，在不增加inode中的指针个数的前提下，取</p><p>消一个直接块指针，增加一个三级间接块指针，则能支持的文件最大容量约</p><p>为________。 <strong>D</strong></p><p>A．64KB B．64MB C．4GB D．16GB</p><p>**&#x2F;&#x2F; [(1KB&#x2F;4B)^3]<em>1KB&#x3D;16GB</em>*</p><h2 id="二、-计算问答题"><a href="#二、-计算问答题" class="headerlink" title="二、 计算问答题"></a>二、 计算问答题</h2><p>1、某操作系统中，给文件分配外存空间采用的是混合索引分配方式。索引节点（inode）中包含 12 个直接块指针和 1 个一级间接块指针，间接块指向的是一个索引块，每个索引块和数据块的大小均为一个扇区，即 512B，地址指针所占空间为 4B。</p><p>1） 该文件系统能支持的文件最大容量是____(1)____。</p><p>2） 为了支持更大的文件，在不增加 inode 中的指针个数的前提下，取消一4个直接块指针，增加一个二级间接块指针，则能支持的文件最大容量是____(2)____。</p><p>3） 在上一问的基础上，若将数据块的大小修改为 1KB，则该文件系统能支持的文件最大容量是____(3)____。</p><p>4） 在上一问的基础上，假设该索引节点已经被加载进内存中，则若要读取文件的第 10MB 的内容，需要访问磁盘____(4)____次。</p><p>*<em>答：（1）(12+(512&#x2F;4))<em>512B&#x3D;71680B&#x3D;70KB</em></em></p><p>*<em>（2）(11+(512&#x2F;4)+ (512&#x2F;4)^2)<em>512B&#x3D;8459776B&#x3D;8261.5KB&#x3D;8.068MB</em></em></p><p>*<em>（3）(11+(1024&#x2F;4)+(1024&#x2F;4)^2)<em>1024B&#x3D;65803KB&#x3D;64.261MB</em></em></p><p><strong>（4）3 次．由上一问知，10MB 需要通过二级间接索引访问，故需要访问二个索引块和一个数据块。</strong></p><p>2、在 inode 的多级索引指针中，为什么保留了直接指向数据块的指针，而不是设计成只使用一个指向多级间接索引块的指针，就可以访问到所有的数据块？数据块的大小可以影响文件系统能支持的最大文件的大小，但是数据块的大小对文件系统的性能和空间利用率之间有什么关系？为什么？</p><p><strong>答：直接指针访问速度快，适合小文件。</strong></p><p><strong>数据块增大，传输数据的单位容量增大，传输效率提升，性能上升。</strong></p><p><strong>数据块增大，则文件存储分配单位变大，内部剩余增加，空间利用率下降。</strong></p><p><strong>数据块减小则情况相反。</strong></p><p>3、若干个等待访问磁盘者依次要访问的柱面为 20,44,40,4,80,12,76，假设每移动一个柱面需要 3ms 时间，移动臂当前位于 40 号柱面，磁头正向磁道号增加的方向移动，请按 FCFS, SSTF, SCAN 算法分别计算为完成上述访问总共花费的寻找时间。</p><p><em><em>FCFS：（|20-40| + |44-20| + |40-44| + |4-40| + |80-4| + |12-80| + |76-12|）</em> 3 &#x3D;</em>* </p><p>**(20+24+4+36+76+68+64)<em>3 &#x3D; 876ms</em>* </p><p><strong>SSTF： 40 - 44 - 20 - 12 – 4 - 76 – 80</strong> </p><p><em><em>（4+24+8+8+72+4）</em> 3 &#x3D; 360 ms</em>*</p><p><strong>SCAN：40 – 44 – 76 – 80 – 20 – 12 - 4</strong> </p><p><em><em>（4+32+4+60+8+8）</em> 3 &#x3D; 348 ms</em>*</p><p>4、假设计算机系统采用 CSCAN(循环扫描)磁盘调度策略,使用 2KB 的内存空间记录 16384 个磁盘块的空闲状态。</p><p>(1) 请说明在上述条件下如何进行磁盘块空闲状态的管理。</p><p>(2) 设某单面磁盘旋转速度为每分钟6000 转,每个磁道有100 个扇区,相邻磁道间的平均移动时间为1ms。若在某时刻,磁头位于100 号磁道处,并沿着磁道号增大的方向移动(如下图所示),磁道号请求队列为50,90,30,120,对请求队列中的每个磁道需读取1 个随机分布的扇区,则读完这4 个扇区点共需要多少时间?要求给出计算过程。</p><p>(3) 如果将磁盘替换为随机访问的Flash 半导体存储器(如U 盘、SSD 等),是否有比CSCAN 更高效的磁盘调度策略?若有,给出磁盘调度策略的名称并说明理由;若无,说明理由。</p><p><strong>(1) 位图法</strong></p><blockquote><p>在CSCAN磁盘调度策略下，管理磁盘块的空闲状态可以采用位图的方式进行。位图是一种数据结构，用于表示磁盘块的分配状态，每个磁盘块用一个比特位来表示其状态（已分配或空闲）。</p><p>给定16384个磁盘块，每个块用一个比特位来表示其状态，所需的比特数可以通过以下方式计算：</p><p>16384个块 ÷ 8位&#x2F;字节 &#x3D; 2048字节 ÷ 1024字节&#x2F;KB &#x3D; 2KB</p><p>因此，需要2KB的内存空间来记录这些磁盘块的空闲状态。</p><p>管理这个位图时，通过初始化所有比特位为“0”来表示所有磁盘块都是空闲的状态。当磁盘块被分配时，相应的比特位被设置为“1”表示已被占用。当磁盘块被释放时，相应的比特位重新设置为“0”以表示它变为空闲状态。</p><p>CSCAN调度算法将磁盘的访问方向限制在一个特定的范围内移动，这使得磁盘空间的管理可以更加高效地实现。</p></blockquote><p><strong>(2) CSCAN：190.4 ms</strong></p><p><strong>寻道时间：|120-100| + |30-120| + |50-30| + |90-50| &#x3D; 170ms</strong></p><p><strong>旋转时间：10ms&#x2F;2*4 &#x3D; 20ms</strong></p><p><strong>读数据：10ms&#x2F;100 * 4 &#x3D; 0.4ms</strong></p><p><strong>(3) FCFS</strong></p><p>ps：</p><blockquote><p><strong>当参加天津大学智算学部“操作系统原理”课程期末考试时</strong></p><p>1．SCAN 算法，磁臂从磁盘的一端向另一端移动，当磁头移过每一个</p><p>柱面时，处理位于该柱面上的请求服务。当到达另一端时，改变方向</p><p>继续处理。（每次都运动到顶端）</p><p>2．C-SCAN 算法，C-SCAN 也是将磁头从磁盘一端移到另一端，随着</p><p>移动不断的处理请求。但是，当磁头移到另一端时，会马上返回到磁</p><p>盘开始，返回时不处理请求.（每次都运动到顶端）</p><p>3．LOOK 算法：是改进的 SCAN 算法，处理过程与 SCAN 相似，只是</p><p>每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。</p><p>4．C-LOOK 算法：是改进的 C-SCAN 算法，处理过程与 C-SCAN 相似，</p><p>只是每次都不运动到顶端，在最大磁道号和最小磁道号之间移动。 </p><p><strong>非期末考试时（如阅读其他教参时、做作业时等）</strong></p><p>SCAN 算法＝LOOK 算法&#x3D;上面第 3 条描述（两头不到顶）</p><p>C-SCAN 算法＝C-LOOK 算法&#x3D;上面第 4 条描述（两头不到顶）</p></blockquote><p>整理自：<a href="https://blog.csdn.net/m0_73495245?type=blog">Wind_9233</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件管理习题&quot;&gt;&lt;a href=&quot;#文件管理习题&quot; class=&quot;headerlink&quot; title=&quot;文件管理习题&quot;&gt;&lt;/a&gt;&lt;strong&gt;文件管理习题&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;共三个习题：&lt;/strong&gt;&lt;br&gt;进程管理、内存管理、</summary>
      
    
    
    
    
    <category term="操作系统_文件管理专题" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T15:12:41.862Z</published>
    <updated>2023-12-27T15:12:42.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理习题！"><a href="#进程管理习题！" class="headerlink" title="进程管理习题！"></a>进程管理习题！</h1><h2 id="一、-单项选择题"><a href="#一、-单项选择题" class="headerlink" title="一、 单项选择题"></a>一、 单项选择题</h2><p>1、设与某资源关联的记录型信号量初值为 1,当前值为 -3。则当前因等待使用该资源而处于阻塞态的进程个数为______。</p><p> A.1 B.0 C.3 D.4</p><p>2、当一个进程处于（ ）状态时，称其为等待（或阻塞）状态。 </p><p>A. 它正等待中央处理机 B. 它正等待合作进程的一个消息 </p><p>C. 它正等待分给它一个时间片 D. 它正等待进入内存</p><p>3、下面关于线程的叙述中，正确的是（ ）。</p><p> A.不论是系统支持线程还是用户级线程，其切换都需要内核的支持。</p><p> B.线程是资源的分配单位，进程是调度和分配的单位。</p><p> C.不管系统中是否有线程，进程都是拥有资源的独立单位。</p><p> D.在引入线程的系统中，进程仍是资源分配和调度分派的基本单位。</p><p>4、资源的按序分配策略可以破坏______条件。</p><p>A. 互斥使用资源 B. 占有且等待资源 C. 非抢夺资源 D. 循环等待资源</p><p>5、下列选项中，会导致用户进程从用户态切换到内核态的操作是</p><p>I.整数除以零 II. sin()函数调用 III. read系统调用</p><p>A.仅I、II B.仅I、III C.仅II、III D. I、II和III</p><p>6、下列关于银行家算法的叙述中，正确的是</p><p>A. 银行家算法可以预防死锁 </p><p>B. 当系统处于安全状态时，系统中一定无死锁进程</p><p>C. 当系统处于不安全状态时，系统中一定会出现死锁进程</p><p>D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件2</p><p>7、有 5 个批处理任务 A、B、C、D、E 几乎同时到达一个计算中心。它们预计运行的时间分别是 10min、6min、2min、4min 和 8min。其优先级（由外部设定）分别为 3、5、2、1 和</p><p>4，这里 5 为最高优先级。下列各种调度算法中，其平均进程周转时间为 14min 的是</p><p>A. 时间片轮转调度算法 B. 优先级调度算法</p><p>C. 先来先服务调度算法 D. 最短作业优先算法</p><p>8、可以被多个进程在任意时刻共享的代码必须是________。</p><p>A. 顺序代码 B. 机器语言代码 C.不能自身修改的代码 D. 无转移指令代码</p><p>9、设m为同类资源数，n为系统中并发线程数。当n个进程共享m个互斥资源时，每个进程的最大需求是w；则下列情况会出现系统死锁的是：</p><p>A. m&#x3D;2,n&#x3D;1,w&#x3D;2 B. m&#x3D;2,n&#x3D;2,w&#x3D;1 C. m&#x3D;4,n&#x3D;3,w&#x3D;2 D. m&#x3D;4,n&#x3D;2,w&#x3D;3</p><p>10、 下列调度算法中，不可能导致饥饿现象的是：</p><p>A.时间片轮转 B.静态优先级调度 </p><p>C.非抢占式作业优先 D.抢占式短作业优先</p><p>11、 某系统有n台互斥使用的同类设备，3个并发进程，最多分别需要3,4,5台设备，可确保系统不会发生死锁的设备数n最少为：</p><p>A. 9 B. 10 C. 11 D. 12</p><p>12、 下列指令中，不能在用户态执行的是：</p><p>A.trap 指令 B.跳转指令 C. 压栈指令 D.关中断指令</p><p>13、 一个进程调用了阻塞式系统调用read()进行读磁盘操作，操作完成后，操作系统针对该进程必须做的是：</p><p>A.修改进程状态为就绪态 B.降低进程优先级</p><p>C.进程分配用户内存空间 D.增加进程的时间片大小</p><p>设系统中有三种类型的资源（A、B、C），它们的资源数量分别是 17、5、20，五个进程（P1，</p><p>P2，P3，P4，P5）。在 T0 时刻系统状态如下表所示，系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230517556.png" alt="image-20231227230517556"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230525378.png" alt="image-20231227230525378"></p><p>14、 在T0时刻若进程P2请求资源（0,3,4），是否能实施分配？为什么？</p><p>A. 不可以，因为无足够资源完成分配。</p><p>B. 不可以，因为分配后进入不安全状态。</p><p>C. 可以，分配后存在安全序列 P4-&gt;P2-&gt;P5-&gt;P3-&gt;P1。</p><p>D. 可以，分配后存在安全序列 P2-&gt;P5-&gt;P4-&gt;P1-&gt;P3。</p><p>假定在单道批处理环境下有5个作业，各作业进入系统的时间和估计运行时间如下表所示：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230539993.png" alt="image-20231227230539993"></p><p>15、 如果应用最短作业优先的作业调度算法，则作业的平均周转时间为______分钟。</p><p> A. 50.3 B. 77.4 C. 37.2 D. 43.4</p><p>16、 某系统正在执行三个进程 P1、P2 和 P3，各进程的计算（CPU）时间和 I&#x2F;O 时间比</p><p>例如下表所示。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230555000.png" alt="image-20231227230555000"></p><p>为提高系统资源利用率，合理的进程优先级设置应为</p><p>A. P1&gt;P2&gt;P3 B. P3&gt;P2&gt;P1 C. P2&gt;P1&#x3D;P3 D. P1&gt;P2&#x3D;P3</p><p>17、 中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调4用不需要保存的是</p><p>A. 程序计数器 B. 程序状态字寄存器C. 通用数据寄存器 D. 通用地址寄存器</p><p>18、 有 5 个批处理任务 A、B、C、D、E 几乎同时到达一个计算中心。它们预计运行的时间分别是 10min、6min、2min、4min 和 8min。其优先级（由外部设定）分别为 3、5、2、1 和 4，这里 5 为最高优先级。下列各种调度算法中，其平均进程周转时间为 14min 的</p><p>是</p><p>A. 时间片轮转调度算法 B. 优先级调度算法</p><p>C. 先来先服务调度算法 D. 最短作业优先算法</p><p>19、 </p><p>一个多道批处理系统中仅有P1和P2两个作业，P2比P1晚5 ms到达。它们的计算和I&#x2F;O操作顺序如下：</p><p>P1：计算 60 ms，I&#x2F;O 80 ms，计算 20 ms</p><p>P2：计算 120 ms，I&#x2F;O 40 ms，计算 40 ms</p><p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是</p><p>A. 240 ms B. 260 ms C. 340 ms D. 360ms</p><p>20、 若某单处理器多进程系统中有多个就绪态进程，则下列关于处理机调度的叙述中错误的是</p><p>A. 在进程结束时能进行处理机调度 B. 创建新进程后能进行处理机调度</p><p>C. 在进程处于临界区时不能进行处理机调度</p><p>D. 在系统调用完成并返回用户态时能进行处理机调度</p><p>21、 下列关于进程和线程的叙述中，正确的是</p><p>A. 不管系统是否支持线程，进程都是资源分配的基本单位</p><p>B. 线程是资源分配的基本单位，进程是调度的基本单位</p><p>C. 系统级线程和用户级线程的切换都需要内核的支持</p><p>D. 同一进程中的各个线程拥有各自不同的地址空间</p><p>22、 下列关于银行家算法的叙述中，正确的是</p><p>A. 银行家算法可以预防死锁</p><p>B. 当系统处于安全状态时，系统中一定无死锁进程5</p><p>C. 当系统处于不安全状态时，系统中一定会出现死锁进程</p><p>D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件</p><p>23、 若一个用户过程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过</p><p>程的叙述中，正确的是</p><p>Ⅰ. 若该文件的数据不在内存，则该进程进入睡眠等待状态</p><p>Ⅱ. 请求 read 系统调用会导致 CPU 从用户态切换到核心态</p><p>Ⅲ. read 系统调用的参数应包含文件的名称</p><p>A. 仅Ⅰ、Ⅱ </p><p>B. 仅Ⅰ、Ⅲ </p><p>C. 仅Ⅱ、Ⅲ </p><p>D. Ⅰ、Ⅱ和Ⅲ</p><p>24、 假设5个进程P0、P1、P2、P3、P4的共享3类资源R1、R2、R3，这些资源总数分别</p><p>为18、6、22。T0时刻的资源分配情况如下表所示，此时存在的一个安全序列是</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230612035.png" alt="image-20231227230612035"></p><p>A. P0，P2，P4，P1，P3 </p><p>B. P1，P0，P3，P4，P2</p><p>C. P2，P1，P0，P3，P4 </p><p>D. P3，P4，P2，P1，P0</p><p>25、 设有3个进程共享一个互斥段，如果最多允许有2个进程同时进入互斥段，则所采用的信号量的初值应是（ ）：</p><p>A．2 B．3 C．1 D．0</p><p>26、 两个进程合作完成一个任务。在并发执行中，一个进程要等待其合作伙伴发来消息，或者建立某个条件后再向前执行，这种制约性合作关系被称为进程的（ ）。</p><p>A．同步 B．互斥 C．调度 D．执行</p><p>27、 设备分配问题中，算法实现时，同样要考虑安全性问题，防止在多个进程进行设备请求时，因相互等待对方释放所占设备所造成的（ ）现象。6</p><p>A．瓶颈 B．碎片 C．系统抖动 D．死锁</p><p>28、 下列进程状态的转换中，哪一个是不正确的（ ）。</p><p>A．就绪-&gt;运行 B．运行-&gt;就绪 C．就绪-&gt;阻塞 D．阻塞-&gt;就绪</p><p>29、 在多进程的系统中，为了保证公共变量的完整性，各进程应互斥进入临界区。所</p><p>谓临界区是指______。</p><p>A．一个缓冲区 B．一段数据区 C．同步机制 D．一段程序</p><p>假设系统中有 4 个进程和 4 个可分配资源，当前分配和最大需求如下表所示，已知资源的最大拥有量为 E&#x3D;（12，9，5，4）。系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230628809.png" alt="image-20231227230628809"></p><p>30、 在当前时刻若进程2请求资源（0,1,0,0），是否能实施分配？若能，给出安全序列。</p><p>A．不能分配，因为分配后不存在安全序列。</p><p>B．不能分配，因为资源不足。</p><p>C．能分配，分配后存在安全序列 3-&gt;4-&gt;2-&gt;1</p><p>D．能分配，分配后存在安全序列 3-&gt;4-&gt;1-&gt;2</p><p>有 6 个 CPU 密集型批处理作业 A、B、C、D、E 和 F，几乎同时被提交。预计运行时间分别为 12，6，2，4，8 和 2 分钟。对于下列每种调度算法，忽略进程切换的开销，计算其平均进程周转时间。</p><p>31、 设进程A-F的优先级分别为4，6，3，2，5和1，其中1为最高优先级。则采用优先级调度算法，平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟</p><p>32、 采用先来先服务调度算法，按照A、B、C、D、E和F的顺序运行。则平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟7</p><p>33、 采用最短作业优先调度算法，平均进程周转时间为______。</p><p>A. 16.33分钟 B.14.33分钟 C. 14分钟 D. 23.33分钟</p><p>34、 某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的输入、计算和输出时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执行，则执行完3个作业需要的时间最少是______。</p><p>A. 15ms B. 17ms C. 22ms D.27ms</p><p>35、 系统中有3个不同的临界资源R1、R2和R3，被4个进程P1、P2、P3和P4共享。各进程对资源的需求为：P1申请R1和R2，P2申请R2和R3，P3申请R1和R3，P4申请R2。若系统出现死锁，则处于死锁状态的进程数至少是______。</p><p>A. 1 B. 2 C. 3 D.4</p><p>36、 进程P1和P2均包含并发执行的线程，部分伪代码描述如下所示：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230643549.png" alt="image-20231227230643549"></p><p>下列选项中，需要互斥执行的操作是______。</p><p>A. a&#x3D;1 与 a&#x3D;2 B. a&#x3D;x 和 b&#x3D;x C. x+&#x3D;1 与 x+&#x3D;2 D. x+&#x3D;1 与 x+&#x3D;3</p><p>假设系统中有 4 个进程和 1 个可分配资源，当前分配和最大需求如下表所示，已知资源的总量为 100。系统采用银行家算法实施死锁避免策略。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230701803.png" alt="image-20231227230701803"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230708036.png" alt="image-20231227230708036"></p><p>37、 在当前时刻若进程2请求该资源数量为10，是否能实施分配？若能，给出安全序列。</p><p>A．不能分配，因为分配后不存在安全序列。</p><p>B．不能分配，因为资源不足。</p><p>C．能分配，分配后存在安全序列 3-&gt;4-&gt;2-&gt;1</p><p>D．能分配，分配后存在安全序列 3-&gt;4-&gt;1-&gt;2</p><h2 id="二、-简答题"><a href="#二、-简答题" class="headerlink" title="二、 简答题"></a>二、 简答题</h2><p>1、你需要在一个很古老的 UNIX 上编写支持多线程的程序，它的内核不支持线程，内核代码也未公开，所以很难改造内核。请问如何解决这个问题？</p><p>2、在 UNIX 中父进程通过 fork()产生与自己一模一样的子进程，请问执行什么系统调用后，子进程才拥有自己独立的新代码段。这个系统调用的返回值是如何规定的？</p><p>3、当检测到死锁发生时，如果必须杀死一个进程以解除死锁，请问以什么标准来选择被杀死的进程比较合理？</p><p>4、在一单道批处理系统中，一组作业的提交时刻和运行时间如下表所示。试计算一下三种作业调度算法的平均周转时间 T 和平均带权周转时间 W。 (1) 先来先服务; (2) 短作业优先 (3) 高响应比优先。作业提交时刻和运行时间如下表</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230719689.png" alt="image-20231227230719689"></p><p>5、设系统中有 3 种类型的资源(A，B，C)和 5 个进程(P1，P2，P3，P4，P5)，A 资源的数量为 17，B 资源的数量为 5，C 资源的数量为 20。在 T0 时刻系统状态表如下表所示。<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230729750.png" alt="image-20231227230729750"></p><p>系统采用银行家算法试试死锁避免策略。</p><p>(1) T0 时刻是否为安全状态?若是，请给出安全序列。</p><p>(2) 在 T0 时刻若进程 P2 请求资源(0,3,4)，是否能实施资源分配?为什么?</p><p>(3) 在(2)的基础上，若进程 P4 请求资源(2,0,1)，是否能实施资源分配?为什么?</p><p>(4) 在(3)的基础上，若进程 P1 请求资源(0,2,0)，是否能实施资源分配?为什么?</p><p>6、某系统有 R1,R2,R3 共 3 类资源，在 T0 时刻 P1,P2,P3 和 P4 这 4 个进程对资源的占用和 需求情况见下表，此刻系统可用资源向量为(2,1,2）</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230747261.png" alt="image-20231227230747261"></p><p>问题:</p><p> (1)将系统中各种资源总量和此刻各进程对各资源的需求数目用向量或矩阵表示出来</p><p>(2)如果此时 P1,P2 均发出资源请求向量 Request(1,0,1),为了保持系统的安全性应该如 何分配资源?说明你所采用策略的原因。</p><p>(3)如果(2)中两个请求立刻得到满足后，系统此刻是否处于死锁状态?</p><p>7、设有 3 个进程 P、Q、R，它们共享 10 个同类资源，P、Q、R 进程的资源最大需求量依次为 4、7 和 8。现假定它们对资源的请示序列如下表所示:</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230759306.png" alt="image-20231227230759306"></p><p>为了避免死锁，系统分配资源时采用银行家算法。如果申请资源得不到满足，进程就转入阻塞态。根据上述信息，试描述各步骤结束时，申请资源的进程是得到满足，还是转入阻塞状 态，为什么?(起始状态:各进程均不拥有资源，无进程处于阻塞态)</p><p>8、分时操作系统中进程调度算法中对普通进程常常采用的是优先级轮转法，请问如何保证不会有进程因为优先级太低而饥饿？</p><p>9、死锁是一种对操作系统正常运行危害很大的现象，但是大多数死锁的解决方法只停留在理论探讨中，无法应用于实际的操作系统系统。请列举中哪些方法是实际操作系统中采用的应对死锁的可行方法。如果操作系统发现死锁已经发生，应如何应对使造成的损失较小？</p><p>10、 假定下面的 C 语言程序在 UNIX 系统上运行，并且所有系统调用都能成功完成。其中“pthread_create(&amp;t, NULL, bar, NULL);”的功能是创建一个新线程来执行函数bar，并返回线程对象标识 t。“pthread_join(t,NULL);”的功能是等待线程 t 结束。试问此程序在运行过程中会打印出多少个“hello”？需要说明分析过程。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230857634.png" alt="image-20231227230857634"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227230904055.png" alt="image-20231227230904055"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程管理习题！&quot;&gt;&lt;a href=&quot;#进程管理习题！&quot; class=&quot;headerlink&quot; title=&quot;进程管理习题！&quot;&gt;&lt;/a&gt;进程管理习题！&lt;/h1&gt;&lt;h2 id=&quot;一、-单项选择题&quot;&gt;&lt;a href=&quot;#一、-单项选择题&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/12/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/</id>
    <published>2023-12-27T15:04:10.874Z</published>
    <updated>2023-12-27T15:04:11.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理习题"><a href="#内存管理习题" class="headerlink" title="内存管理习题"></a>内存管理习题</h1><h2 id="⼀、-选择题"><a href="#⼀、-选择题" class="headerlink" title="⼀、 选择题"></a>⼀、 选择题</h2><p>1、设备分配问题中，算法实现时，同样要考虑安全性问题，防⽌在多个进程进⾏设备请求时，因相互等待对⽅释放所占设备所造成的（ D）现象。</p><p>A．瓶颈 B．碎⽚ C．系统抖动 D．死锁</p><p>&#x2F;&#x2F;概念题</p><p>2、主存与辅存间频繁的页⾯置换现象被称为（C ）。</p><p>A．请求调页 B．碎⽚整理 C．系统抖动 D．输⼊输出</p><p>&#x2F;&#x2F;概念题</p><p>3、在可变分区存储管理中，最差适应分配算法要求对空闲区表项按（C ）进⾏排列。</p><p>A．地址从⼤到⼩ B．地址从⼩到⼤ C．尺⼨从⼤到⼩ D．尺⼨从⼩到⼤</p><p>&#x2F;&#x2F;概念题</p><p>4、段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管</p><p>理的基本思想，即（B）。</p><p> A、⽤分段⽅法来分配和管理物理存储空间，⽤分页⽅法来管理⽤户地址空间。 </p><p> B、⽤分段⽅法来分配和管理⽤户地址空间，⽤分页⽅法来管理物理存储空间。 </p><p> C、⽤分段⽅法来分配和管理主存空间，⽤分页⽅法来管理辅存空间。 </p><p>D、⽤分段⽅法来分配和管理辅存空间，⽤分页⽅法来管理主存空间。</p><p>&#x2F;&#x2F;概念题：先分段再分页</p><p>5、下列措施中，能加快虚实地址转换的是：（C）</p><p>I. 增⼤快表（TLB） II. 让页表常驻内存 III. 增加交换区</p><p>A. 仅 I B. 仅 II C. 仅 I,II D. 仅 II,III</p><p>6、在页式存储管理系统中，采⽤某些页⾯置换算法，会出现Belady异常现象，即进程的缺页次数会随着分配给该进程的页框个数的增加⽽增加。下列算法中，可能出现Belady异常现象的是：</p><p>I. LRU 算法 II. FIFO 算法 III. OPT 算法</p><p>A. 仅 II B.仅 I,II C. 仅 I,III D. 仅 II,III2</p><p>7、下列选项中，属于多级页表优点的是：</p><p>A.加快地址变换速度 </p><p>B.减少缺页中断次数</p><p>C. 减少⼀个页表项所占字节数 </p><p>D.减少页表所占的内存空间</p><p>8、下列关于虚拟存储器的叙述中，正确的是</p><p>A. 虚拟存储器只能基于连续分配技术 B. 虚拟存储器只能基于⾮连续分配技术</p><p>C. 虚拟存储器只受外存容量的限制 D. 虚拟存储器只受内存容量的限制</p><p>9、在⼀个请求分页系统中，采⽤ LRU 页⾯转换算法时，加⼊⼀个作业的页⾯⾛向为：</p><p>1，3，2，1，1，3，5，1，3，2，1，5.当分配给该作业的物理块数分别为 3 和 4 时，在</p><p>访问过程中所发⽣的缺页率为</p><p>A. 25%，33% B. 50%，25% C.50%,33% D. 50%，75%</p><p>10、 设有 8 页的逻辑空间，每页有 1024B,它们被映射到 32 块的物理存储区中。那么，</p><p>逻辑地址的有效位是_______位，物理地址⾄少是________位。</p><p>A. 10、11 </p><p>B. 12、14 </p><p>C. 13、15 </p><p>D. 14、16</p><p>11、 某作业的逻辑地址空间为4页，页⾯⼤⼩为2048，已知页表如下所⽰，则逻辑地址</p><p>4865（⼗进制）对应的物理地址为（ ）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227224908008.png" alt="image-20231227224908008"></p><p>A、4865 B、8961 C、13057 D、6865</p><p>12、 若⽤户进程访问内存时产⽣缺页，则下列选项中，操作系统可能执⾏的操作是</p><p>I.处理越界错 </p><p>II.置换页 </p><p>III.分配内存</p><p>A.仅I、II B.仅II、III C. 仅I、III D. I、II和III</p><p>13、 可以被多个进程在任意时刻共享的代码必须是________。</p><p>A. 顺序代码 B. 机器语⾔代码 C.不能⾃⾝修改的代码 D. ⽆转移指令代码</p><p>14、 假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000 H；地址 1000H 中</p><p>的内容为 2000H，地址 2000H 中的内容为 3000H，地址 3000 H 中的内容为 4000H，则变3</p><p>址寻址⽅式下访问到的操作数是： </p><p>A. 1000H B. 2000H C. 3000H D. 4000 H</p><p>15、 有⼀个整数矩阵为 100 ⾏*200 列，即 a[100][200]。在⼀个虚拟系统中，采⽤ LRU 算</p><p>法，系统分给该进程 5 个页⾯来存储数据（不包含程序），设每页可存放 200 个整数，该</p><p>程序要对整个数组初始化，数组存储时是按⾏存放的。试计算下列两个程序各⾃的缺页</p><p>次数（假定所有页都以请求⽅式调⼊）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225029374.png" alt="image-20231227225029374"></p><p>A. 100,200 B. 100,20000 C. 200,100 D. 20000,100</p><p>16、 考虑页⾯置换算法，系统有 m 个物理块供调度，初始时全空，页⾯引⽤串长度为</p><p>p，包含了 n 个不同的页号，⽆论⽤什么算法，缺页次数不会少于（ ）</p><p>A、m B、p C、n D、min(m,n)</p><p>17、 总体上说，“按需调页”（Demand-Paging）是个很好的虚拟内存管理策略。但是，</p><p>有些程序设计技术并不适合于这适种环境。例如（ ）</p><p>A、堆栈 B、线性搜索 C、⽮量运算 D、⼆分法搜索</p><p>18、 把进程地址空间中使⽤的逻辑地址变成内存中物理地址的过程称为：</p><p>A、重定位 B、物理化 C、逻辑化 D、加载</p><p>19、 在可变分区存储管理中，最佳适应分配算法要求对空闲区表项按（ ）进⾏排列。</p><p>A、地址从⼤到⼩ B、地址从⼩到⼤ C、尺⼨从⼤到⼩ D、尺⼨从⼩到⼤</p><p>20、 主存与辅存间频繁的页⾯置换现象被称为（ ）。</p><p>A、请求调页 B、碎⽚整理 C、系统抖动 D、输⼊输出</p><p>21、 某作业的逻辑地址空间为 4 页，页⾯⼤⼩为 2048，已知页表如下所⽰，则逻辑地址4865（⼗进制）对应的物理地址为（ ）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225202115.png" alt="image-20231227225202115"></p><p>A、4865 B、8961 C、13057 D、6865</p><h2 id="⼆、-计算题（选择）"><a href="#⼆、-计算题（选择）" class="headerlink" title="⼆、 计算题（选择）"></a>⼆、 计算题（选择）</h2><p>某操作系统中，进程的逻辑地址空间和系统的物理地址空间均为 64KB，按字节编址。某进程最多需要 8 页（Page）数据存储空间，页的⼤⼩为 2KB，操作系统采⽤固定分配局部置换策略为此进程分配 6 个页框（Page Frame），采⽤⽼化算法（aging）进⾏页⾯置换，每个页⾯使⽤ 8bits 记录使⽤情况。在每个 clock tick结束时，6 个页⾯的 R 位如下所⽰：<br><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225259459.png" alt="image-20231227225259459"></p><p>页表存放在主存中，对主存的⼀次存取需要100ns，对TLB表的查找时间为10ns，处理</p><p>⼀次缺页中断需要10^8 ns（10的8次⽅ns，含更新TLB和慢表的时间）。</p><p>22、 如果现在程序执⾏时遇到逻辑地址1AC5H，这次访问耗费时间为______。</p><p>A. 108 +220ns B. 100ns C. 110ns D. 210ns</p><p>23、 然后，程序执⾏时遇到逻辑地址32C5H，这次访问耗费时间为______。5</p><p>A. 108 +220ns B. 100ns C. 110ns D. 210ns</p><p>24、 32C5H对应的物理地址为______。</p><p>A. 7AC5H B. 22C5H C. 3AC5H D. F2C5H</p><p> 有⼀个整数矩阵为 100 ⾏*100 列，即 a[100][100]。系统分给该进程 5 个页⾯来存储此矩阵，设每页可存放 100 个整数，该程序要对整个数组初始化，数组存储时是按⾏存放的。页⾯采⽤ LRU 页⾯置换算法和局部置换策略。试计算下列两个程序各⾃的缺页次数（假定所有页都以请求⽅式调⼊）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225458098.png" alt="image-20231227225458098"></p><p>25、 程序⼀执⾏时产⽣的缺页中断次数为________。</p><p>A. 20 B. 100 C. 2000 D. 10000</p><p>26、 程序⼆执⾏时产⽣的缺页中断次数为________。</p><p>A. 20 B. 100 C. 2000 D. 10000</p><p>某计算机主存按字节编址，逻辑地址和物理地址都是 32 位，页⾯⼤⼩为 4KB，页表项⼤⼩为 4 字节。请回答下列问题。</p><p>27、 若使⽤⼀级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225436229.png" alt="image-20231227225436229"></p><p>此时页表最⼤占⽤空间为_______。</p><p>A. 4KB </p><p>B. 1MB </p><p>C. 4MB </p><p>D. 32MB</p><p>28、 若使⽤⼆级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225447428.png" alt="image-20231227225447428"></p><p>若该进程共⽤到了10000个页，则此时此⼆级页表占⽤的总空间最⼩为_______。</p><p>A. 4KB </p><p>B. 11KB </p><p>C. 44KB </p><p>D. 11MB</p><p>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 1KB，逻辑地址空间为 32 位，物理地址空间⼤⼩为 4 GB，按字节编址。页表采⽤多级页表，⼀个页表项⼤⼩为 4B。TLB（快表）采⽤全相联映射，有 4 个页表项，内容如下表所⽰。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225522350.png" alt="image-20231227225522350"></p><p>29、 该系统的页表项中，最多可以保存_______位标志位。</p><p>A．8 B．10 C．12 D．16</p><p>30、 若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤______级页</p><p>表较合适。</p><p>A．0 B．1 C．2 D．3</p><p>31、 对逻辑地址3FFF1880H转换为物理地址的结果是______。</p><p>A. 0C153080H B. 0F035880H C. TLB 缺失 D.缺页</p><p>某请求页式存储管理，允许⽤户空间为 32 个页⾯（每页 2KB），主存为 16KB，如有⼀</p><p>个⽤户程序有 10 页长，且某时刻该⽤户进程的页表如下表所⽰</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225948016.png" alt="image-20231227225948016"></p><p>32、 如果程序执⾏时遇到逻辑地址1AC5H，则它对应的物理地址为______。</p><p>A. 7AC5H B. 4AC5H C. 3AC5H D. 缺页</p><p>33、 页表存放在主存中，对主存的⼀次存取需要100ns，对TLB表的查找时间为10ns，</p><p>这次访问耗费时间为______。</p><p>A. 10ns B. 100ns C. 110ns D. 210ns</p><p>34、 如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为80%，则访问</p><p>内存中数据的平均有效访问时间是______。7</p><p>A．120ns B．130ns C．170ns D．190ns</p><p>某操作系统的内存管理器采⽤请求式分页，页⾯⼤⼩为 4KB，逻辑地址空间为 32 位，</p><p>物理地址空间为 36 位，⼀个页表项⼤⼩为 4B。⼀次快表（TLB）的访问时间是 10ns，⼀次</p><p>内存的访问时间是 100ns，处理⼀次缺页的平均时间 10^8 ns（已含更新 TLB 和页表的时</p><p>间）。进程的驻留集⼤⼩固定为 2,采⽤最近未使⽤置换算法(NRU)和局部淘汰策略。假设（1）</p><p>TLB 初始为空;（2）地址转换时先访问 TLB,若 TLB 未命中,再访问页表(忽略访问页表之后</p><p>的 TLB 更新时间);（3）有效位为 0 表⽰页⾯不在内存,产⽣缺页中断,缺页中断处理后,返回</p><p>到产⽣缺页中断的指令处重新执⾏。进程的部分页表如下所⽰：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225914783.png" alt="image-20231227225914783"></p><p>35、 该系统的页表项中，最多可以保存_______位标志位。</p><p>A．4 B．8 C．12 D．16</p><p>36、 若采⽤多级页表，要求每级页表均可以装⼊⼀个页⾯内，则应该采⽤______级页</p><p>表较合适。</p><p>A．0 B．1 C．2 D．3</p><p>37、 如果不考虑缺页的情况，对于已经载⼊内存的页⾯，快表命中率为90%，则访问</p><p>内存中数据的平均有效访问时间是______。</p><p>A．20ns B．110ns C．120ns D．320ns</p><p>38、 ⾸先，访问逻辑地址00001618H，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>39、 然后，访问逻辑地址00000FA6H，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>40、 最后，访问逻辑地址0000126CH，则读⼊所需数据需要的总时间是______。</p><p>A．约 10^8ns B．110ns C．200ns D．210ns</p><p>41、 在依次访问完上述三个逻辑地址后，页框101254H对应的页号为______。</p><p>A．00000H B．00001H C．00002H D．00003H</p><p>某基于动态分区存储管理的计算机,其主存容量为 55MB(初始为空闲) ,分配和释放的顺8</p><p>序为:分配 15MB,分配 30MB,释放 15MB,分配 8MB,分配 6MB。</p><p>42、 若采⽤最佳适配(Best Fit)算法，此时主存中最⼤空闲分区的⼤⼩是______。</p><p>A.7MB B.9MB C.10MB D.15MB</p><p>43、 若采⽤最差适配(Worst Fit)算法，此时主存中最⼤空闲分区的⼤⼩是______。</p><p>A.7MB B.9MB C.10MB D.15MB</p><h2 id="三、-计算题（填空）"><a href="#三、-计算题（填空）" class="headerlink" title="三、 计算题（填空）"></a>三、 计算题（填空）</h2><p>1、在逻辑地址转换为物理地址时，采⽤页式存储管理，两级页表，页⾯⼤⼩为 4 KB，页表</p><p>项⼤⼩为 4 字节。逻辑地址的结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225816196.png" alt="image-20231227225816196"></p><p>若该进程共⽤到了 3072 个页，则此时此⼆级页表占⽤的总空间最⼩为___(1)____。</p><p>TLB（快表）采⽤全相联映射，有 4 个页表项，内容如下表所⽰。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225808126.png" alt="image-20231227225808126"></p><p>则逻辑地址 03FFF180H 对应的物理地址是____(2)_____，逻辑地址 02FF3036H 对应的物理</p><p>地址是____(3)_____。（如⽆对应的物理地址，则填写原因，可能为“TLB 缺失”或“缺页”）</p><p>2、某计算机主存按字节编址，逻辑地址和物理地址都是 32 位，页表项⼤⼩为 4 字节。请</p><p>回答下列问题。</p><p>（1）若使⽤⼀级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225753388.png" alt="image-20231227225753388"></p><p>则页的⼤⼩是__(1)_<strong>。页表最⼤占⽤空间为</strong>(2)__。</p><p>（2）若使⽤⼆级页表的分页存储管理⽅式，逻辑地址结构为：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225746983.png" alt="image-20231227225746983"></p><p>设逻辑地址为LA，则其对应的页⽬录号的表达式___(3)<em><strong>和页表索引的表达式</strong></em>(4)___。</p><p>若该进程共⽤到了3072个页，则此时此⼆级页表占⽤的总空间最⼩为___(5)____。</p><p>（3）采⽤（1）中的分页存储管理⽅式，⼀个代码段起始逻辑地址为 0000 8000H，其长度为8 KB，被装载到从物理地址 0090 0000H 开始的连续主存空间中。页表从主存 0020 0000H 开始的物理地址处连续存放，如下图所⽰（地址⼤⼩⾃下向上递增）。则该代码段对应的两个页表项，物理地址 1 是___(6)<em><strong>，物理地址 2 是</strong></em>(7)_<strong>；这两个页表项中的页框号 1 是</strong>(8)<em><strong>，页框号 2 是</strong></em>(9)<em><strong>；以及代码页⾯ 2 的起始物理地址 3 是</strong></em>(10)___。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225700626.png" alt="image-20231227225700626"></p><h2 id="四、计算题（简答）"><a href="#四、计算题（简答）" class="headerlink" title="四、计算题（简答）"></a>四、计算题（简答）</h2><ol><li>请求分页管理系统中，假设某进程的页表内容如下表所⽰:</li></ol><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225642811.png" alt="image-20231227225642811"></p><p>页⾯⼤⼩为 4KB，⼀次内存的访问时间是 100ns，⼀次快表(TLB)的访问时间是 10ns，处理</p><p>⼀次缺页的平均时间 108 ns(已含更新 TLB 和页表的时间)，进程的驻留集⼤⼩固定为 2，</p><p>采⽤最近最少使⽤置换算法(LRU)和局部淘汰策略。假设 (1) TLB 初始为空; (2) 地址转换时</p><p>先访问 TLB，若 TLB 未命中，再访问页表(忽略访问页表之后的 TLB 更新时间); (3) 有效</p><p>位为 0 表⽰页⾯不在内存，产⽣缺页中断，缺页中断处理后，返回到产⽣缺页中断的指令</p><p>处重新执⾏。设有虚地址访问序列 2362H、1565H、25A5H，请问:</p><p>\1) 依次访问上述三个虚地址，各需多少时间?给出计算过程。</p><p>\2) 基于上述访问序列，虚地址 1565H 的物理地址是多少?请说明理由。</p><p>\2. 某系统的页⾯淘汰算法采⽤⽼化(Aging)算法，每个页⾯分配⼀个8位⼆进制数的计数器。</p><p>某进程共有 6 个页⾯，在时刻 0 之前所有页⾯均未被引⽤过。下表是前 5 个 clock tick 中10</p><p>各页⾯的被引⽤情况，被引⽤者标 1，未被引⽤者标 0。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225628323.png" alt="image-20231227225628323"></p><p>1） 在 clock tick 4 过后，需要淘汰⼀个页⾯，应选择哪个页⾯进⾏淘汰？为什么？</p><p>2） 为什么说⽼化(Aging)算法是⼀种简单有效的算法，但只是 LRU 的⼀个近似实现？</p><p>\3. 设某计算机的逻辑地址空间和物理地址空间均为 64KB,按字节编址。若某进程最多需要</p><p>6 页(Page)数据存储空间,页的⼤⼩为 1KB,操作系统采⽤固定分配局部置换策略为此进</p><p>程分配 4 个页框(Page Frame)。在时刻 260 前的该进程访问情况如下表所⽰(访问位即</p><p>使⽤位)。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231227225614727.png" alt="image-20231227225614727"></p><p>当该进程执⾏到时刻 260 时,要访问逻辑地址为 17CAH 的数据。请回答下列问题:</p><p>(1) 该逻辑地址对应的页号是多少?</p><p>(2) 若采⽤最近最少使⽤(LRU)置换算法,该逻辑地址对应的物理地址是多少?要求给出计</p><p>算过程。</p><p>\4. 已知某系统页⾯长 4KB，页表项 4B，虚拟地址空间为 64 位，物理地址空间 4GB。</p><p>（1）如采⽤多层分页策略，限定各分层页表最多占 1 页⼤⼩，请问可以采⽤⼏层分页</p><p>策略？</p><p>（2）如采⽤倒排页表⽅式，请问倒排页表的⼤⼩？是每个进程⼀张倒排页表还是系统</p><p>维护⼀张倒排页表？如何解决倒排页表不便于逻辑地址向物理地址转换的问题？11</p><h2 id="五、-简答题"><a href="#五、-简答题" class="headerlink" title="五、 简答题"></a>五、 简答题</h2><p>1、 在虚拟存储管理中，分段式内存管理⽅式解决了分页式内存管理中的什么问题，又</p><p>带来了什么问题呢？</p><p>2、 Intel IA32体系结构中的保护模式是将逻辑地址转成线性地址再转成物理地址，这</p><p>种内存管理⽅式是段页式内存管理⽅式吗，为什么？</p><p>3、 LRU页⾯置换算法是⼀种⽐较优秀的算法但是较难实现，为什么？试给出⼀种可⾏</p><p>的近似算法作为LRU的取代⽅案。</p><p>4、 单纯的分段式和分页式内存管理各有什么缺点？为什么段页式可以避免这些缺点？</p><p>为什么段页式内存管理没有被⼴泛采⽤呢？</p><p>5、 为什么内存管理⽅式中，可变分区管理中有最差适应（worst fit)分配算法，⽽固定</p><p>分区管理中没有这个算法？分区管理中的交换技术（swap）和段式管理中的请求式</p><p>分段技术有什么区别？请求式分段与覆盖技术（overlay）又有什么区别？</p><p>6、 页⾯置换（淘汰）的时机是什么？哪种算法最理想同时也不可能实现？为什么说</p><p>LRU算法很有效但是很难实现？什么是Belady异常？哪种算法存在Belady异常现</p><p>象？</p><p>7、 请讨论⼀下页⾯置换算法中⼯作集（Working Set）置换算法的⼯作原理。</p><p>8、 在内存管理的⽅法中，分段式管理⽐分页式管理有什么优势？段页式与其他⽅式相</p><p>⽐有什么好处？</p><p>9、 为了同时抢占⾼端和中低端市场，CPU ⼚商常常在同⼀⽣产线上⽣产主频和制作⼯</p><p>艺相同的⾼端和低端 CPU，如 Intel 曾经同时⽣产相同主频和制作⼯艺的“奔腾 4”和</p><p>“赛扬”，价格上相差很⼤，据称主要区别在⼆级缓存的⼤⼩。请问缓存（Cache）有</p><p>什么⽤，什么地⽅会⽤到它？12</p><p>10、 为什么要使⽤倒排页表？倒排页表⾯临的最⼤的问题是什么？如何解决？</p><p>11、 内存分区管理中的交换技术与请求式分段技术相⽐，有什么相同点和不同点？</p><p>12、 在页⾯淘汰算法中，为什么说⽼化(Aging)算法只是 LRU 的⼀个近似实现？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存管理习题&quot;&gt;&lt;a href=&quot;#内存管理习题&quot; class=&quot;headerlink&quot; title=&quot;内存管理习题&quot;&gt;&lt;/a&gt;内存管理习题&lt;/h1&gt;&lt;h2 id=&quot;⼀、-选择题&quot;&gt;&lt;a href=&quot;#⼀、-选择题&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些常见加密</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/08/29/++++++m/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/08/29/++++++m/</id>
    <published>2023-08-28T16:00:00.000Z</published>
    <updated>2024-01-18T14:37:50.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Base加密"><a href="#Base加密" class="headerlink" title="Base加密"></a>Base加密</h3><h4 id="Hex-base16"><a href="#Hex-base16" class="headerlink" title="Hex(base16)"></a>Hex(base16)</h4><p>8位二进制–&gt;2个4位字节，长度是源数据的两倍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///encode</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> charset[] = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">convert</span> <span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;<span class="number">0xA</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>+val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>+(val<span class="number">-0xA</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">hex_encode</span><span class="params">(<span class="type">char</span>*<span class="built_in">array</span>,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span>*encode;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">array</span>||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    encode=(<span class="type">char</span>*)<span class="built_in">malloc</span>(size*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        encoded[<span class="number">2</span>*i]=convert((<span class="built_in">array</span>[i]&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xF</span>);</span><br><span class="line">        encode[w*i+<span class="number">1</span>]=convert(<span class="built_in">array</span>[i]&amp;<span class="number">0xF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encode[size*<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> encode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//decode</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">re_convert</span> <span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;<span class="number">0xA</span>)</span><br><span class="line">        <span class="keyword">return</span> val-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> val+<span class="number">0xA</span>-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">hex_decode</span><span class="params">(<span class="type">char</span>*<span class="built_in">array</span>,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">char</span>*decode;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">array</span>||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     encode=(<span class="type">char</span>*)<span class="built_in">malloc</span>((size+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        encoded[<span class="number">2</span>*i]=convert((<span class="built_in">array</span>[i]&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0xF</span>);</span><br><span class="line">        encode[w*i+<span class="number">1</span>]=convert(<span class="built_in">array</span>[i]&amp;<span class="number">0xF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encode[size/<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> decode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> test1[] = &#123;<span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAB</span>, <span class="number">0xCD</span>, <span class="number">0xEF</span>&#125;;</span><br><span class="line"><span class="type">char</span> test2[] = &#123;<span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0x3B</span>, <span class="number">0x5C</span>, <span class="number">0xB9</span>, <span class="number">0xF9</span>, <span class="number">0x0F</span>, <span class="number">0x69</span>, <span class="number">0x61</span>, <span class="number">0x8F</span>,</span><br><span class="line"><span class="number">0x5D</span>, <span class="number">0xE6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *m1t1, *m1t2;</span><br><span class="line">    m1t1 = hex_encode(test1, <span class="keyword">sizeof</span>(test1));</span><br><span class="line">m1t2 = hex_encode(test2, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">    m1t3 = hex_decode(test1, <span class="keyword">sizeof</span>(test1));</span><br><span class="line">m1t4 = hex_decode(test2, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t1: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t2: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t3: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1t4: %s\n&quot;</span>, m1t1);</span><br><span class="line">    <span class="built_in">free</span>(m1t1);</span><br><span class="line"><span class="built_in">free</span>(m1t2);</span><br><span class="line"><span class="built_in">free</span>(m1t3);</span><br><span class="line"><span class="built_in">free</span>(m1t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>编码表长度为64</p><p>编码后的字节数组长度为4的倍数、编码前的4&#x2F;3倍</p><p>编码得到的字符串常以“&#x3D;”结尾（</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</span><br></pre></td></tr></table></figure><p>#变种：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">encoded = <span class="string">&quot;zCN7zTJP3hj71C3BxSj72SuSnhQ=&quot;</span></span><br><span class="line">old = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">new = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ+/&quot;</span></span><br><span class="line">mapper = <span class="built_in">str</span>.maketrans(new, old)</span><br><span class="line">tmp = encoded.translate(mapper)</span><br><span class="line">flag = base64.b64decode(tmp)</span><br><span class="line"><span class="built_in">print</span> (flag.decode())</span><br></pre></td></tr></table></figure><h4 id="Base58"><a href="#Base58" class="headerlink" title="Base58"></a>Base58</h4><p>(少了0,o.l,I,+,&#x2F;)密文不断对58取模（得商和模），直到商为零（辗转相除），模逆向存入</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install base58</span></span><br><span class="line"><span class="keyword">import</span> base58</span><br><span class="line">enflag = <span class="string">&quot;2NEpo7TZRRrLZSi2U&quot;</span></span><br><span class="line"><span class="built_in">print</span>(base58.b58decode(enflag))</span><br></pre></td></tr></table></figure><h3 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h3><p>流加密，密钥长度变，加解密使用相同密钥，<strong>属于对称加密</strong>，<strong>有线等效加密</strong>（WEP）中使用得加密算法，</p><h5 id="S盒初始化"><a href="#S盒初始化" class="headerlink" title="S盒初始化"></a>S盒初始化</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">S[i]:=i <span class="comment">#?</span></span><br><span class="line">endfor</span><br><span class="line"></span><br><span class="line">j:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">j:=(j+S[i]+KEY[i mod key_len]) mod <span class="number">256</span>  <span class="comment">#256次for循环 #根据密钥打乱S盒</span></span><br><span class="line">    swap(S[i],S[j])</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h5 id="密钥流生成"><a href="#密钥流生成" class="headerlink" title="密钥流生成"></a>密钥流生成</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> GeneratingOutput</span><br><span class="line">i := (i + <span class="number">1</span>) mod <span class="number">256</span></span><br><span class="line">j := (j + S[i]) mod <span class="number">256</span></span><br><span class="line">swap(S[i], S[j])</span><br><span class="line">send(S[S[i]+S[j]mod <span class="number">256</span>]) to stream</span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure><h5 id="流加密"><a href="#流加密" class="headerlink" title="流加密"></a>流加密</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to plain_len  <span class="comment">#便利输入明文的每个字节，从s盒中去一个字节与之亦或，完成加密</span></span><br><span class="line">plain[i]^=stream[i]</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&quot;hello world&quot;</span></span><br><span class="line">cipher = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;A0 E2 BA F4 B5 02 ED 9B 41 2F E6 23&quot;</span>)</span><br><span class="line">rc4 = ARC4.new(key)</span><br><span class="line">plain = rc4.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span>(plain)</span><br></pre></td></tr></table></figure><p>特点：<br>前期准备很多很长</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>一般有两种形式的调用，一种是直接封装成一个函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8_t digest[<span class="number">16</span>];</span><br><span class="line">uint8_t <span class="built_in">input</span>[] = <span class="string">&quot;xxxxxxx&quot;</span>;</span><br><span class="line">MD5_hash(<span class="built_in">input</span>, sizeof(<span class="built_in">input</span>) - <span class="number">1</span>, digest);</span><br></pre></td></tr></table></figure><p>另一种是分三步完成哈希：</p><p>openssl</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MD5_CTX ctx;</span><br><span class="line">uint8_t digest[<span class="number">16</span>];</span><br><span class="line">uint8_t <span class="built_in">input</span>[] = <span class="string">&quot;xxxxxxx&quot;</span>;</span><br><span class="line">MD5_Init(&amp;ctx);</span><br><span class="line">MD5_Update(&amp;ctx, <span class="built_in">input</span>, sizeof(<span class="built_in">input</span>) - <span class="number">1</span>);</span><br><span class="line">MD5_Final(&amp;ctx, digest);</span><br></pre></td></tr></table></figure><p>在函数实现中，可以在靠近开头的位置看到几个特殊的常量</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0x67452301</span>;</span><br><span class="line">B = <span class="number">0xEFCDAB89</span>;</span><br><span class="line">C = <span class="number">0x98BADCFE</span>;</span><br><span class="line">D = <span class="number">0X10325476</span>;</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><p><strong>四个</strong>固定的常量（初始化向量）</p></li><li><p>不论输入是多长，输出永远是 <strong>16</strong> 字节</p></li><li><p>符合上述两种调用方式之一</p></li></ul><p><strong>逆向方式：</strong></p><ul><li><p>脚本爆破</p></li><li><p>查询网站：</p><ul><li>cmd5</li><li>[somd5][<a href="https://www.somd5.com/]">https://www.somd5.com/]</a></li></ul></li><li><p>hashcat 使用</p></li></ul><h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h4><p>五个常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H0 = 0x67452301</span><br><span class="line">H1 = 0xEFCDAB89</span><br><span class="line">H2 = 0x98BADCFE</span><br><span class="line">H3 = 0x10325476</span><br><span class="line">H4 = 0xC3D2E1F0</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><strong>五个</strong>固定的常量（初始化向量）</li><li>不论输入是多长，输出永远是 <strong>20</strong> 字节</li><li>符合上述两种调用方式之一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">target = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;ee 93 50 b8 86 a1 ba be c0 26 39 e4 7f 8b d2 a2 c1 22 3e a7&quot;</span>)</span><br><span class="line">charset = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(charset.repeat=<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> hashlib.sha1(<span class="built_in">bytes</span>(i)).digest()==tarfet:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">bytes</span>(i))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="sha-224-28个字节"><a href="#sha-224-28个字节" class="headerlink" title="sha_224 28个字节"></a>sha_224 28个字节</h4><h4 id="SHA-256"><a href="#SHA-256" class="headerlink" title="SHA-256"></a>SHA-256</h4><p>256&#x2F;8&#x3D;32</p><p>八个常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">H0 = 0x6a09e667</span><br><span class="line">H1 = 0xbb67ae85</span><br><span class="line">H2 = 0x3c6ef372</span><br><span class="line">H3 = 0xa54ff53a</span><br><span class="line">H4 = 0x510e527f</span><br><span class="line">H5 = 0x9b05688c</span><br><span class="line">H6 = 0x1f83d9ab</span><br><span class="line">H7 = 0x5be0cd19</span><br></pre></td></tr></table></figure><p><strong>识别特征：</strong></p><ul><li><p>八个固定的常量（初始化向量）</p></li><li><p>不论输入是多长，输出永远是 <strong>32</strong> 字节</p></li><li><p>符合上述两种调用方式之一</p></li></ul><h3 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h3><p>[0x9e3779B9和0x61c88647]</p><p>识别特征：</p><p>标准 DELTA 常数（魔数）</p><p>密钥为 16 字节（4 个 DWORD）</p><p>加密轮数为 16&#x2F;32&#x2F;64 轮</p><p>加密结构中存在左 4 右 5 移位及异或运算</p><p>加密结构中存在轮加&#x2F;减相同常数的语句</p><p>对抗方式：</p><p>修改魔数</p><p>修改轮数</p><p>修改轮加&#x2F;减魔数的位置</p><h4 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h4><p>识别特征：</p><p>同 TEA</p><p>加密结构中存在右移 11 位并 &amp; 3 的运算</p><h4 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a><strong>XXTEA</strong></h4><p>XXTEA 是 XTEA 的升级版，其实现过程比前两种算法要略显复杂些，加密的明文数据可以不再是</p><p>64bit（两个 32 位无符号整数），并且其加密轮数是由 n，即待加密数据个数决定的。</p><p>识别特征基本同 TEA，但是加密轮数通过计算求得（6 + 52&#x2F;n）</p><h2 id="分组加密算法"><a href="#分组加密算法" class="headerlink" title="分组加密算法"></a>分组加密算法</h2><h3 id="常见工作模式"><a href="#常见工作模式" class="headerlink" title="常见工作模式"></a>常见工作模式</h3><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171156586.png" alt="image-20231112171156586"></p><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171208459.png" alt="image-20231112171208459"></p><h3 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171319806.png" alt="image-20231112171319806"></p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171443392.png" alt="image-20231112171443392"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171507346.png" alt="image-20231112171507346"></p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20231112171515871.png" alt="image-20231112171515871"></h3><p>S：637c77 </p><p>16-10</p><p>24-12</p><p>32-14</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Base加密&quot;&gt;&lt;a href=&quot;#Base加密&quot; class=&quot;headerlink&quot; title=&quot;Base加密&quot;&gt;&lt;/a&gt;Base加密&lt;/h3&gt;&lt;h4 id=&quot;Hex-base16&quot;&gt;&lt;a href=&quot;#Hex-base16&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="密码 特征" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E5%AF%86%E7%A0%81-%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/06/25/Misc%EF%BC%9AMiscMasc%EF%BC%81/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/06/25/Misc%EF%BC%9AMiscMasc%EF%BC%81/</id>
    <published>2023-06-24T16:28:47.159Z</published>
    <updated>2023-07-05T14:29:52.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Misc：MiscMasc！"><a href="#Misc：MiscMasc！" class="headerlink" title="Misc：MiscMasc！"></a>Misc：MiscMasc！</h1><h2 id="适合作为桌面"><a href="#适合作为桌面" class="headerlink" title="适合作为桌面"></a>适合作为桌面</h2><p><a href="http://t.csdn.cn/XsnrR">http://t.csdn.cn/XsnrR</a></p><p>题解</p><pre><code>单纯从图片观察，未发现线索；右键使用记事本打开，依然未发现 flag 字样；考虑图片隐写，启动 Stegsolve ，加载图片；直接切换图片，在 red plane 1 中，可以看到，图片左上角出现了一个二维码。（图片隐写大概率可能还会涉及到数据提取，这道题比较基础，所以直接切换就可以看到）识别该二维码，在线条码解析，记得选择二维码，然后 read 读取；扫描结果是一串十六进制的数字；启动 winhex 进行解码，选择 AscII Hex虽然解析出来是乱码，但是根据这些关键字可以推断出，这应该是一个 python 被编译之后的 pyc 文件将其保存为 pyc 文件启动 easy python decompiler 对其进行反编译反编译会在 pyc 文件所在目录下生成这个文件将其后缀改为 py 使用 vscode 打开，发现实际上是一个名为 flag 的 python 方法，但并无调用语句，于是自己加上一行代码，调用这个方法找到 flag</code></pre><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>拿题目</p><p>首先还是分析题目，看看从题目中能发现什么蛛丝马迹。这是一道“13掌”打架题。先下载附加看看。</p><p> 与佛论禅</p><p>附件里面是一段看不懂的文字，但是正常的应该能看出这应该是一段佛文。</p><p>立马想到【与佛论禅】</p><p>复制解密一下：注意格式一定要加上：【佛曰：】进行解密，得到密文：{MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9}</p><p>十三掌解密</p><p>上面的第一步解密完成，但是输入进去是一个错误的flag，继续分析题干。题干上有一个比较明显的提示：【如来十三掌】。</p><p>必须很快的想到要进行rot13解码：解码得到{ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9}</p><p>输入依然不是正确的flag。</p><p>Base64解密</p><p>从13掌中得到的密文后，我们再进行一个Base64解密得到最终flag。flag{bdscjhbkzmnfrdhbvckijndskvbkjdsab}<br>————————————————<br>版权声明：本文为CSDN博主「Jum朱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_22903531/article/details/117768461">https://blog.csdn.net/qq_22903531/article/details/117768461</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Misc：MiscMasc！&quot;&gt;&lt;a href=&quot;#Misc：MiscMasc！&quot; class=&quot;headerlink&quot; title=&quot;Misc：MiscMasc！&quot;&gt;&lt;/a&gt;Misc：MiscMasc！&lt;/h1&gt;&lt;h2 id=&quot;适合作为桌面&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/06/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/06/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89/</id>
    <published>2023-06-21T14:12:23.277Z</published>
    <updated>2023-07-24T13:37:04.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言（王爽）"><a href="#汇编语言（王爽）" class="headerlink" title="汇编语言（王爽）"></a>汇编语言（王爽）</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>机器语言与机器指令 ：（eg）1000100111011000</p><p>汇编语言的主体是汇编指令</p><h4 id="CPU对存储器的读写："><a href="#CPU对存储器的读写：" class="headerlink" title="CPU对存储器的读写："></a>CPU对存储器的读写：</h4><ul><li>CPU想要进行数据的读写，必须和外部器件进行三类信息的交互：<ul><li>存储单元的地址（地址信息）</li><li>期间的选择、读或写命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul></li></ul><p> 将各类存储器看作一个逻辑存储器——统一编址</p><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><ul><li><p>主存储器地址空间</p><ul><li>RAM主存储器</li><li>ROM装有系统BIOS（来自最后一点）</li><li>RAM主存储器</li></ul></li><li><p>显存地址空间</p><ul><li>RAM显存</li></ul></li><li><p>显卡BIOS ROM地址空间</p><ul><li>ROM装有显卡BIOS</li></ul></li><li><p>网卡BIOS ROM地址空间</p><ul><li>ROM装有网卡BIOS</li></ul></li><li><p>系统BIOS ROM地址空间</p></li></ul><p>物理地址&#x3D;短地址*16+偏移地址</p><p>内存没有分段，段的划分来自于CPU </p><h2 id="汇编语言程序"><a href="#汇编语言程序" class="headerlink" title="汇编语言程序"></a>汇编语言程序</h2><h2 id="内存寻址方式"><a href="#内存寻址方式" class="headerlink" title="内存寻址方式"></a>内存寻址方式</h2><h2 id="流程转移与子程序"><a href="#流程转移与子程序" class="headerlink" title="流程转移与子程序"></a>流程转移与子程序</h2><h2 id="中断及其应用"><a href="#中断及其应用" class="headerlink" title="中断及其应用"></a>中断及其应用</h2><h2 id="高级汇编语言技术"><a href="#高级汇编语言技术" class="headerlink" title="高级汇编语言技术"></a>高级汇编语言技术</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编语言（王爽）&quot;&gt;&lt;a href=&quot;#汇编语言（王爽）&quot; class=&quot;headerlink&quot; title=&quot;汇编语言（王爽）&quot;&gt;&lt;/a&gt;汇编语言（王爽）&lt;/h1&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>程序设计综合实践练习</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/04/13/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/04/13/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0/</id>
    <published>2023-04-12T16:00:00.000Z</published>
    <updated>2023-04-15T08:56:13.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序设计综合实践练习"><a href="#程序设计综合实践练习" class="headerlink" title="程序设计综合实践练习"></a>程序设计综合实践练习</h1><p>[TOC]</p><h2 id="一，基础算法1"><a href="#一，基础算法1" class="headerlink" title="一，基础算法1"></a>一，基础算法1</h2><h3 id="1249-士兵队列训练问题"><a href="#1249-士兵队列训练问题" class="headerlink" title="1249: 士兵队列训练问题"></a>1249: 士兵队列训练问题</h3><p><strong>题目描述</strong></p><p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。</p><p><strong>输入</strong></p><p>​本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。</p><p><strong>输出</strong></p><p>​共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。</p><p><strong>样例输入</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">20</span><br><span class="line">40</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 7 19</span><br><span class="line">1 19 37</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解决</strong></p><p>tmp的vector不断更新，count根据奇偶性改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, count = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">soldiers</span>(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">soldiers[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (soldiers.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line"><span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; soldiers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(soldiers[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; soldiers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(soldiers[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">soldiers = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; soldiers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; soldiers[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1198-斐波那契数列"><a href="#1198-斐波那契数列" class="headerlink" title="1198: 斐波那契数列"></a>1198: 斐波那契数列</h3><p><strong>题目描述</strong></p><p>斐波那契数列中, a0&#x3D;0, a1&#x3D;1, ,对于k &gt; 1,  ak &#x3D; ak-1 + ak-2 求出斐波那契数列的第n项。</p><p><strong>输入</strong></p><p>第一行输入一个整数T表示样例个数,对于每个样例,输入一个整数n表示需要求出第n项斐波那契数字。</p><p><strong>输出</strong></p><p><strong>对</strong>于每个样例,输出一个数字num表示第n项斐波那契数字。</p><p><strong>样例输入</strong>             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>n &lt;&#x3D; 60</p><p><strong>思路&amp;解答</strong></p><p>dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fib</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        fib[<span class="number">0</span>] = <span class="number">0</span>, fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; fib[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1544-数值问题-高精度加法"><a href="#1544-数值问题-高精度加法" class="headerlink" title="1544: [数值问题]高精度加法"></a>1544: [数值问题]高精度加法</h3><p><strong>题目描述</strong></p><p>​ 输入两个高精度正整数a和b（a，b的位数&lt;&#x3D;200），求这两个数的和 </p><p><strong>输入</strong></p><p>输入共两行，分别为a和b</p><p><strong>输出</strong></p><p>输出共一行，表示两个数的和。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1111111111111111111111111111111111</span><br><span class="line">9999999999999999999999999999999999</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111111110</span><br></pre></td></tr></table></figure><p><strong>思考&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">reverse</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">size</span>(), len2 = b.<span class="built_in">size</span>();</span><br><span class="line">    a = <span class="built_in">reverse</span>(a); b = <span class="built_in">reverse</span>(b);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1||j&lt;len2)&#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1) &#123;</span><br><span class="line">            sum += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; len2) &#123;</span><br><span class="line">            sum += b[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        sum %= <span class="number">10</span>;</span><br><span class="line">        res += (sum + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        res += carry + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverse</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(a,b) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1237-三角形个数"><a href="#1237-三角形个数" class="headerlink" title="1237: 三角形个数"></a>1237: 三角形个数</h3><p><strong>题目描述</strong></p><p>​ 小b有一个仅包含非负整数的数组a，她想知道有多少个三元组(i,j,k)，满足i&lt;j&lt;k且a[i],a[j],a[k]可能作为某个三角形的三条边的边长。 </p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个正整数n，表示数组a中元素个数；</span><br><span class="line">第二行n个非负整数，表示a中元素，以空格隔开；</span><br><span class="line">其中0＜n≤1000，a中任意元素a[i]满足0≤a[i]≤1000。</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个数，表示满足题意的三元组个数</span><br></pre></td></tr></table></figure><p><strong>样例输入</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>               </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>思考&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; n &amp;&amp; a[i] + a[j] &gt; a[k]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += k - j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1234-找零"><a href="#1234-找零" class="headerlink" title="1234: 找零"></a>1234: 找零</h3><p><strong>题目描述</strong></p><p>​假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？如果无法支付K元，则输出-1。  </p><p><strong>输入</strong></p><p>输入第一行为一个整数T，表示样例个数。<br> 对于每个样例，第一行输入一个整数N表示需要找零的钱数，第二行输入7个整数表示每个纸币拥有的数量，分别表示1,2,5,10,20,50,100纸币的个数。</p><p><strong>输出</strong></p><p>对于每个样例，输出一个数字表示最少找零个数，输出-1表示无法找开。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">107</span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">200</span><br><span class="line">1 1 1 1 1 0 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>数据保证贪心可解。</p><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### <span class="number">1199</span>: 汉诺塔      </span><br><span class="line"></span><br><span class="line">**题目描述**</span><br><span class="line"></span><br><span class="line">汉诺塔(又称河内塔)问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子,在一根柱子上从下往上按照大小顺序摞着<span class="number">64</span>片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定,在小圆盘上不能放大圆盘,在三根柱子之间一次只能移动一个圆盘。</span><br><span class="line"></span><br><span class="line">**输入**</span><br><span class="line"></span><br><span class="line">第一行包含一个整数T表示样例数。</span><br><span class="line"> 对于每个样例,输入一个n表示汉诺塔的级数。</span><br><span class="line"></span><br><span class="line">**输出**</span><br><span class="line"></span><br><span class="line">对于每个样例,输出一个整数表示最少需要移动的次数。</span><br><span class="line"></span><br><span class="line">**样例输入**           复制          </span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">**样例输出**          复制          </span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">**提示**</span><br><span class="line"></span><br><span class="line">n &lt;= <span class="number">40</span></span><br><span class="line"></span><br><span class="line">**思路&amp;解答**</span><br><span class="line"></span><br><span class="line">~~~C++</span><br></pre></td></tr></table></figure><h3 id="1219-绝对值排序"><a href="#1219-绝对值排序" class="headerlink" title="1219: 绝对值排序"></a>1219: 绝对值排序</h3><p><strong>题目描述</strong></p><p>输入n(n&lt;&#x3D;100)个整数，按照绝对值从大到小排序后输出。题目保证对于每一个测试实例，所有的数的绝对值都不相等。</p><p><strong>输入</strong></p><p>输入数据有多组，每组占一行，每行的第一个数字为n,接着是n个整数，n&#x3D;0表示输入数据的结束，不做处理。</p><p><strong>输出</strong></p><p>​对于每个测试实例，输出排序后的结果，两个数之间用一个空格隔开。每个测试实例占一行。</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 3 -4 2</span><br><span class="line">4 0 1 2 -3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-4 3 2</span><br><span class="line">-3 2 1 0</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ssort</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(b) &gt; <span class="built_in">abs</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">1010</span>];</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b,b+a,ssort);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二，基础算法2"><a href="#二，基础算法2" class="headerlink" title="二，基础算法2"></a>二，基础算法2</h2><h3 id="1110-最多水容器"><a href="#1110-最多水容器" class="headerlink" title="1110: 最多水容器"></a>1110: 最多水容器</h3><p><strong>题目描述</strong></p><p>给定一个数组, 每个数值代表柱子的高度, 那么求出这些柱子最多可以装多少水. 水的体积由较短的长度乘以两个柱子的距离.<br><img src="https://justyy.com/wp-content/uploads/2018/07/container-with-most-water-leetcode-puzzle-coding-exercise.jpg" alt="container-with-most-water-leetcode-puzzle-coding-exercise C++ 编程练习题 - 最多水容器 (递归) ACM题解 程序设计 " style="zoom:50%;" /></p><p><strong>输入</strong></p><p>第一行输入一个数字N表示容器个数。第二行输入N个使用空格间隔的整数，表示容器高度。 </p><p><strong>输出</strong></p><p>输出一个数字表示最多装水量。</p><p><strong>样例输入</strong>                     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1 8 6 2 5 4 8 3 7</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>2 &lt;&#x3D; N &lt;&#x3D; 10</p><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];<span class="comment">//放外面不需要赋零</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j+<span class="number">1</span>; k &lt; m; k++) &#123;</span><br><span class="line"><span class="type">int</span> tmp = (<span class="built_in">min</span>(a[j], a[k]) * (k - j));</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; sum)sum = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1197-区间和统计"><a href="#1197-区间和统计" class="headerlink" title="1197: 区间和统计"></a>1197: 区间和统计</h3><p><strong>题目描述</strong></p><p>给定一个包含n个元素的数组,数组中元素ai保证 -1000 &lt; ai &lt; 1000。在数组中,从l到r(l &lt;&#x3D; r)的所有数叫做数组的一个[l, r]子区间,你需要求出,所有子区间中,和为k的区间一共有多少个。</p><p><strong>输入</strong></p><p>第一行包含一个整数T表示样例个数。<br> 对于每一个样例,第一行输入两个数字,n, p其中n表示数组的长度, p代表区间和。<br> 第二行包含n个数字表示数组的元素。</p><p><strong>输出</strong></p><p>对于每一个样例,输出一个数字表示和为p的子区间个数。</p><p><strong>样例输入</strong>                     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 8</span><br><span class="line">4 4 4 4 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>所有的ai均为整数。<br> 保证 n &lt;&#x3D; 1000</p><p><strong>思路&amp;解答</strong></p><p><strong>遍历数组，计算前缀和</strong></p><p>用哈希表记录前缀和出现的次数，对于i，如果前缀和prefix_sum[i]-p在哈希表中已经出现过了，说明从上一个出现该前缀和的位置到当前位置的子数组和为p，将这些子数组的数量累加到res中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],prefix_sum[<span class="number">1010</span>];<span class="comment">//放外面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, p;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">//哈希表记录前缀和出现的次数</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            prefix_sum[i + <span class="number">1</span>] = prefix_sum[i] + a[i];</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(prefix_sum[i + <span class="number">1</span>] - p)) &#123; </span><br><span class="line">                res += mp[prefix_sum[i + <span class="number">1</span>] - p]; </span><br><span class="line"><span class="comment">//将上一个出现该前缀和的位置到当前位置的子数组和为p的数量累加到结果中 &#125;</span></span><br><span class="line">            mp[prefix_sum[i + <span class="number">1</span>]]++; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1125-子矩阵求和"><a href="#1125-子矩阵求和" class="headerlink" title="1125:子矩阵求和"></a>1125:子矩阵求和</h3><p><strong>思路&amp;解答</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> M, N, Q;</span><br><span class="line">cin &gt;&gt; M &gt;&gt; N &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; Q; k++) &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num1, num2, num3, num4;</span><br><span class="line">cin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3 &gt;&gt; num4;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i1 = <span class="built_in">min</span>(num1, num3); i1 &lt;= <span class="built_in">max</span>(num1, num3); i1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j1 = <span class="built_in">min</span>(num2, num4); j1 &lt;= <span class="built_in">max</span>(num2, num4); j1++)</span><br><span class="line">sum += a[i1][j1];<span class="comment">//最大值最小值转化为标准型去计算</span></span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1126-选择排序"><a href="#1126-选择排序" class="headerlink" title="1126: 选择排序"></a>1126: 选择排序</h3><p><strong>题目描述</strong></p><p>给你一个序列，按照从小到大的顺序重新排列，要求使用选择排序</p><p><strong>输入</strong></p><p>​第一行是一个正整数m，代表测试样例的个数<br>     对于每组测试样例，输入一行数字，第一个数字m，代表这组样例中数字的个数，接下来的m个数字代表所给序列 </p><p><strong>输出</strong></p><p>对于每组输出样例，输出一行，输出按照从小到大顺序排列的结果</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2 1</span><br><span class="line">5</span><br><span class="line">9 5 1 4 3</span><br><span class="line">6</span><br><span class="line">2 3 8 1 5 6</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3 4 5 9</span><br><span class="line">1 2 3 5 6 8</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[min_idx]);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="type">int</span> arr[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">selectionSort</span>(arr, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1257-前m大的数"><a href="#1257-前m大的数" class="headerlink" title="1257: 前m大的数"></a>1257: 前m大的数</h3><p><strong>题目描述</strong></p><p>还记得Gardon给小希布置的那个作业么？其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。<br>     给定一个包含N(N&lt;&#x3D;3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)&#x2F;2个和，求出其中前M大的数(M&lt;&#x3D;1000)并按从大到小的顺序排列。 </p><p><strong>输入</strong></p><p>输入可能包含多组数据，其中每组数据包括两行：<br> 第一行两个数N和M，<br> 第二行N个数，表示该序列。 </p><p><strong>输出</strong></p><p>对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 3 4</span><br><span class="line">4 5</span><br><span class="line">5 3 6 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 6 5 5</span><br><span class="line">11 10 9 9 8</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3010</span>]; <span class="type">int</span> b[<span class="number">5000000</span>];<span class="comment">//注意开对数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; a;<span class="comment">//从大到小是&lt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> uu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; m; k++) &#123;</span><br><span class="line">b[uu] = a[j] + a[k];</span><br><span class="line">uu++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b, b + m*(m<span class="number">-1</span>)/<span class="number">2</span>, tmp);<span class="comment">//先出结果再排序，放心，够用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">cout &lt;&lt; b[u] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1238-Greed"><a href="#1238-Greed" class="headerlink" title="1238: Greed"></a>1238: Greed</h3><p><strong>题目描述</strong></p><p>​Jafar has <em>n</em> cans of cola. Each can is described by two integers: remaining volume of cola <em>ai</em> and can’s capacity <em>bi</em> (<em>ai</em> ≤  <em>bi</em>). </p><p>​Jafar has decided to pour all remaining cola into just 2 cans, determine if he can do this or not! </p><p> Jafar has n cans of cola. Each can is described by two integers: remaining volume of cola ai and can’s capacity bi (ai  ≤    ≤  bi). Jafar has decided to pour all remaining cola into just 2 cans, determine if he can do this or not! </p><p> 贾法尔有n罐可乐。每个罐由两个整数描述：可乐的剩余体积ai和罐的容量bi（ai ≤    ≤ bi）。 贾法尔决定把所有剩下的可乐倒进两个罐子里，看看他能不能做到！ </p><p><strong>输入</strong></p><p>​The first line of the input contains one integer <em>n</em> (2 ≤ <em>n</em> ≤ 100 000) — number of cola cans. </p><p>​The second line contains <em>n</em> space-separated integers <em>a, *a, …, *an</em>* (0 ≤ *ai*) — volume of remaining cola in cans.<br>*</p><p>​The third line contains <em>n</em> space-separated integers that <em>b, *b, …, *bn</em>* (*ai** ≤ <em>bi</em>) — capacities of the cans. </p><p>输入的第一行包含一个整数n（2 ≤（2 ≤ n ≤ 100 000）-可乐罐的数量。 第二行包含n个空格分隔的整数a，a，… an（0 ≤ ai）-罐中剩余可乐的体积。 第三行包含n个空格分隔的整数，B，…，B，…bn（ai彡bi）-罐的容量。 </p><p><strong>输出</strong></p><p>​Print “YES” (without quotes) if it is possible to pour all remaining cola in 2 cans. Otherwise print “NO” (without quotes). </p><p>​You can print each letter in any case (upper or lower). </p><p>如果可以将剩余的可乐倒入2罐，请打印“YES”（不带引号）。否则打印“NO”（不带引号）。 您可以在任何情况下打印每个字母（上部或下部）。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><p><strong>思路解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">int</span> cans[<span class="number">1009</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//vecctor存储每个罐子信息</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cans</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; cans[i].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; cans[i].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(cans.<span class="built_in">begin</span>(), cans.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> total_vol = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    total_vol += cans[i].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_vol &lt;= cans[<span class="number">0</span>].second + cans[<span class="number">1</span>].second) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1239-珠心算测验"><a href="#1239-珠心算测验" class="headerlink" title="1239: 珠心算测验"></a>1239: 珠心算测验</h3><p><strong>题目描述</strong></p><p>​珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。 </p><p>​某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？ </p><p>​最近老师出了一些测验题，请你帮忙求出答案。 </p><p>​</p><p><strong>输入</strong></p><p>共两行，第一行包含一个整数n<em>n</em>，表示测试题中给出的正整数个数。 第二行有n<em>n</em>个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。 </p><p><strong>输出</strong></p><p>一个整数，表示测验题答案。</p><p><strong>样例输入</strong>                    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>由1+2&#x3D;3,1+3&#x3D;41+2&#x3D;3,1+3&#x3D;4，故满足测试要求的答案为22。 注意，加数和被加数必须是集合中的两个不同的数。 </p><p> n &lt;&#x3D; 1000，集合中所有的数字保证小于等于1e7.</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> a[<span class="number">10000009</span>]; <span class="type">int</span> b[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">cin &gt;&gt; b[i]; a[b[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[b[i] + b[j]] == <span class="number">1</span>) &#123; ans++; a[b[i] + b[j]] = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1236-Monthly-Expense"><a href="#1236-Monthly-Expense" class="headerlink" title="1236: Monthly Expense"></a>1236: Monthly Expense</h3><p><strong>题目描述</strong></p><p>​给出n天中每天的花费，需要将这些天分成m组，每组包含连续的一或多天，若第i组的花费为Ki，求一种分组方法使得K&#x3D;max{Ki}最小。 </p><p><strong>输入</strong></p><p>​输入数据第一行为两个正整数N和M，之后输入N个正整数，分别表示第i天的费用。输出包含一行，表示上面描述的K。 </p><p><strong>输出</strong></p><p>对于每组数据，输出一个数表示最小的花费。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 5</span><br><span class="line">100</span><br><span class="line">400</span><br><span class="line">300</span><br><span class="line">100</span><br><span class="line">500</span><br><span class="line">101</span><br><span class="line">400</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>n &lt;&#x3D; 100. </p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], sum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum[i] - sum[pre] &gt; x) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            pre = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">            r += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，数据结构"><a href="#三，数据结构" class="headerlink" title="三，数据结构"></a>三，数据结构</h2><h3 id="1330-ip转换"><a href="#1330-ip转换" class="headerlink" title="1330: ip转换"></a>1330: ip转换</h3><p><strong>题目描述</strong></p><p>在进行基于ipv4协议的网络通讯时，用长度为32的信号表示ip地址。为了便于使用，通常会将32位信号转换为4个长度为8的信号。<br> 例如: 01111111000000000000000000000001会被转化为 127.0.0.1</p><p> 现在给出一系列ip地址的二进制表示，需要转化为它的对应十进制便于阅读的表示方式，即a.b.c.d形式。</p><p><strong>输入</strong></p><p>第一行包含一个整数T表示样例个数<br> 对于每个样例，输入一个长度为32的二进制串表示ip地址。 </p><p><strong>输出</strong></p><p>对于每个样例，输出一行字符串表示便于阅读的ip地址。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="function">bitset&lt;32&gt; <span class="title">bs</span><span class="params">(s)</span></span>; <span class="comment">// 将二进制串转换为位集</span></span><br><span class="line">        <span class="comment">// 通过位运算获取四个字节的值</span></span><br><span class="line">        <span class="type">int</span> a = (bs.<span class="built_in">to_ulong</span>() &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> b = (bs.<span class="built_in">to_ulong</span>() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> c = (bs.<span class="built_in">to_ulong</span>() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> d = bs.<span class="built_in">to_ulong</span>() &amp; <span class="number">0xFF</span>;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; d &lt;&lt; endl; <span class="comment">// 输出点分十进制表示的 IP 地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1337-进制转换"><a href="#1337-进制转换" class="headerlink" title="1337: 进制转换"></a>1337: 进制转换</h3><p><strong>题目描述</strong></p><p>输入一个十进制数N，将它转换成R进制数输出。</p><p><strong>输入</strong></p><p>输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;&#x3D;R&lt;&#x3D;16, R&lt;&gt;10）。</p><p><strong>输出</strong></p><p>为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> is_negative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        is_negative = <span class="literal">true</span>;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> digit = n % r;</span><br><span class="line">        <span class="keyword">if</span> (digit &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            result += <span class="built_in">to_string</span>(digit);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">&#x27;A&#x27;</span> + digit - <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n /= r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (is_negative) &#123;</span><br><span class="line">        result = <span class="string">&quot;-&quot;</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, r;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; r) &#123;</span><br><span class="line">        string result = <span class="built_in">convert</span>(n, r);</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1206-简单计算器"><a href="#1206-简单计算器" class="headerlink" title="1206: 简单计算器"></a>1206: 简单计算器</h3><p><strong>题目描述</strong></p><p>读入一个只包含 +, -, *, &#x2F; 的非负整数计算表达式，计算该表达式的值。 </p><p><strong>输入</strong></p><p>测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 </p><p><strong>输出</strong></p><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_priority</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span> || op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">do_operation</span><span class="params">(<span class="type">double</span> left, <span class="type">double</span> right, <span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left - right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left * right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluate_expression</span><span class="params">(<span class="type">const</span> string&amp; expr)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; num_stack;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; op_stack;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = expr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// Skip spaces</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; expr[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read a number</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[i])) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; (<span class="built_in">isdigit</span>(expr[j]) || expr[j] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> num = <span class="built_in">stod</span>(expr.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">            num_stack.<span class="built_in">push</span>(num);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Read an operator</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;+&#x27;</span> || expr[i] == <span class="string">&#x27;-&#x27;</span> || expr[i] == <span class="string">&#x27;*&#x27;</span> || expr[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">char</span> op = expr[i];</span><br><span class="line">            <span class="keyword">while</span> (!op_stack.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">get_priority</span>(op_stack.<span class="built_in">top</span>()) &gt;= <span class="built_in">get_priority</span>(op)) &#123;</span><br><span class="line">                <span class="type">double</span> right = num_stack.<span class="built_in">top</span>();</span><br><span class="line">                num_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">double</span> left = num_stack.<span class="built_in">top</span>();</span><br><span class="line">                num_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">char</span> prev_op = op_stack.<span class="built_in">top</span>();</span><br><span class="line">                op_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">double</span> result = <span class="built_in">do_operation</span>(left, right, prev_op);</span><br><span class="line">                num_stack.<span class="built_in">push</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">            op_stack.<span class="built_in">push</span>(op);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Skip other characters</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!op_stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">double</span> right = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">double</span> left = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">char</span> op = op_stack.<span class="built_in">top</span>();</span><br><span class="line">        op_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">do_operation</span>(left, right, op);</span><br><span class="line">        num_stack.<span class="built_in">push</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num_stack.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string expr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, expr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">evaluate_expression</span>(expr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1207-队列和栈"><a href="#1207-队列和栈" class="headerlink" title="1207: 队列和栈"></a>1207: 队列和栈</h3><p><strong>题目描述</strong></p><p>​ 队列和栈是两种重要的数据结构，它们具有push k和pop操作。push k是将数字k加入到队列或栈中，pop则是从队列和栈取一个数出来。队列和栈的区别在于取数的位置是不同的。</p><pre><code>  队列是先进先出的：把队列看成横向的一个通道，则push k是将k放到队列的最右边，而pop则是从队列的最左边取出一个数。    栈是后进先出的：把栈也看成横向的一个通道，则push k是将k放到栈的最右边，而pop也是从栈的最右边取出一个数。    假设队列和栈当前从左至右都含有1和2两个数，则执行push 5和pop操作示例图如下：         push 5     pop    队列 1 2 -------&gt; 1 2 5 ------&gt; 2 5         push 5     pop    栈  1 2 -------&gt; 1 2 5 ------&gt; 1 2   现在，假设队列和栈都是空的。给定一系列push k和pop操作之后，输出队列和栈中存的数字。若队列或栈已经空了，仍然接收到pop操作，则输出error。  </code></pre><p><strong>输入</strong></p><p>第一行为m，表示有m组测试输入，m&lt;100。<br> 每组第一行为n，表示下列有n行push k或pop操作。（n&lt;150）<br> 接下来n行，每行是push k或者pop，其中k是一个整数。<br>     （输入保证同时在队列或栈中的数不会超过100个） </p><p><strong>输出</strong></p><p>​对每组测试数据输出两行，正常情况下，第一行是队列中从左到右存的数字，第二行是栈中从左到右存的数字。若操作过程中队列或栈已空仍然收到pop，则输出error。输出应该共2*m行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            string op;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> k;</span><br><span class="line">                cin &gt;&gt; k;</span><br><span class="line">                q.<span class="built_in">push</span>(k);</span><br><span class="line">                s.<span class="built_in">push</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">empty</span>() || s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出队列中的数字</span></span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;error&quot;</span>&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出栈中的数字</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1325-报数"><a href="#1325-报数" class="headerlink" title="1325: 报数"></a>1325: 报数</h3><p><strong>题目描述</strong></p><p>今天一共n位同学参加了TIEI期末考试，大家计划在期末考试后在教室玩一个游戏，n个同学编号1-n后围成一圈报数，报到7的倍数的同学将被移出队伍，然后下一位同学继续现在的报数。当剩余人数少于7时结束游戏。<br> 请你输出剩余同学的原始编号。</p><p><strong>输入</strong></p><p>第一行包含一个整数T，表示样例个数。<br> 对于每个样例，包含一个单独的整数n表示同学的编号。</p><p><strong>输出</strong></p><p>对于每个样例，在一行输出剩余同学的编号，使用空格分隔。</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造循环链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">createCircleList</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = head; <span class="comment">// 将最后一个节点指向头节点，形成循环</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个节点，并返回下一个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">deleteKthNode</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 找到要删除的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除该节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">        prev-&gt;next = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        head = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cur);</span><br><span class="line">    <span class="comment">// 返回下一个节点</span></span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环报数并删除节点，直到剩余人数少于7</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countAndDelete</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> an[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        head = <span class="built_in">deleteKthNode</span>(head, <span class="number">7</span>);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出剩余同学的原始编号</span></span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            an[i] = cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(an, an + <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            cout &lt;&lt; an[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ListNode* head = <span class="built_in">createCircleList</span>(n);</span><br><span class="line">        <span class="built_in">countAndDelete</span>(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4442-二叉树遍历1"><a href="#4442-二叉树遍历1" class="headerlink" title="4442: 二叉树遍历1"></a>4442: 二叉树遍历1</h3><p><strong>题目描述</strong></p><p>​编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。<br> 例如如下的先序遍历字符串：<br> ABC##DE#G##F###<br> 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p><p><strong>输入</strong></p><p>​</p><p>​输入包括1行字符串，长度不超过100。</p><p>​</p><p><strong>输出</strong></p><p>​</p><p>​可能有多组测试数据，对于每组数据，<br> 输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。<br> 每个输出结果占一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树的节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">char</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归建立二叉树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(string s, <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= s.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(s[i++]);</span><br><span class="line">    root-&gt;left = <span class="built_in">buildTree</span>(s, i);</span><br><span class="line">    root-&gt;right = <span class="built_in">buildTree</span>(s, i);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归中序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123; <span class="comment">// 循环读入多组测试数据</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        TreeNode* root = <span class="built_in">buildTree</span>(s, i); <span class="comment">// 建立二叉树</span></span><br><span class="line">        <span class="built_in">inorder</span>(root); <span class="comment">// 中序遍历二叉树并输出结果</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4440-复原二叉树"><a href="#4440-复原二叉树" class="headerlink" title="4440: 复原二叉树"></a>4440: 复原二叉树</h3><p><strong>题目描述</strong></p><p>小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。</p><p><strong>输入</strong></p><p>输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。</p><p><strong>输出</strong></p><p>对于每组输入，输出对应的二叉树的后续遍历结果。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DBACEGF ABCDEFG</span><br><span class="line">BCAD CBAD</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACBFGED</span><br><span class="line">CDAB</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">string pre, in, post;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> prel, <span class="type">int</span> inl, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">post += pre[prel];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> root = in.<span class="built_in">find</span>(pre[prel]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(prel + <span class="number">1</span>, inl, root - inl);</span><br><span class="line"><span class="built_in">dfs</span>(prel + root - inl + <span class="number">1</span>, root + <span class="number">1</span>, len - (root - inl) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">post += pre[prel];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">post = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> n = pre.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">cout &lt;&lt; post &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4441-合并果子（堆）"><a href="#4441-合并果子（堆）" class="headerlink" title="4441: 合并果子（堆）"></a>4441: 合并果子（堆）</h3><p><strong>题目描述</strong></p><p>​ 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。     每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。     因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。     例如有3种果子，数目依次为1，2，9。可以先将 1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为 12。所以多多总共耗费体力&#x3D;3+12&#x3D;15。可以证明15为最小的体力耗费值。   </p><p><strong>输入</strong></p><p>​ 输入文件fruit.in包括两行，第一行是一个整数n（1 &lt;&#x3D; n &lt;&#x3D; 30000），表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai（1 &lt;&#x3D; ai &lt;&#x3D; 20000）是第i种果子的数目。   </p><p><strong>输出</strong></p><p>​ 输出文件fruit.out包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于231。   </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 5 1 7 6 4 2 5 4 1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, ai;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>; <span class="comment">// 需要使用 long long 类型存储结果，避免溢出</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q; <span class="comment">// 小根堆</span></span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; ai;</span><br><span class="line">    q.<span class="built_in">push</span>(ai);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 只要堆中还有两个及以上的元素，就一直合并</span></span><br><span class="line">    <span class="type">int</span> a = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    ans += a + b;</span><br><span class="line">    q.<span class="built_in">push</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四，搜索算法"><a href="#四，搜索算法" class="headerlink" title="四，搜索算法"></a>四，搜索算法</h2><h3 id="1264-正方形"><a href="#1264-正方形" class="headerlink" title="1264: 正方形"></a>1264: 正方形</h3><p><strong>题目描述</strong></p><p>有n个木棒，需要用上所有木棒，围成一个正方形，如果可以围成正方形，则输出”yes”, 否则输出”no”。 </p><p><strong>输入</strong></p><p>第一行输入一个整数T表示样例个数。<br> 对于每个样例，第一行输入一个整数N表示木棍的个数，第二行输入N个数字表示木棒的长度。 </p><p><strong>输出</strong></p><p>对于每个样例，如果可以则输出”yes”, 否则输出”no”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> idx, <span class="type">int</span> sum, <span class="type">int</span>* visited, <span class="type">int</span> n, <span class="type">int</span> cnt, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(a, <span class="number">0</span>, target, visited, n, cnt + <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] || a[i] &gt; sum) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, i + <span class="number">1</span>, sum - a[i], visited, n, cnt, target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当已经找到三组数字之和等于目标和时，还需要判断最后一组是否符合要求</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">2</span> &amp;&amp; sum == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> visited[<span class="number">25</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(a, <span class="number">0</span>, sum / <span class="number">4</span>, visited, n, <span class="number">0</span>, sum / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">25</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(a, n)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1265-prime-circle"><a href="#1265-prime-circle" class="headerlink" title="1265: prime circle"></a>1265: prime circle</h3><p><strong>题目描述</strong></p><p>A ring is compose of n circles as shown in diagram. Put natural number 1, 2, …, n into each circle separately, and the sum of numbers in two  adjacent circles should be a prime.</p><p> Note: the number of first circle should always be 1.</p><p><strong>输入</strong></p><p>n (0 &lt; n &lt; 20).<br> (multi test case) </p><p><strong>输出</strong></p><p>The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and  anticlockwisely. The order of numbers must satisfy the above  requirements. Print solutions in lexicographical order.</p><p> You are to write a program that completes above process.</p><p> Print a blank line after each case.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目描述</span><br><span class="line">A ring is compose of n circles as shown in diagram. Put natural number <span class="number">1</span>, <span class="number">2</span>, ..., n into each circle separately, <span class="keyword">and</span> the sum of numbers in two adjacent circles should be a prime.</span><br><span class="line"></span><br><span class="line">Note: the number of first circle should always be <span class="number">1.</span></span><br><span class="line">输入</span><br><span class="line"><span class="built_in">n</span> (<span class="number">0</span> &lt; n &lt; <span class="number">20</span>).</span><br><span class="line">(multi test <span class="keyword">case</span>)</span><br><span class="line">输出</span><br><span class="line">The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from <span class="number">1</span> clockwisely <span class="keyword">and</span> anticlockwisely. The order of numbers must satisfy the above requirements. Print solutions in lexicographical order.</span><br><span class="line"></span><br><span class="line">You are to write a program that completes above process.</span><br><span class="line"></span><br><span class="line">Print a blank line after each <span class="keyword">case</span>.</span><br><span class="line">样例输入 复制</span><br><span class="line"></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">样例输出 复制</span><br><span class="line"></span><br><span class="line">Case <span class="number">1</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Case <span class="number">2</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">8</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1266-棋盘问题"><a href="#1266-棋盘问题" class="headerlink" title="1266: 棋盘问题"></a>1266: 棋盘问题</h3><p><strong>题目描述</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><p><strong>输入</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;输入含有多组测试数据。 </p><p><strong>输出</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b &lt; other.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">char</span> a[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> last_b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].b &gt;= last_b) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = p[i].b;</span><br><span class="line">            p[i].b = last_b;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, tmp);</span><br><span class="line">            p[i].b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((cin &gt;&gt; m &gt;&gt; n)&amp;&amp;(m != <span class="number">-1</span>) &amp;&amp; (n != <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>,q=<span class="number">0</span>; j &lt; m; j++,q++) &#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == <span class="string">&#x27;#&#x27;</span>)p[q].a = i, p[q].b = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(p, p + m);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1268-迷宫问题-题目描述"><a href="#1268-迷宫问题-题目描述" class="headerlink" title="1268: 迷宫问题   题目描述"></a>1268: 迷宫问题   <strong>题目描述</strong></h3><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;定义一个二维数组： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int maze[5][5] = &#123;</span><br><span class="line"></span><br><span class="line">0, 1, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 1, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>输入</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;一个5 ×  5的二维数组，表示一个迷宫。数据保证有唯一解。</p><p><strong>输出</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255,  0.5);”&gt;左上角到右下角的最短路径，格式如样例所示。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(0, 0)</span><br><span class="line">(1, 0)</span><br><span class="line">(2, 0)</span><br><span class="line">(2, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(2, 3)</span><br><span class="line">(2, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(4, 4)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> maze[MAXN][MAXN];</span><br><span class="line"><span class="type">bool</span> visited[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> pre[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125; &#125;; <span class="comment">// 上右下左</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in">sizeof</span>(visited));</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    Node start = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> x = cur.x, y = cur.y, step = cur.step;</span><br><span class="line">        <span class="keyword">if</span> (x == MAXN - <span class="number">1</span> &amp;&amp; y == MAXN - <span class="number">1</span>) &#123; <span class="comment">// 到达终点，结束搜索</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(0, 0)&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="type">int</span> pre_x = MAXN - <span class="number">1</span>, pre_y = MAXN - <span class="number">1</span>;</span><br><span class="line">            vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; path; <span class="comment">// 记录路径</span></span><br><span class="line">            <span class="keyword">while</span> (pre_x != <span class="number">0</span> || pre_y != <span class="number">0</span>) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(&#123; pre_x, pre_y &#125;);</span><br><span class="line">                <span class="type">int</span> tmp_x = pre_x, tmp_y = pre_y;</span><br><span class="line">                pre_x = pre[pre_x][pre_y][<span class="number">0</span>];</span><br><span class="line">                pre_y = pre[tmp_x][tmp_y][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; path[i].first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path[i].second &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> next_x = x + dir[i][<span class="number">0</span>], next_y = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= MAXN || next_y &lt; <span class="number">0</span> || next_y &gt;= MAXN) <span class="keyword">continue</span>; <span class="comment">// 越界</span></span><br><span class="line">            <span class="keyword">if</span> (maze[next_x][next_y] == <span class="number">1</span> || visited[next_x][next_y]) <span class="keyword">continue</span>; <span class="comment">// 墙或者已访问过</span></span><br><span class="line">            Node next_node = &#123; next_x, next_y, step + <span class="number">1</span> &#125;;</span><br><span class="line">            pre[next_x][next_y][<span class="number">0</span>] = x; <span class="comment">// 记录路径</span></span><br><span class="line">            pre[next_x][next_y][<span class="number">1</span>] = y;</span><br><span class="line">            q.<span class="built_in">push</span>(next_node);</span><br><span class="line">            visited[next_x][next_y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MAXN; j++) &#123;</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1270-Find-a-way"><a href="#1270-Find-a-way" class="headerlink" title="1270: Find a way"></a>1270: Find a way</h3><p><strong>题目描述</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;Pass a  year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally.  Leave Ningbo one year, yifenfei have many people to meet. Especially a  good friend Merceki. </p><p><strong>输入</strong></p><p>&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;&lt;span  style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;The input contains multiple test cases. </p><p><strong>输出</strong></p><p>​&lt;span style&#x3D;”font-family:Merriweather, Full-Width-Quoration-Marks,  -apple-system, bl<x>inkMacSystemFont,  “font-size:15px;background-color:rgba(210, 210, 255, 0.5);”&gt;For each  test case output the minimum total time that both yifenfei and Merceki  to arrival one of KFC.You may sure there is always have a KFC that can  let them meet. </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">Y.#@</span><br><span class="line">....</span><br><span class="line">.#..</span><br><span class="line">@..M</span><br><span class="line">4 4</span><br><span class="line">Y.#@</span><br><span class="line">....</span><br><span class="line">.#..</span><br><span class="line">@#.M</span><br><span class="line">5 5</span><br><span class="line">Y..@.</span><br><span class="line">.#...</span><br><span class="line">.#...</span><br><span class="line">@..M.</span><br><span class="line">#...#</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">66</span><br><span class="line">88</span><br><span class="line">66</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">int</span> tx, <span class="type">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx, sy, <span class="number">0</span>&#125;);</span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    dist[sx][sy] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b] || g[a][b] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            dist[a][b] = t.t + <span class="number">1</span>;</span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b, dist[a][b]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[tx][ty];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sy, sx, ty, tx, res = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;Y&#x27;</span>) sx = i, sy = j;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;M&#x27;</span>) tx = i, ty = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> d1 = <span class="built_in">bfs</span>(sx, sy, i, j);</span><br><span class="line">                    <span class="type">int</span> d2 = <span class="built_in">bfs</span>(tx, ty, i, j);</span><br><span class="line">                    res = <span class="built_in">min</span>(res, d1 + d2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res * <span class="number">11</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1282-马的遍历"><a href="#1282-马的遍历" class="headerlink" title="1282: 马的遍历"></a>1282: 马的遍历</h3><p><strong>题目描述</strong></p><p>有一个n*m的棋盘(1&lt;n,m&lt;&#x3D;400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步</p><p><strong>输入</strong></p><p>一行四个数据，棋盘的大小和马的坐标</p><p><strong>输出</strong></p><p>​一个n*m的矩阵，同一行元素之间用空格分离。代表马到达某个点最少要走几步。不能到达则输出-1。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3 1 1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 3 2</span><br><span class="line">3 -1 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">405</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m, sx, sy;</span><br><span class="line"><span class="type">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx, sy&#125;);</span><br><span class="line">    dis[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>().x, y = q.<span class="built_in">front</span>().y;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(nx, ny) &amp;&amp; dis[nx][ny] == INF) &#123;</span><br><span class="line">                dis[nx][ny] = dis[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dis[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i][j] == INF) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; dis[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1283-求细胞数量"><a href="#1283-求细胞数量" class="headerlink" title="1283: 求细胞数量"></a>1283: 求细胞数量</h3><p><strong>题目描述</strong></p><p>一矩形阵列由数字 0 到 9 组成，数字 1 到 9 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。</p><p><strong>输入</strong></p><p>第一行两个整数代表矩阵大小 n 和 m。 接下来 n 行，每行一个长度为 m 的只含字符 0 到 9 的字符串，代表这个n×m 的矩阵。 </p><p><strong>输出</strong></p><p>​一行一个整数代表细胞个数。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 10</span><br><span class="line">0234500067</span><br><span class="line">1034560500</span><br><span class="line">2045600671</span><br><span class="line">0000000089</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>; <span class="comment">// 最大矩阵大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;; <span class="comment">// 上下左右四个方向的坐标变化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> matrix[MAXN][MAXN]; <span class="comment">// 输入的矩阵</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN][MAXN]; <span class="comment">// 标记每个点是否访问过</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 细胞数量计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个点是否在矩阵内</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inMatrix</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n&amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS遍历整个细胞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; sx, sy &#125;);</span><br><span class="line">    vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> x = p.first, y = p.second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 四个方向搜索</span></span><br><span class="line">            <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inMatrix</span>(nx, ny) &amp;&amp; !vis[nx][ny] &amp;&amp; matrix[nx][ny] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; nx, ny &#125;);</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; matrix[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; !vis[i][j]) &#123; <span class="comment">// 如果是细胞且未访问过</span></span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j); <span class="comment">// BFS搜索整个细胞</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1284-01迷宫"><a href="#1284-01迷宫" class="headerlink" title="1284: 01迷宫"></a>1284: 01迷宫</h3><p><strong>题目描述</strong></p><p>有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 </p><p><strong>输入</strong></p><p>第1行为两个正整数n,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。<br> 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 </p><p><strong>输出</strong></p><p>​m行，对于每个询问输出相应答案。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>n &lt;&#x3D; 400</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> maze[MAXN][MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;  <span class="comment">// 上右下左</span></span><br><span class="line"><span class="type">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; sx, sy &#125;);</span><br><span class="line">    vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> x = p.first, y = p.second;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (maze[x][y] != maze[nx][ny]) &#123;</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; nx, ny &#125;);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        x--; y--;  <span class="comment">// 转换成从0开始编号的坐标</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">bfs</span>(x, y) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));  <span class="comment">// 注意清空标记数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五，图论"><a href="#五，图论" class="headerlink" title="五，图论"></a>五，图论</h2><h3 id="4444-dfs"><a href="#4444-dfs" class="headerlink" title="4444: dfs"></a>4444: dfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];  <span class="comment">// 存储图</span></span><br><span class="line"><span class="type">bool</span> vis[N];       <span class="comment">// 标记是否已经访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 输出当前节点编号</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;     <span class="comment">// 标记已经访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;  <span class="comment">// 如果节点v还没有被访问</span></span><br><span class="line">            <span class="built_in">dfs</span>(v);      <span class="comment">// 继续访问节点v</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);  <span class="comment">// 添加无向边</span></span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);  <span class="comment">// 从节点1开始遍历</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4445-bfs"><a href="#4445-bfs" class="headerlink" title="4445: bfs"></a>4445: bfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);  <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1298-蜜罐"><a href="#1298-蜜罐" class="headerlink" title="1298: 蜜罐"></a>1298: 蜜罐</h3><p><strong>题目描述</strong></p><p>​蜜蜂乔治在采蜂蜜的时候，会把蜜放进N个蜜罐中，现在需要把这N个不相邻的蜜罐构建一些双向边把它们连接起来。即有N个分立的点，同时给出M个不同的边，需要你求出这张图的最小生成树。或许你会觉得这种描述有些奇怪，不过使用如此描述完全由于出题人喜欢吃蜂蜜。 </p><p><strong>输入</strong></p><p>​第一行输入一个T，表示样例个数。<br>     对于每一个样例，第二行输入N, M，表示蜜罐数与边的数量。<br>     第三行输入三个数字 s, t, w表示双向边的两个端点和权重。 </p><p><strong>输出</strong></p><p>​对于每个样例，输出一个数字res表示生成树的权重。如果无法构成生成树，则输出-1. </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3  3</span><br><span class="line">1 2 3</span><br><span class="line">2 3 3</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>​1 &lt; N, M &lt; 2000<br>     w &lt; 10000</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, t, w;</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> v = G[u][i].first, w = G[u][i].second;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; w) &#123;</span><br><span class="line">                dis[v] = w;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v], v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans += dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;</span><br><span class="line">            G[s].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(t, w));</span><br><span class="line">            G[t].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(s, w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">prim</span>();</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1310-村村通"><a href="#1310-村村通" class="headerlink" title="1310: 村村通"></a>1310: 村村通</h3><p><strong>题目描述</strong></p><p>某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 “村村通工程” 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？</p><p><strong>输入</strong></p><p>​ 输入包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目n 和道路数目 m ；随后的 m 行对应 m 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 1 到 n 编号。<br>      注意：两个城市间可以有多条道路相通。 </p><p><strong>输出</strong></p><p>​ 对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent; <span class="comment">// 存储节点的父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123; <span class="comment">// 初始化</span></span><br><span class="line">        parent.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 查找节点所在集合的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// 合并两个集合</span></span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="comment">// 统计集合的数量</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; parent.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>; <span class="comment">// 初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            uf.<span class="built_in">merge</span>(u, v); <span class="comment">// 合并u和v所在的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; uf.<span class="built_in">count</span>() - <span class="number">1</span> &lt;&lt; endl; <span class="comment">// 输出最少需要的道路数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1297-一个人的旅行"><a href="#1297-一个人的旅行" class="headerlink" title="1297: 一个人的旅行"></a>1297: 一个人的旅行</h3><p><strong>题目描述</strong></p><p>​ 虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗<del>),但是草儿仍然很喜欢旅行，因为在旅途中  会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊</del>）。 </p><p><strong>输入</strong></p><p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br> 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1&#x3D;&lt;(a,b)&lt;&#x3D;1000;a,b 之间可能有多条路)<br> 接着的第T+1行有S个数，表示和草儿家相连的城市；<br> 接着的第T+2行有D个数，表示草儿想去地方。</p><p><strong>输出</strong></p><p>​输出草儿能去某个喜欢的城市的最短时间 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 2 3</span><br><span class="line">1 3 5</span><br><span class="line">1 4 7</span><br><span class="line">2 8 12</span><br><span class="line">3 8 4</span><br><span class="line">4 9 12</span><br><span class="line">9 10 2</span><br><span class="line">1 2</span><br><span class="line">8 9 10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w, nxt;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dist[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> s[MAXN], d[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, t, S, D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, INF, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;S, &amp;D) == <span class="number">3</span>) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            <span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">            <span class="built_in">addEdge</span>(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= D; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) &#123;</span><br><span class="line">            <span class="built_in">SPFA</span>(s[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= D; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[d[j]] &lt; ans) &#123;</span><br><span class="line">                    ans = dist[d[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1312-文化之旅"><a href="#1312-文化之旅" class="headerlink" title="1312: 文化之旅"></a>1312: 文化之旅</h3><p><strong>题目描述</strong></p><p>有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。<br> 现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。 </p><p><strong>输入</strong></p><p>每组输入数据的第一行为五个整数N，K，M，S，T，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为1到N），文化种数（文化编号为1到K），道路的条数，以及起点和终点的编号（保证S不等于T）；<br> 第二行为N个整数，每两个整数之间用一个空格隔开，其中第i个数Ci，表示国家i的文化为Ci。<br> 接下来的K行，每行K个整数，每两个整数之间用一个空格隔开，记第i行的第j个数为aij，aij&#x3D;1表示文化i排斥外来文化j（i等于j时表示排斥相同文化的外来人），aij&#x3D;0表示不排斥（注意i排斥j并不保证j 一定也排斥i）。<br> 接下来的M行，每行三个整数u，v，d，每两个整数之间用一个空格隔开，表示国家u与国家v有一条距离为d的可双向通行的道路（保证u不等于v，两个国家之间可能有多条道路）。 </p><p> 数据规模：<br> 对于20%的数据，有2≤N≤8，K≤5；<br> 对于30%的数据，有2≤N≤10，K≤5；<br> 对于50%的数据，有2≤N≤20，K≤8；<br> 对于100%的数据，有2≤N≤100，1≤K≤10，1≤M≤N2，1≤ki≤K，1≤u, v≤N，1≤d≤1000，S≠T，1≤S, T≤N。 </p><p><strong>输出</strong></p><p>每组输出只有一行，一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出-1）。 </p><p> 下面是对样例数据的解释：<br> 样例一：<br> 由于到国家2必须要经过国家1，而国家2的文明却排斥国家1的文明，所以不可能到达国家2。<br> 样例二：<br> 路线为1-&gt;2。 </p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 2 1 1 2</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">1 2 10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>-———–<br> 2 2 1 1 2<br> 1 2<br> 0 1<br> 0 0<br> 1 2 10<br> -———-<br> 10 </p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, K = <span class="number">105</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, k, m, s, t;</span><br><span class="line"><span class="type">int</span> c[N], dist[N];      <span class="comment">//某个国家的文化，到某个国家的距离 </span></span><br><span class="line"><span class="type">int</span> a[K][K], e[N][N];   <span class="comment">//两国之间是否排斥，两国之间的距离 </span></span><br><span class="line"><span class="type">bool</span> h[K];              <span class="comment">//已经学过的文化 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//到国家x的距离是d </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= dist[x] || d &gt;= dist[t]) <span class="keyword">return</span>;</span><br><span class="line">    dist[x] = d;</span><br><span class="line">    <span class="keyword">if</span> (x == t) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;             <span class="comment">//i国 </span></span><br><span class="line">        <span class="keyword">if</span> (e[x][i] == INF) <span class="keyword">continue</span>;           <span class="comment">//x,i两国之间没有路</span></span><br><span class="line">        <span class="keyword">if</span> (h[c[i]]) <span class="keyword">continue</span>;                  <span class="comment">//已学过该国文化 </span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j ++) &#123;         <span class="comment">//j文化 </span></span><br><span class="line">            <span class="keyword">if</span> (h[j] &amp;&amp; a[c[i]][j] == <span class="number">1</span>) &#123;      <span class="comment">//学过j文化且i国的文化排斥j文化 </span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        h[c[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, d + e[x][i]);</span><br><span class="line">        h[c[i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;n, &amp;k, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;             </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);                     <span class="comment">//国家 i的文化为 Ci</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);              <span class="comment">//a[i][j] = 1 表示文化 i 排斥外来文化 j</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));           <span class="comment">//初始化 </span></span><br><span class="line">    <span class="built_in">memset</span>(e, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(e));                 </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;d);</span><br><span class="line">        e[u][v] = e[v][u] = <span class="built_in">min</span>(e[u][v], d);    <span class="comment">//邻接矩阵，去掉重复的边 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h[c[s]] = <span class="literal">true</span>;                             <span class="comment">//学习起点国家的文化  </span></span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[t] == <span class="number">0x3f3f3f3f</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[t]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1320-公交线路"><a href="#1320-公交线路" class="headerlink" title="1320: 公交线路"></a>1320: 公交线路</h3><p><strong>题目描述</strong></p><p>​P市有n个公交站，之间连接着m条道路。P市计划新开设一条公交线路，该线路从城市的东站（s点）修建到西站（t点），请为P市设计一条满足上述条件并且最短的公交线路图。  </p><p><strong>输入</strong></p><p>第一行有5个正整数n，m，s，t。</p><p> 接下来m行，每行3个数a,b,v描述一条无向道路a——b，长度为v。</p><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果有解，输出一行，表示满足条件的最短公交线路的长度c。</span><br><span class="line"></span><br><span class="line">否则，输出“-1”</span><br></pre></td></tr></table></figure><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 1 2</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>1 ≤ s,t ≤ n ≤ 1000<br> 1 ≤ m ≤ 10000<br> 1 ≤ 道路的长度 ≤ 10000</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, t; <span class="comment">// n: 点的数量，m: 边的数量，s: 起点，t: 终点</span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">105</span>]; <span class="comment">// dis[i] 表示从起点 s 到 i 的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">105</span>]; <span class="comment">// vis[i] 表示 i 是否已经访问过</span></span><br><span class="line"><span class="type">int</span> G[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">// G[i][j] 表示 i 到 j 的边的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="built_in">sizeof</span>(dis)); <span class="comment">// 初始化 dis 数组为 INF</span></span><br><span class="line">    dis[s] = <span class="number">0</span>; <span class="comment">// 起点 s 到自己的距离为 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">-1</span>, min_dis = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; min_dis) &#123;</span><br><span class="line">                    u = j;</span><br><span class="line">                    min_dis = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有点都已经访问过</span></span><br><span class="line">            vis[u] = <span class="literal">true</span>; <span class="comment">// 标记 u 已经访问过</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF &amp;&amp; dis[u] + G[u][v] &lt; dis[v]) &#123;</span><br><span class="line">                    dis[v] = dis[u] + G[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="built_in">memset</span>(G, INF, <span class="built_in">sizeof</span>(G)); <span class="comment">// 初始化 G 数组为 INF</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i][i] = <span class="number">0</span>; <span class="comment">// 自己到自己的距离为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u][v] = G[v][u] = w; <span class="comment">// 无向图，所以需要同时更新 G[u][v] 和 G[v][u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>(); <span class="comment">// 求解最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dis[t] != INF) cout &lt;&lt; dis[t] &lt;&lt; endl; <span class="comment">// 如果有解，输出最短距离</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 否则输出 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4443-弗洛伊德"><a href="#4443-弗洛伊德" class="headerlink" title="4443: 弗洛伊德"></a>4443: 弗洛伊德</h3><p><strong>题目描述</strong></p><p>​在带权有向图G中，求G中的任意一对顶点间的最短路径问题，也是十分常见的一种问题。 解决这个问题的一个方法是执行n次迪杰斯特拉算法，这样就可以求出每一对顶点间的最短路径，执行的时间复杂度为O(n3)。 而另一种算法是由弗洛伊德提出的，时间复杂度同样是O(n3)，但算法的形式简单很多。 </p><p>​在本题中，读入一个有向图的带权邻接矩阵（即数组表示），建立有向图并按照以上描述中的算法求出每一对顶点间的最短路径长度。</p><p>​ </p><p><strong>输入</strong></p><p>输入的第一行包含1个正整数n，表示图中共有n个顶点。其中n不超过50。 以后的n行中每行有n个用空格隔开的整数。对于第i行的第j个整数，如果大于0，则表示第i个顶点有指向第j个顶点的有向边，且权值为对应的整数值；如果这个整数为0，则表示没有i指向j的有向边。当i和j相等的时候，保证对应的整数为0。</p><p><strong>输出</strong></p><p>共有n行，每行有n个整数，表示源点至每一个顶点的最短路径长度。如果不存在从源点至相应顶点的路径，输出-1。对于某个顶点到其本身的最短路径长度，输出0。 请在每个整数后输出一个空格，并请注意行尾输出换行。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 3 0 1</span><br><span class="line">0 0 4 0</span><br><span class="line">2 0 0 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 3 2 1 </span><br><span class="line">6 0 4 7 </span><br><span class="line">2 5 0 3 </span><br><span class="line">3 6 1 0 </span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>在本题中，需要按照题目描述中的算法完成弗洛伊德算法，并在计算最短路径的过程中将每个顶点是否可达记录下来，直到求出每一对顶点的最短路径之后，算法才能够结束。 相对于迪杰斯特拉算法，弗洛伊德算法的形式更为简单。通过一个三重循环，弗洛伊德算法可以方便的求出每一对顶点间的最短距离。 另外需要注意的是，为了更方便的表示顶点间的不可达状态，可以使用一个十分大的值作为标记。而在题目描述中的算法示例使用了另外一个三维数组对其进行表示，这使原本的O(n3)时间复杂度增长到了O(n4)，这也是需要自行修改的部分。</p><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> graph[MAXN][MAXN]; <span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph[i][k] != INF &amp;&amp; graph[k][j] != INF) &#123;</span><br><span class="line">graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="built_in">memset</span>(graph, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(graph));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="type">int</span> w;</span><br><span class="line">cin &gt;&gt; w;</span><br><span class="line"><span class="keyword">if</span> (w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">graph[i][j] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">graph[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行弗洛伊德算法</span></span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph[i][j] == INF) &#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; graph[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4446-奖学金-reward"><a href="#4446-奖学金-reward" class="headerlink" title="4446: 奖学金(reward)"></a>4446: 奖学金(reward)</h3><p><strong>题目描述</strong></p><p>期末考试终于完了，老班决定召开班委会，内容嘛，则是可爱的奖学金的问题（(<em>^__^</em>)），她叫来了一些班委，每位班委提出了自己的意见：“我认为同学a的奖学金应该比b多！”老班决定要找出一种奖学金方案，满足各位班委的意见，且同时使得总奖学金数最少。每位同学奖学金最少为100元且都为整数。</p><p><strong>输入</strong></p><p>​第一行两个整数n,m，表示同学总数和班委意见数；</p><p>以下m行，每行2个整数a,b，表示某个班委认为第a号同学奖学金应该比第b号同学高。</p><p><strong>输出</strong></p><p>若无法找到合法方案，则输出“impossible”(不含引号）；否则输出一个数表示最少总奖学金。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">201</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;<span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(),ch&lt;<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(x=<span class="number">10</span>*x+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>(),ch&gt;<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cat_max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">return</span> a&gt;b ? a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cat_min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">return</span> a&lt;b ? a:b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> mon; </span><br><span class="line">    <span class="built_in">node</span> ():<span class="built_in">num</span>(<span class="number">0</span>),<span class="built_in">mon</span>(<span class="number">100</span>)&#123;&#125;;  </span><br><span class="line">&#125;G[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next;</span><br><span class="line">&#125;g[<span class="number">20000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> head[maxn],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">g[++tot].to = v;</span><br><span class="line">g[tot].next = head[u];</span><br><span class="line">head[u] = tot; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> q[maxn],l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;reward.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;reward.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="type">int</span> n,m;<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;<span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a),<span class="built_in">read</span>(b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        G[a].num++;<span class="comment">//纪录每一个点的入度 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i].num == <span class="number">0</span>)&#123;</span><br><span class="line">            q[r] = i;</span><br><span class="line"> ++r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        tmp = q[l];++l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[tmp]; i ; i = g[i].next)&#123;</span><br><span class="line">            G[g[i].to].num--;</span><br><span class="line">            <span class="keyword">if</span>(G[g[i].to].mon &lt;= G[tmp].mon)</span><br><span class="line">               G[g[i].to].mon = G[tmp].mon + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(G[g[i].to].num == <span class="number">0</span>)&#123;<span class="comment">//入度为零则不可能再一次被更新了 </span></span><br><span class="line">                q[r] = g[i].to ; ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i].num != <span class="number">0</span>)&#123;</span><br><span class="line">           flag = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">break</span>;<span class="comment">//判环 </span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt += G[i].mon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt);</span><br><span class="line">    <span class="built_in">fclose</span>(stdin);<span class="built_in">fclose</span>(stdout);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="六，动态规划"><a href="#六，动态规划" class="headerlink" title="六，动态规划"></a>六，动态规划</h2><h3 id="4447-冬冬爬楼梯"><a href="#4447-冬冬爬楼梯" class="headerlink" title="4447: 冬冬爬楼梯"></a>4447: 冬冬爬楼梯</h3><p><strong>题目描述</strong></p><p>冬冬爬楼梯，一步可以1级，也可以爬2级、3级。冬冬很可爱，每到一处楼梯处，他都想知道直完这个楼梯有多少种走法。但由于有的时候楼梯级数太多，可能是个天文数字，很显然，对于还处于小学5年级的冬冬是不太现实的。聪明的你，能帮冬冬实现这个愿望吗？</p><p><strong>输入</strong></p><p>多组测试数据，每组测试数据一行一个整数n (1&lt;&#x3D;n&lt;&#x3D;3000)</p><p><strong>输出</strong></p><p>对于每组测试数据，输出一个整数，为n级楼梯冬冬走完的方法数。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3005</span>;</span><br><span class="line">string dp[MAXN];</span><br><span class="line"><span class="function">string <span class="title">reverseStr</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[n - i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">size</span>(), len2 = b.<span class="built_in">size</span>();</span><br><span class="line">    a = <span class="built_in">reverseStr</span>(a); b = <span class="built_in">reverseStr</span>(b);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 || j &lt; len2) &#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1) &#123;</span><br><span class="line">            sum += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; len2) &#123;</span><br><span class="line">            sum += b[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        sum %= <span class="number">10</span>;</span><br><span class="line">        res += (sum + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; carry &lt;&lt; &quot; &quot; &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        res += (carry + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverseStr</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; add(&quot;13&quot;, &quot;11&quot;) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : dp) i = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="string">&quot;4&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">add</span>(dp[i - <span class="number">1</span>], <span class="built_in">add</span>(dp[i - <span class="number">2</span>], dp[i - <span class="number">3</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; dp[n - 1] &lt;&lt; &quot; &quot; &lt;&lt; dp[n - 2] &lt;&lt; &quot; &quot; &lt;&lt; dp[n - 3] &lt;&lt; endl;</span></span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4450-最大子段和"><a href="#4450-最大子段和" class="headerlink" title="4450: 最大子段和"></a>4450: 最大子段和</h3><p><strong>题目描述</strong></p><p>​输入若干个整数，有正有负，要求用动态规划算法计算最大子段和，并输出这个和。注意子段为一段连续的数，同时规定全是负数的子段其和为0。</p><p><strong>输入</strong></p><p>​第一行为一个整数M，代表有M组测试数据。<br> 随后每组测试数据的第一行为N，代表该组数据有N个数。(0&lt;n&lt;&#x3D;100000) &lt;br&#x3D;””&gt;接下来一行给出用空格隔开的这N个整数。&lt;&#x2F;n&lt;&#x3D;100000)&gt;</p><p><strong>输出</strong></p><p>每组测试数据输出一行，即最大子段和。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">-2 10 8 -4 7 5 -29 10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">b += a[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = a[i];</span><br><span class="line"><span class="keyword">if</span> (b &gt; sum)</span><br><span class="line">sum = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> M; cin &gt;&gt; M;</span><br><span class="line"><span class="keyword">while</span> (M--) &#123;</span><br><span class="line"><span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">maxSum</span>(a, N) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4454-最大子阵和"><a href="#4454-最大子阵和" class="headerlink" title="4454: 最大子阵和"></a>4454: 最大子阵和</h3><p><strong>题目描述</strong></p><p>有一个包含正数和负数的二维数组。一个子矩阵是指在该二维数组里，任意相邻的下标是1*1或更大的子数组。一个子矩阵的和是指该子矩阵中所有元素的和。本题中，把具有最大和的子矩阵称为最大子矩阵。<br> 例如：<br> 0 -2 -7 0<br> 9 2 -6 2<br> -4 1 -4 1<br> -1 8 0 -2<br> 这个数组的最大子矩阵为：<br> 9 2<br> -4 1<br> -1 8<br> 其和为15。</p><p><strong>输入</strong></p><p>输入包含多组测试数据。每组输入的第一行是一个正整数N（1&lt;&#x3D;N&lt;&#x3D;100），表示二维方阵的大小。接下来N行每行输入N个整数，表示数组元素，范围为[-127，127]。</p><p><strong>输出</strong></p><p>输出最大子阵和。</p><p><strong>样例输入</strong>                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line">9 2 -6 2</span><br><span class="line">-4 1 -4 1</span><br><span class="line">-1 8 0 -2</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>                  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], sum[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kadane</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_sum = arr[<span class="number">0</span>], cur_sum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur_sum = <span class="built_in">max</span>(cur_sum + arr[i], arr[i]);</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, cur_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) sum[i][j] = a[i][j];</span><br><span class="line">                <span class="keyword">else</span> sum[i][j] = sum[i - <span class="number">1</span>][j] + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) arr[k] = sum[j][k];</span><br><span class="line">                    <span class="keyword">else</span> arr[k] = sum[j][k] - sum[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">kadane</span>(n, arr));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] arr;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4449-最长上升子序列"><a href="#4449-最长上升子序列" class="headerlink" title="4449: 最长上升子序列"></a>4449: 最长上升子序列</h3><p><strong>题目描述</strong></p><p>给出一个由n个数组成的序列A[1..n]，求最长单调上升子序列（LIS)的长度。LIS即求最大的一个子序列长度m，使得a1&lt;a2&lt;……&lt;am且A[a1]&lt;A[a2]&lt;……&lt;A[am]。</p><p><strong>输入</strong></p><p>​两行：</p><p>​第1行：整数n (1&lt;&#x3D;n&lt;&#x3D;1000)</p><p>​第2行：n个整数 （int范围内），空格隔开。</p><p><strong>输出</strong></p><p>一行：一个整数，即最长上升子序列长度。</p><p><strong>样例输入</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6311213628205737824</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>               </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN], dp[MAXN];  <span class="comment">// dp[i]表示以a[i]为结尾的最长上升子序列长度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;  <span class="comment">// LIS长度至少为1</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;    <span class="comment">// 第一个元素自成长度为1的LIS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;  <span class="comment">// 初始化dp[i]为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;  <span class="comment">// 如果a[j]&lt;a[i]，则a[i]可以接在以a[j]结尾的LIS之后形成更长的LIS</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);  <span class="comment">// 更新最长上升子序列的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4453-最小乘车费用"><a href="#4453-最小乘车费用" class="headerlink" title="4453: 最小乘车费用"></a>4453: 最小乘车费用</h3><p><strong>题目描述</strong></p><p>​某条街上每一公里就有一汽车站，乘车费用如下表： </p><table><thead><tr><th>公里数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>费用</td><td>12</td><td>21</td><td>31</td><td>40</td><td>49</td><td>58</td><td>69</td><td>79</td><td>90</td><td>101</td></tr></tbody></table><p>​而一辆汽车从不行驶超过10公里。某人想行驶n公里，假设他可以任意次换车，请你帮他找到一种乘车方案使费用最小（10公里的费用比1公里小的情况是允许的）。 </p><p><strong>输入</strong></p><p>​第一行为10个不超过100的整数，依次表示行驶1～10公里的费用，相邻两数间用空格隔开； </p><p>​第二行为某人想要行驶的公里数(1000以内)。 </p><p><strong>输出</strong></p><p>包含一个整数，表示该测试点的最小费用。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 21 31 40 49 58 69 79 90 101 </span><br><span class="line">15</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">147</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> f[<span class="number">25</span>],dp[<span class="number">205</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line">        cin&gt;&gt;f[i];</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=f[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+f[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">10</span> &amp;&amp; j&lt;=i; j++)</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i],dp[i-j]+f[j]);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dp[i]&lt;&lt;&quot;  &quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4448-方格取数"><a href="#4448-方格取数" class="headerlink" title="4448: 方格取数"></a>4448: 方格取数</h3><p><strong>题目描述</strong></p><p>​在n*n的方格阵中，从左上角出发，每次只能往正下方或右边走，找出一种路线方案，使得所经历方格中数字和最大，输出这个值。 </p><p>​（下图n&#x3D;5) </p><p>​  </p><table><thead><tr><th>0</th><th>5</th><th>37</th><th>53</th><th>9</th></tr></thead><tbody><tr><td>55</td><td>10</td><td>19</td><td>23</td><td>8</td></tr><tr><td>65</td><td>58</td><td>82</td><td>89</td><td>9</td></tr><tr><td>8</td><td>0</td><td>14</td><td>50</td><td>68</td></tr><tr><td>89</td><td>5</td><td>10</td><td>41</td><td>0</td></tr></tbody></table><p><strong>输入</strong></p><p>​第1行：一个整数n  (1&lt;&#x3D;n&lt;&#x3D;1000)</p><p>​第2-n+1行：每行n个非负整数 （整型范围）</p><p><strong>输出</strong></p><p>一行：一个整数</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">0537539</span><br><span class="line">551019238</span><br><span class="line">655882899</span><br><span class="line">80145068</span><br><span class="line">89510410</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">467</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4451-01背包"><a href="#4451-01背包" class="headerlink" title="4451: 01背包"></a>4451: 01背包</h3><p><strong>题目描述</strong></p><p>一个旅行者有一个最多能用M公斤的背包，现在有N件物品，<br> 它们的重量分别是W1，W2，…,Wn,<br> 它们的价值分别为P1,P2,…,Pn.<br> 若每种物品只有一件求旅行者能获得最大总价值。</p><p><strong>输入</strong></p><p>M,N<br> W1,P1<br> W2,P2<br> ……</p><p><strong>输出</strong></p><p>最大总价值。</p><p><strong>样例输入</strong>           复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 4</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">4 5</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; j) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]] + p[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4452-完全背包"><a href="#4452-完全背包" class="headerlink" title="4452: 完全背包"></a>4452: 完全背包</h3><p><strong>题目描述</strong></p><p>完全背包定义有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是c，价值是w。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。本题要求是背包恰好装满背包时，求出最大价值总和是多少。如果不能恰好装满背包，输出NO</p><p><strong>输入</strong></p><p>第一行： N 表示有多少组测试数据（N&lt;7）。 </p><p> 接下来每组测试数据的第一行有两个整数M，V。 M表示物品种类的数目，V表示背包的总容量。(0&lt;M&lt;&#x3D;2000，0&lt;V&lt;&#x3D;50000)<br> 接下来的M行每行有两个整数c，w分别表示每种物品的重量和价值(0&lt;c&lt;100000，0&lt;w&lt;100000)</p><p><strong>输出</strong></p><p>对应每组测试数据输出结果（如果能恰好装满背包，输出装满背包时背包内物品的最大价值总和。 如果不能恰好装满背包，输出NO）</p><p><strong>样例输入</strong>         </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 5</span><br><span class="line">2 2</span><br><span class="line">2 5</span><br><span class="line">2 2</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>           </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">999999</span>; <span class="comment">// 物品数量的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MAXV = <span class="number">999999</span>; <span class="comment">// 背包容量的最大值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> w[MAXN], v[MAXN]; <span class="comment">// w[i]表示第i件物品的体积，v[i]表示第i件物品的价值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXV]; <span class="comment">// f[j]表示背包容量为j时的最大价值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(f)); <span class="comment">// 初值为负无穷大</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 容量为0时，最大价值为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        &#123; <span class="comment">// 枚举物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = w[i]; j &lt;= m; j++) </span><br><span class="line">            &#123; <span class="comment">// 枚举容量</span></span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + v[i]); <span class="comment">// 转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f[m] &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七，字符串和数学实验"><a href="#七，字符串和数学实验" class="headerlink" title="七，字符串和数学实验"></a>七，字符串和数学实验</h2><h3 id="问题-A-字符串"><a href="#问题-A-字符串" class="headerlink" title="问题 A: 字符串"></a>问题 A: 字符串</h3><p><strong>题目描述</strong></p><p>给定连个字符串a和 b,求出b在a中第一次出现的位置。如果b没有在a中出现过,则输出-1。</p><p><strong>输入</strong></p><p>第一行包含一个数字T表示样例个数,对于每组样例,包含两个用空格分隔的字符串a,只包含小写字母。</p><p><strong>输出</strong></p><p>对于每组样例,输出b在a中第一次出现的位置。</p><p><strong>样例输入</strong>           复制          ****</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">abc b</span><br><span class="line">aaaab ab</span><br><span class="line">ab d</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          复制          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><p>简单查找，（基础查找）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;cin &gt;&gt; T;  <span class="comment">// 输入样例个数</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        string a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;  <span class="comment">// 输入两个字符串</span></span><br><span class="line">        <span class="comment">// 在a中查找b</span></span><br><span class="line">        <span class="type">int</span> pos = a.<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (pos != string::npos) &#123;</span><br><span class="line">            cout &lt;&lt; pos &lt;&lt; endl;  <span class="comment">// 输出第一次出现的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;  <span class="comment">// 如果b没有在a中出现过，则输出-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法：（next数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算字符串s的前缀函数（即next数组）</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_prefix</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用KMP算法在a中查找b的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">compute_prefix</span>(b);</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] != b[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;  <span class="comment">// 输入样例个数</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        string a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;  <span class="comment">// 输入两个字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">kmp</span>(a, b);  <span class="comment">// 在a中查找b</span></span><br><span class="line">        cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="问题-B-Oulipo"><a href="#问题-B-Oulipo" class="headerlink" title="问题 B: Oulipo"></a>问题 B: Oulipo</h3><p><strong>题目描述</strong></p><p>The French author Georges Perec (1936–1982) once wrote a book, La  disparition, without the letter ‘e’. He was a member of the Oulipo  group. A quote from the book:</p><p> Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal,  d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir  où s’articulait l’association qui l’unissait au roman : stir son tapis,  assaillant à tout instant son imagination, l’intuition d’un tabou, la  vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision,  l’avision d’un oubli commandant tout, où s’abolissait la raison : tout  avait l’air normal mais…</p><p> Perec would probably have scored high (or rather, low) in the following  contest. People are asked to write a perhaps even meaningful text on  some subject with as few occurrences of a given “word” as possible. Our  task is to provide the jury with a program that counts these  occurrences, in order to obtain a ranking of the competitors. These  competitors often write very long texts with nonsense meaning; a  sequence of 500,000 consecutive ‘T’s is not unusual. And they never use  spaces.</p><p> So we want to quickly find out how often a word, i.e., a given string,  occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …,  ‘Z’} and two finite strings over that alphabet, a word W and a text T,  count the number of occurrences of W in T. All the consecutive  characters of W must exactly match consecutive characters of T.  Occurrences may overlap.</p><p><strong>输入</strong></p><p>The first line of the input file contains a single number: the number of  test cases to follow. Each test case has the following format:</p><p> One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤  |W| ≤ 20,000 (here |W| denotes the length of the string W).<br> One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 2,000,000.</p><p><strong>输出</strong></p><p>For every test case in the input file, the output should contain a single  number, on a single line: the number of occurrences of the word W in the text T.</p><p><strong>样例输入</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">BAPC</span><br><span class="line">BAPC</span><br><span class="line">AZA</span><br><span class="line">AZAZAZA</span><br><span class="line">VERDI</span><br><span class="line">AVERDXIVYERDIAN</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><p>依旧是KMP（next数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算模式串（pattern）的前缀函数（也称为最长前缀后缀）</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_prefix_function</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    pi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; pattern[k] != pattern[i]) &#123;</span><br><span class="line">            k = pi[k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[k] == pattern[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文本串（text）中查找模式串（pattern）的出现次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pi = <span class="built_in">compute_prefix_function</span>(pattern);</span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; pattern[q] != text[i]) &#123;</span><br><span class="line">            q = pi[q<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[q] == text[i]) &#123;</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == m) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            q = pi[q<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        string pattern, text;</span><br><span class="line">        cin &gt;&gt; pattern &gt;&gt; text;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">kmp</span>(pattern, text) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-C-本质不同的子串"><a href="#问题-C-本质不同的子串" class="headerlink" title="问题 C: 本质不同的子串"></a>问题 C: 本质不同的子串</h3><p><strong>题目描述</strong></p><p>​    mfc是一个很优秀的同学，他学习认真，经常刷题。这天，他正好学习到了字符串的相关知识。为了巩固知识，他在网上找到了这样一个题目：给定n(n&lt;&#x3D;10)个字符串环，每个字符串的长度为m(m&lt;&#x3D;500)，保证每个字符串中只有小写字母，求出每个字符串环有多少个本质不同的子串（两个字符串不相同则认为本质不同）。 </p><p>​    求解本质不同的子串是一个经典的问题，mfc提出了三种效率不同的做法，最简单但是最慢的方法mfc不屑于去讲（你可以去写），当然你也可以使用字典树来记录所有的子串，时间复杂度O(m^2)，如果你也想像m队长一样厉害，也可以学习后缀自动机来求解该问题，时间复杂度O(m)。如果你可以使用效率较高的程序来解决这个问题，就可以到acm实验室与m队长一较高下！ </p><p><strong>输入</strong></p><blockquote><p>​一共有n+1行输入  </p><p>​第一行输入n，表示测试实例的个数  </p><p>​接下来的n行，每行包括一个测试实例  </p></blockquote><p><strong>输出</strong></p><blockquote><p>​对于每个测试实例，输出该字符串环中本质不同的子串个数，每个输出占一行。 </p></blockquote><p><strong>样例输入</strong>            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">aaa</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>          </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>​字符串环是指一种形成环的字符串，例如abc，字符a后面跟着b，b后面跟着c，c后面跟着a。如下图所示  </p><p>​<img src="http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221202/20221202230513_20658.png" alt="img">  </p><p>​ </p><p>​对于第一个测试实例aaa，它有a，aa，aaa三个本质不同的子串。  </p><p>​对于第二个测试实例abc，它有a，b，c，ab，bc，ca，abc，bca，cab九个本质不同的子串。  </p></blockquote><p> <strong>思路&amp;解答：</strong></p><p>模仿字符串“环”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">set&lt;string&gt; str;</span><br><span class="line">string s, ss;</span><br><span class="line"><span class="type">int</span> m;cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> q = <span class="number">0</span>; q &lt; m; q++) &#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">ss = s + s;<span class="comment">//拼接</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ss.<span class="built_in">length</span>(); i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ss.<span class="built_in">length</span>() - i; j++)</span><br><span class="line"><span class="keyword">if</span> (j &lt;= s.<span class="built_in">length</span>())</span><br><span class="line">str.<span class="built_in">insert</span>(ss.<span class="built_in">substr</span>(i, j));<span class="comment">//键值对存储</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">clear</span>();<span class="comment">//清空准备下次使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动机</p><p>字典树</p><h3 id="问题-D-最小公倍数"><a href="#问题-D-最小公倍数" class="headerlink" title="问题 D: 最小公倍数"></a>问题 D: 最小公倍数</h3><p><strong>题目描述</strong></p><p>给定两个正整数，计算这两个数的最小公倍数。</p><p><strong>输入</strong></p><p>输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.</p><p><strong>输出</strong></p><p>对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。</p><p><strong>样例输入</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 14</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">        <span class="type">int</span> g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">        cout &lt;&lt; a / g * b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="问题-E-素数求和"><a href="#问题-E-素数求和" class="headerlink" title="问题 E: 素数求和"></a>问题 E: 素数求和</h3><p><strong>题目描述</strong></p><p>输入一个正整数N，求N以内所有的素数之和对于unsigned long long自然溢出后的结果。 </p><p><strong>输入</strong></p><p>第一行一个整数N </p><p><strong>输出</strong></p><p>一行一个素数 </p><p><strong>样例输入</strong>      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>​数据范围：10≤N≤10^7 </p><p><strong>思路&amp;解答</strong></p><p>使用筛法+is_prime判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n, sum = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;<span class="built_in">is_prime</span>(n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>筛：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inc(i,j,k) for(re int i=j;i&lt;=k;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(i,j,k) for(re int i=j;i&gt;=k;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> re <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"> <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"> <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+(ch^<span class="number">48</span>); ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"> <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>;</span><br><span class="line"><span class="type">bool</span> notprime[N+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> pri[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(notprime,<span class="number">0</span>,<span class="built_in">sizeof</span>(notprime));</span><br><span class="line"> notprime[<span class="number">0</span>]=notprime[<span class="number">1</span>]=<span class="number">1</span>; tot=<span class="number">0</span>;</span><br><span class="line"> <span class="built_in">inc</span>(i,<span class="number">2</span>,N)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!notprime[i]) pri[++tot]=i;</span><br><span class="line">  <span class="keyword">for</span>(re <span class="type">int</span> j=<span class="number">1</span>; j&lt;=tot &amp;&amp; i*pri[j]&lt;=N; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   notprime[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(!(i%pri[j])) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">prim</span>();</span><br><span class="line"> <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">inc</span>(i,<span class="number">1</span>,tot)&#123;</span><br><span class="line">  <span class="keyword">if</span>(pri[i]&lt;=n)&#123;</span><br><span class="line">   sum+=pri[i];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-F-人见人爱A-B"><a href="#问题-F-人见人爱A-B" class="headerlink" title="问题 F: 人见人爱A^B"></a>问题 F: 人见人爱A^B</h3><p><strong>题目描述</strong></p><p>求A^B的最后三位数表示的整数。<br> 说明：A^B的含义是“A的B次方”</p><p><strong>输入</strong></p><p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;&#x3D;A,B&lt;&#x3D;10000），如果A&#x3D;0, B&#x3D;0，则表示输入数据的结束，不做处理。</p><p><strong>输出</strong></p><p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</p><p><strong>样例输入</strong>            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">12 6</span><br><span class="line">6789 10000</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">984</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>思路&amp;解答</strong></p><p>因为只要最后三位，如果多余三位，只保留后三位（%1000）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> A, B;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; A &gt;&gt; B &amp;&amp; !(A == <span class="number">0</span> &amp;&amp; B == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (B &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (B &amp; <span class="number">1</span>) &#123;</span><br><span class="line">ans = (ans * A) % <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line">A = (A * A) % <span class="number">1000</span>;</span><br><span class="line">B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">a %= m;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)res = res * a % m;</span><br><span class="line">a = a * a % m;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, p;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">Pow</span>(a,b,p);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-G-XORinacci"><a href="#问题-G-XORinacci" class="headerlink" title="问题 G: XORinacci"></a>问题 G: XORinacci</h3><p><strong>题目描述</strong></p><p>​Cengiz recently learned Fibonacci numbers and now he is studying  different algorithms to find them. After getting bored of reading them,  he came with his own new type of numbers that he named XORinacci numbers. He defined them as follows:</p><ul><li>​f(0)&#x3D;a </li><li>​f(1)&#x3D;b </li><li>​f(n)&#x3D;f(n−1)⊕f(n−2) when n&gt;1, where ⊕ denotes the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR">bitwise XOR operation</a>.</li></ul><p>​You are given three integers a, b, and n, calculate f(n).</p><p>​You have to answer for T independent test cases.</p><p><strong>输入</strong></p><p>​The input contains one or more independent test cases.</p><p>​The first line of input contains a single integer T (1≤T≤1000), the number of test cases.</p><p>​Each of the T following lines contains three space-separated integers a, b, and n (0≤a,b,n≤10^9) respectively.</p><p><strong>输出</strong></p><p>For each test case, output f(n).</p><p><strong>样例输入</strong>             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 2</span><br><span class="line">4 5 0</span><br><span class="line">325 265 1231232</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">4</span><br><span class="line">76</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>In the first example, f(2)&#x3D;f(0)⊕f(1)&#x3D;3⊕4&#x3D;7</p><p><strong>思路&amp;解答</strong></p><p>找规律得结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, INF_BIT = <span class="number">0x3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> a, b, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a ^ b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="问题-H-不同的n-x2F-i"><a href="#问题-H-不同的n-x2F-i" class="headerlink" title="问题 H: 不同的n&#x2F;i"></a>问题 H: 不同的n&#x2F;i</h3><p><strong>题目描述</strong></p><p>给定一个n，对于i从1到n，找出有多少个不同的n&#x2F;i<br> 如：n&#x3D;6<br> 有4个不同的n&#x2F;i：6，3，2，1 </p><p><strong>输入</strong></p><p>第一行一个T，表示有T组数据(T &lt; 100000)<br> 之后T行，每行一个n(n &lt;&#x3D; 10^18) </p><p><strong>输出</strong></p><p>每行输出一个数，表示不同的个数 </p><p><strong>样例输入</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>               </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>对于50%的数据：n &lt;&#x3D; 100000, T &lt;&#x3D; 10<br> 对于100%的数据：n &lt;&#x3D; 10^18, T &lt; 100000</p><p><strong>思路&amp;解答</strong></p><p>依旧是找规律写代码</p><table><thead><tr><th>i&#x3D;1</th><th>1(1)</th><th></th></tr></thead><tbody><tr><td>i&#x3D;2</td><td>2(2,3)</td><td>3(4,5)</td></tr><tr><td>i&#x3D;3</td><td>4(6,7,8)</td><td>5(9,10,11)</td></tr><tr><td>i&#x3D;4</td><td>6(12,13,14,15)</td><td>7(16,17,18,19)</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line">        <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            cin &gt;&gt; i;</span><br><span class="line">            <span class="type">int</span> n = (<span class="type">int</span>)((<span class="number">-1</span> + <span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">4</span> * i)) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> k = (<span class="type">int</span>)((<span class="number">-1</span> + <span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">4</span> * (i - n))) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n==k+<span class="number">1</span>)cout &lt;&lt; <span class="number">2</span> * n - <span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="number">2</span> * n<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序设计综合实践练习&quot;&gt;&lt;a href=&quot;#程序设计综合实践练习&quot; class=&quot;headerlink&quot; title=&quot;程序设计综合实践练习&quot;&gt;&lt;/a&gt;程序设计综合实践练习&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一，基础算法1&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    
    <category term="程序设计 OJ" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-OJ/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-07T10:49:47.452Z</published>
    <updated>2023-04-07T10:49:47.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机系统基础"><a href="#计算机系统基础" class="headerlink" title="计算机系统基础"></a>计算机系统基础</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><p>一种将程序指令存储器和数据存储器合并在一起的一种计算机组织结构</p><ul><li>运算器（ALU）</li><li>控制器（Controller）</li></ul><p>（前两个称为CPU（MPU</p><ul><li><p>存储器（Memory）</p></li><li><p>输入设备（Input device）</p></li><li><p>输出设备（Output Device）</p></li></ul><p>后两个叫IO设备</p><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\697508b76e3781cdd09216f282dce4d.png" alt="697508b76e3781cdd09216f282dce4d" style="zoom:67%;" /><ul><li>数据总线（Data Bus）：在CPU与RAM之间来回传送需要处理或是需要储存的数据。</li><li>地址总线（Address Bus）：用来指定在RAM（Random Access Memory）之中储存的数据的地址。</li><li>控制总线（Control Bus）：将微处理器控制单元（Control Unit）的信号，传送到周边设备。</li><li>扩展总线（Expansion Bus）：外部设备和计算机主机进行数据通信的总线，例如ISA总线，PCI总线。</li><li>局部总线（Local Bus）：取代更高速数据传输的扩展总线。</li></ul><p>其中的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF/272650?fromModule=lemma_inlink">数据总线</a>DB（Data Bus）、<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF/4307936?fromModule=lemma_inlink">地址总线</a>AB（Address Bus）和<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF/272568?fromModule=lemma_inlink">控制总线</a>CB（Control Bus），也统称为<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF?fromModule=lemma_inlink">系统总线</a>，即通常意义上所说的总线。</p><h2 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h2><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h3 id="addressing-and-Byte-Ordering（字节序（大小端））"><a href="#addressing-and-Byte-Ordering（字节序（大小端））" class="headerlink" title="addressing and Byte Ordering（字节序（大小端））"></a>addressing and Byte Ordering（字节序（大小端））</h3><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\45d407b6c4cf35fd989a1e533eb67d7.png" alt="45d407b6c4cf35fd989a1e533eb67d7" style="zoom:50%;" /><p>（上：大端；下：小端）</p><p>（endian：（查不到）《格列佛游记》无所谓之争）</p><p>x86小端多，网络协议大端多</p><h3 id="Word-Size（字长）"><a href="#Word-Size（字长）" class="headerlink" title="Word Size（字长）"></a>Word Size（字长）</h3><p>Until recently，most machines used 32bits（4bytes）as word size</p><p>Limits addresses to 4GB(2^32 bytes)</p><p>TiB更精确，TB小点（不同单位不一样）<img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\36c50892cbd27aee0ae0fe7808306ac.png" alt="36c50892cbd27aee0ae0fe7808306ac" style="zoom:50%;" /></p><h3 id="Representing-Pointers"><a href="#Representing-Pointers" class="headerlink" title="Representing Pointers"></a>Representing Pointers</h3><h3 id="Representing-Code"><a href="#Representing-Code" class="headerlink" title="Representing Code"></a>Representing Code</h3><p>指令集不同，跨平台能力不同</p><h4 id="封装格式：PE（可移zhi），ELF"><a href="#封装格式：PE（可移zhi），ELF" class="headerlink" title="封装格式：PE（可移zhi），ELF"></a>封装格式：PE（可移zhi），ELF</h4><h3 id="Boolean-Algebra"><a href="#Boolean-Algebra" class="headerlink" title="Boolean Algebra"></a>Boolean Algebra</h3><h4 id="And-amp-；Or-；“Not-”；Xor-（异或）；"><a href="#And-amp-；Or-；“Not-”；Xor-（异或）；" class="headerlink" title="And&amp;；Or|；“Not~”；Xor^（异或）；"></a>And&amp;；Or|；“Not~”；Xor^（异或）；</h4><p>异或异或太重要了！！！！</p><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\81680077440ffe2b18d57c076c5854d.png" alt="81680077440ffe2b18d57c076c5854d" style="zoom:50%;" /><h3 id="Logical-Operations-in-C（逻辑）"><a href="#Logical-Operations-in-C（逻辑）" class="headerlink" title="Logical Operations in C（逻辑）"></a>Logical Operations in C（逻辑）</h3><p>||（或；&amp;&amp;（与；！（非；</p><p><strong>short Circuit</strong>前成立后不执行</p><p>有效防止除零和空指针运算</p><h3 id="Shift-Operations-in-C-位移"><a href="#Shift-Operations-in-C-位移" class="headerlink" title="Shift Operations in C(位移)"></a>Shift Operations in C(位移)</h3><p>&lt;&lt;;&gt;&gt;(算术右移（补数据最高位）；逻辑右移)</p><h3 id="Undefined-Behavior（未定义行为）"><a href="#Undefined-Behavior（未定义行为）" class="headerlink" title="Undefined Behavior（未定义行为）"></a>Undefined Behavior（未定义行为）</h3><p>可读性</p><h3 id="Operator-precedence-issues"><a href="#Operator-precedence-issues" class="headerlink" title="Operator precedence issues"></a>Operator precedence issues</h3><p>加减大于位移</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>底层实现</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>gcc -o1 p1.c p2.c -o p</p><p>-o1优化，p1.c,p2.c编译为p文件</p><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\a2d70754da27d5fd6f1c7350bd0b254.png" alt="a2d70754da27d5fd6f1c7350bd0b254" style="zoom:50%;" /><p>linker链接部分错误更隐蔽</p><h5 id="汇编转换"><a href="#汇编转换" class="headerlink" title="汇编转换"></a>汇编转换</h5><img src="C:\Users\17687\Desktop\HexoBlog\source\_posts\jiji\34d396975b427229df4709a9b91c51f.png" alt="34d396975b427229df4709a9b91c51f" style="zoom:50%;" /><h5 id="反汇编工具（linux）："><a href="#反汇编工具（linux）：" class="headerlink" title="反汇编工具（linux）："></a>反汇编工具（linux）：</h5><p>objdump -d winword.exe</p><p>gdb sum</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机系统基础&quot;&gt;&lt;a href=&quot;#计算机系统基础&quot; class=&quot;headerlink&quot; title=&quot;计算机系统基础&quot;&gt;&lt;/a&gt;计算机系统基础&lt;/h1&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/03/15/%E4%B8%8A%E7%BD%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/03/15/%E4%B8%8A%E7%BD%91/</id>
    <published>2023-03-14T16:00:00.000Z</published>
    <updated>2023-05-25T04:28:10.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="超简单教你科学上网"><a href="#超简单教你科学上网" class="headerlink" title="超简单教你科学上网"></a>超简单教你科学上网</h1><h2 id="一，科学上网"><a href="#一，科学上网" class="headerlink" title="一，科学上网"></a>一，科学上网</h2><h3 id="1-下载Clash（承载vpn的工具）（这个简洁很多我感觉"><a href="#1-下载Clash（承载vpn的工具）（这个简洁很多我感觉" class="headerlink" title="1.下载Clash（承载vpn的工具）（这个简洁很多我感觉"></a>1.下载Clash（承载vpn的工具）（这个简洁很多我感觉</h3><p>链接：<a href="https://pan.baidu.com/s/1l96-P0hxq3mVgVBocy_vEw?pwd=l7rs">https://pan.baidu.com/s/1l96-P0hxq3mVgVBocy_vEw?pwd=l7rs</a><br>提取码：l7rs</p><p>解压后(密码wind)打开文件夹里的猫猫头像（Clash for Windows.exe)</p><h3 id="这两个用哪个都可以"><a href="#这两个用哪个都可以" class="headerlink" title="这两个用哪个都可以"></a>这两个用哪个都可以</h3><p>只要学会加配置+选择结点，两个都一样</p><h3 id="2-购买订阅"><a href="#2-购买订阅" class="headerlink" title="2.购买订阅"></a>2.购买订阅</h3><p><a href="https://w1.v2free.top/auth/register?code=VXqA">https://w1.v2free.top/auth/register?code=VXqA</a><br><a href="https://v02.fl-aff.com/auth/register?code=qeNM">https://v02.fl-aff.com/auth/register?code=qeNM</a><br>这两个机场都不错<br>（一直在换着用）（</p><h3 id="3-导入订阅，使用Clash："><a href="#3-导入订阅，使用Clash：" class="headerlink" title="3.导入订阅，使用Clash："></a>3.导入订阅，使用Clash：</h3><p><strong>如果上面选了第一个：</strong></p><p>主页往下面一点有【Clash】[ 配置一键导入]，</p><p>但是这个网站的自己的教程我放这里：</p><p><a href="https://go.runba.cyou/doc/#/Windows/V2RayN">https://go.runba.cyou/doc/#/Windows/V2RayN</a></p><p>（这个是V2rayN（另一个承载工具的名字）但是方法我觉得用下面那个就可以（</p><p><strong>如果选第二个</strong></p><p>主要是会导入配置文件就ok（推荐下面这个配置方式</p><p><a href="https://help.fastlink.digital/clash_for_windows">https://help.fastlink.digital/clash_for_windows</a></p><p>（笔者建议，购买选第一个，然后承载容器选clash的</p><p>我粘这里</p><p><a href="https://w1.v2free.top/auth/register?code=VXqA">https://w1.v2free.top/auth/register?code=VXqA</a></p><p><a href="https://help.fastlink.digital/clash_for_windows">https://help.fastlink.digital/clash_for_windows</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;超简单教你科学上网&quot;&gt;&lt;a href=&quot;#超简单教你科学上网&quot; class=&quot;headerlink&quot; title=&quot;超简单教你科学上网&quot;&gt;&lt;/a&gt;超简单教你科学上网&lt;/h1&gt;&lt;h2 id=&quot;一，科学上网&quot;&gt;&lt;a href=&quot;#一，科学上网&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="科学上网" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/02/25/%E5%85%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%EF%BC%89/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/02/25/%E5%85%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%EF%BC%89/</id>
    <published>2023-02-25T13:21:41.280Z</published>
    <updated>2023-02-25T13:33:07.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="党课学习（近现代史）"><a href="#党课学习（近现代史）" class="headerlink" title="党课学习（近现代史）"></a>党课学习（近现代史）</h1><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><p>1840年鸦片战争</p><p>使中国由一个独立的封建国家变为半殖民地半封建国家</p><p>两大历史任务:一个是求得民族独立和人民解放；一个是实现国家繁荣富强和人民共同富裕。</p><p>1895年，马关条约签订。</p><p>1901年，在北京，辛丑条约的签订，标志清政府成为“洋人的朝廷”</p><p>1905年，民主革命先行者孙中山发起成立同盟会，提出了实质上是以建立资产阶级民主共和国为目标的政治纲领</p><p>1911年10月，辛亥革命爆发。1912年元旦，中华民国宣告成立。辛亥革命推翻了清王朝，使统治中国几千年的封建专制制度就此结束，民主共和国的观念从此深入人心。</p><p>辛亥革命开创了更完全意义上的近代民主革命，打开了社会进步的闸门，促进了人们的思想解放，并为此后革命斗争的发展，特别是为后来由中国共产党领导的新民主主义革命开辟了道路</p><p>辛亥革命并没有一个完整而彻底的反帝反封建的政治纲领，没有形成一个能够胜利地领导这场革命的坚强有力的革命政党。</p><p>软弱性</p><p>它的失败，给中国的先进分子以深刻的启发，使他们逐渐觉悟到必须另外探寻新的救国救民的道路。</p><p>1912年1月1日，中华民国临时政府成立，定都南京</p><p>1915年9月，陈独秀在上海创办的《青年杂志》（后改为《新青年》）</p><p>新文化运动的基本口号是“德先生”（Democracy）和“赛先生”（Science），也就是民主和科学</p><p>“民主”是指民主思想和民主政治；“科学”主要是指近代自然科学法则和科学精神。</p><p>1914年至1918年的第一次世界大战</p><p>1917年，列宁领导的俄国十月革命开辟了人类历史的新纪元。</p><p>十月革命第一次把社会主义从书本上的学说变成活生生的现实。</p><p>李大钊是中国颂扬俄国十月革命的第一人。</p><p>中国工人阶级的成长壮大，以及此时形成的比辛亥革命时期更为庞大的先进知识分子群，为接受马克思主义提供了客观的社会基础。</p><p>1919年5月4日爆发的五四运动</p><p>直接导火线是中国在巴黎和会上的外交失败</p><p>6月5日起，上海工人举行声援学生的罢工</p><p>五四运动是中国革命史上具有重大意义的事件，它标志着中国新民主主义革命的开端。</p><p>在五四运动以后的马克思主义传播中，李大钊起了主要作用。</p><p>1920年四五月间，《东方杂志》、《新青年》  等刊物刊登苏俄政府发表的第一次对华宣言。</p><p>国中之国是指租界地</p><p>中国共产党的建立，得到了列宁领导的第三国际（即共产国际，成立于1919年3月）的帮助</p><p>1920年8月，上海共产党组织正式成立，陈独秀任书记。</p><p>10月，北京共产党组织成立，李大钊为书记。</p><p>1922年5月5日，中国社会主义青年团成立。</p><p>1921年7月23日，中共一大在上海召开</p><p>党的一大正式宣告了中国共产党的成立。</p><p>马克思主义为行动指南</p><p>中国共产党的成立，适应了近代以来社会的进步和革命发展的客观要求，是开天辟地的大事变。</p><p>1922年7月16日至23日，中共二大在上海举行。</p><p>党的最高纲领：实现社会主义、共产主义。</p><p>最低纲领是：打倒军阀；推翻国际帝国主义的压迫；统一中国为真正的民主共和国。</p><p>中共二大在全国人民面前明确提出了反帝反封建的民主革命纲领。</p><p>1922年1月，香港海员罢工为起点，掀起中国工人运动的第一个高潮。</p><p>安源路矿工人大罢工、开滦煤矿工人大罢工最具代表性，</p><p>1923年2月4日爆发的京汉铁路三万名工人大罢工，使第一次工人运动浪潮达到顶峰。</p><p>2月7日，二七惨案发生</p><p>1923年6月12日至20日，在广州召开中共三大。</p><p>1924年1月20日至30日，国民党第一次全国代表大会由孙中山主持在广州举行。</p><p>国民党一大的成功，标志着第一次国共合作正式形成。</p><p>大革命开始</p><p>1925年1月11日至22日，中国共产党第四次全国代表大会在上海举行。</p><p>对建立政权和武装的极端重要性仍缺乏认识。</p><p>1925年3月12日，孙中山在北京逝世</p><p>1925年5月30日，中共中央在租界内举行大规模的反帝示威活动，上海工人和学生举行街头宣传和示威游行</p><p>1925年7月1日，国民政府在广州建立，汪精卫当选为主席</p><p>1926-1927年北伐战争能够取得胜利，是国共合作结出的丰硕成果。</p><p>1927年4月12日，四一二反革命政变发生后</p><p>1927年4月28日，李大钊在北京英勇就义。</p><p>7月15日，汪精卫召开国民党中央常务委员会扩大会议，正式同共产党决裂。第一次国共合作终于全面破裂，持续三年多的轰轰烈烈的大革命最后失败了。</p><p>这次大革命失败的原因，从客观上说，一是帝国主义和封建势力的联合力量比革命阵营的力量要强大得多，并且有更多的政治经验；二是国民党背信弃义地对共产党及其领导的工农群众发动突然袭击。在主观上，是陈独秀等人在后期犯了右倾机会主义的错误。</p><p>大革命结束</p><p>1927年8月7日，在汉口秘密召开八七会议。</p><p>由大革命失败到土地革命战争兴起的一个历史转折点。</p><p>8月1日，周恩来、贺龙、叶挺、朱德、刘伯承等人，率领北伐军二万多人南昌起义。</p><p>南昌起义打响了武装反抗国民党反动派的第一枪，标志着中国共产党独立地领导革命战争、创建人民军队和武装夺取政权的开始。</p><p>9月9日，毛泽东领导发动秋收起义。</p><p>随后进行了著名的三湾改编</p><p>12月11日，在广东省委书记张太雷和叶挺、叶剑英等领导下发动了广州起义</p><p>1928年6月18日至7月11日，中国共产党在苏联莫斯科召开第六次全国代表大会。</p><p>1929年12月，古田会议召开。毛泽东当选为书记</p><p>1931年9月18日，日本驻中国东北地区的关东军突然袭击沈阳，以武力侵占东北。</p><p>九一八事变</p><p>1931年11月7日至20日，在瑞金举行的第一次全国苏维埃代表大会上，宣布成立中华苏维埃共和国临时中央政府。毛泽东被选为临时中央政府主席。</p><p>1934年，长征开始</p><p>1935年1月15日至17日，召开遵义会议。</p><p>遵义会议是党的历史上一个生死攸关的转折点，以毛泽东为核心的党中央的正确领导开始确立，标志着中国共产党在政治上走向成熟。</p><p>1935年12月9日，举行一二九运动</p><p>1936年10月间，长征结束。</p><p>中国工农红军长征的胜利，是中国革命转危为安的关键。</p><p>12月17日至25日在瓦窑堡召开政治局扩大会议</p><p>瓦窑堡会议是从第五次反“围剿”失败到全民族抗战兴起过程中召开的一次重要会议。</p><p>从大革命失败到抗日战争前夕的十年，是中国共产党从幼年走向政治成熟的重要时期。在这个时期中，党曾两次经受严峻的考验：一次是大革命的失败，一次是第五次反“围剿”的失败。</p><p>1937年开始的全国抗日战争，既是关系中华民族生死存亡的关键一战，也是中国共产党发展壮大的重要时期。</p><p>7月7日夜，日本侵略军在北平西南的卢沟桥附近，向中国驻军突然发起进攻，中国官兵奋起抵抗。中华民族全面抗战就此拉开帷幕。七七事变</p><p>1937年9月23日，蒋介石发表实际上承认中国共产党合法地位的谈话，标志着以国共两党合作为基础的抗日民族统一战线正式形成。</p><p>1945年4月23日至6月11日，中国共产党第七次全国代表大会在延安隆重召开。</p><p>三大作风是指理论与实际相结合的作风、与人民群众紧密地联系在一起的作风以及批评与自我批评的作风。 </p><p>8月15日，日本天皇宣布无条件投降。9月2日，日本代表在向同盟国的投降书上签字。</p><p>中国抗日战争胜利结束，世界反法西斯战争也胜利结束</p><p>1945年8月28日，毛泽东偕周恩来、王若飞前往重庆同国民党当局进行谈判。</p><p>1946年6月26日，全面内战爆发。</p><p>1948年9月，林彪、罗荣桓指挥东北野战军，向分割在锦州、长春、沈阳等孤立地区的55万国民党军发起辽沈战役。</p><p>辽沈战役刚结束，发起淮海战役。</p><p>1月31日，北平和平解放。平津战役结束</p><p>1949年3月，又在河北平山县西柏坡召开七届二中全会。</p><p>9月21日，中国人民政治协商会议第一届全体会议在北平隆重开幕。</p><p>这次政协会议通过了《中国人民政治协商会议共同纲领》。</p><p>其中规定：“中华人民共和国为新民主主义即人民民主主义的国家，实行工人阶级领导的、以工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政”。</p><p>在全国人民代表大会制定宪法前，它具有临时宪法作用</p><p>1956年9月15日至27日，中国共产党第八次全国代表大会在北京举行。</p><p>中共八大的召开，标志着中国共产党在探索建设自己的社会主义道路上取得了初步的成果。</p><p>陈云提出的“三个主体，三个补充”思想，即：国家与集体经营、计划生产和国家市场是主体，一定范围内国家领导的个体经营、自由生产和自由市场作为补充。</p><p>“大跃进”运动从1957年底开始发动，1958年全面展开。</p><p>1958年5月,召开八大二次会议，正式提出“鼓足干劲、力争上游、多快好省地建设社会主义”的总路线。</p><p>“大跃进”和人民公社化运动，是党在探索建设中国自己的社会主义道路过程中的一次严重失误。</p><p>1961年1月，八届九中全会正式决定对国民经济实行“调整、巩固、充实、提高”的八字方针。</p><p>在1964年底到1965年初召开的第三届全国人民代表大会第一次会议上</p><p>从1956年到1966年“文化大革命”爆发前的十年，是党领导我国社会主义建设在探索中曲折发展的十年</p><p>总之，我国赖以进行现代化建设的物质技术基础，很大一部分是这个期间建设起来的；全国经济文化建设等方面的骨干力量和他们的工作经验，大部分是在这个期间培养和积累起来的。这是党在探索中国自己的建设社会主义道路十年工作中的主导方面。</p><p>1965年11月10日，上海《文汇报》发表的姚文元《评新编历史剧&lt;海瑞罢官&gt;》一文，是引发“文化大革命”的导火线。</p><p>1977年秋，在“文化大革命”中被废弃的高考制度得到恢复，全国高校重新通过统一考试招收新生。</p><p> 1978年12月18日至22日，党的十一届三中全会在北京召开。</p><p>十一届三中全会是建国以来党的历史上具有深远意义的伟大转折。这次全会彻底否定“两个凡是”的方针，重新确立解放思想、实事求是的指导思想，实现了思想路线的拨乱反正；停止使用“以阶级斗争为纲”的口号，作出工作重点转移的决策，实现了政治路线的拨乱反正；形成以邓小平为核心的党中央领导集体，取得了组织路线拨乱反正的最重要成果；审查和解决历史上遗留的一批重大问题和一些重要领导人的功过是非问题，开始了系统清理重大历史是非的拨乱反正。</p><p>十一届三中全会后，鉴于国民经济中一些重大比例关系严重失调的状况和经济工作中急于求成的现象的出现，党中央于1979年4月召开工作会议，制定“调整、改革、整顿、提高”的八字方针，开始对国民经济进行调整。</p><p>改革开放是自1978年12月十一届三中全会后中国开始实施的经济改革和措施，可总结为“对内改革、对外开放”，是中国特色社会主义的主要组成部分，于中共十五大被纳入党章，其中“对外开放”是中华人民共和国的基本国策之一。</p><p>此项改革实行混合经济模式，使中国经济高速发展，走向富强之路。</p><p>深圳、珠海、厦门、汕头试办经济特区</p><p>1988年4月，建立了海南经济特区。</p><p>一国两制即“一个国家，两种制度”，是中国政府为实现国家和平统一而提出的基本国策，是邓小平同志提出的具有中国特色社会主义理论之一。</p><p>“一国两制”指在一个中国前提下，国家主体坚持社会主义制度，香港、澳门、台湾保持原有的资本主义制度长期不变，旨在实现祖国和平统一的伟大构想。</p><p>106.党的群众路线是一切为了群众、一切依靠群众、从群众中来、到群众中去</p><p>\107. 民主集中制是我党的根本组织原则和组织制度。</p><p>\108. “两个维护”是指坚决维护习近平总书记在党中央和全党的核心地位，坚决维护</p><p>党中央权威和集中统一领导</p><p>109.党的领导主要是指政治、思想和组织的领导。</p><p>110.批评和自我批评是共产党员正确处理和解决党内矛盾的武器。</p><p>111.毛泽东思想的“活的灵魂”是实事求是、群众路线、独立自主</p><p>112.中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队。</p><p>113.社会主义精神文明建设的目标是，提高全民族的思想道德素质和科学文化素质。</p><p>114.我党执政的最大优势是密切联系群众，我党执政后的最大危险是脱离群众</p><p>115.我们党的最高理想和最终目标是实现共产主义</p><p>116.中国共产党的宗旨是全心全意为人民服务。</p><p>117.马克思列宁主义揭示了人类社会历史发展的规律，它的基本原理是正确</p><p>的，具有强大的生命力。</p><p>118.“三个代表”思想的精髓是解放思想、实事求是、与时俱进</p><p>\119. 在 新 时 代 ， 中 国 共 产 党 以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想作为自己的行动指南。</p><p>120.预备党员没有表决权、选举权、被选举权。</p><p>121.党员必须自觉遵守党的纪律，模范遵守国家的法律法规，严格保守党和国家</p><p>的秘密，执行党的决定，服从组织分配，积极完成党的任务。</p><p>122.社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，</p><p>最终达到共同富裕</p><p>123.发展党员，必须把政治标准放在首位，经过党的支部，坚持个别吸收的原</p><p>则。</p><p>124.中国共产党领导全国各族人民，经过长期的反对帝国主义、封建主义、官僚资本主义</p><p>的革命战争，取得了新主义革命的胜利，建立了人民民主专政的中华人民共和国。</p><p>125.改革开放以来我们取得的一切成绩和进步的根本原因，归结起来就是：</p><p>开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系</p><p>126.在社会主义现代化建设中，必须坚持的四项基本原则是:</p><p>坚持社会主义道路、</p><p>坚持人民民主专政、</p><p>坚持中国共产党的领导、</p><p>坚持马克思列宁主义毛泽东思想</p><p>127.党的纪律处分有五种：警告、严重警告、撤销党内职务、留党察看、开除党籍。</p><p>128.习近平在党的群众路线实践活动工作会议上谈到：开展党的群众路线教育实</p><p>践活动，是保持党的先进性和纯洁性、巩固党的执政基础和执政地位的必然要求。</p><p>\129. 建 设 学 习 型 党 组 织 ， 应 当 遵 循 以 下 主 要 原 则 ： 坚持解放思想，实事求是，与时俱进、坚持理论联系实际的马克思主义学风、坚持领导干部作表率，调动广大党员的积极主动性、坚持改革创新，鼓励大胆探索。</p><p>130.请补全入党誓词：</p><p>“我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。”</p><p>131.发展是解决我国一切问题的基础和关键，发展必须是科学发展，必须坚定不</p><p>移贯彻创新、协调、绿色、开放、共享的发展理念。</p><p>132.“两学一做”是指学党章党规、学系列讲话、做合格党员</p><p>133.新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</p><p>134.中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”。</p><p>\135. 习 近 平 总 书 记 在 十 九 大 报 告 中 提 出 ， 要 为 把 我 国 建 设 成 为富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p><p>136.中国共产党党徽为镰刀和锤头组成的图案。</p><p>137.十九大报告指出，我们要坚持党的领导、人民当家作主、依法治国有机统一。其中，人民当家作主是社会主义民主政治的本质特征。</p><p>1.（第七十期）新党章总纲指出我国社会主义建设的根本任务是什么？（4 分）</p><p>答案：</p><p>我国社会主义建设的根本任务，是进一步解放生产力（1 分），</p><p>发展生产力（1 分），</p><p>逐步实现社会主义现代化（1 分），</p><p>并且为此而改革生产关系和上层建筑中不适应生产力发展的方面和环节（1 分）。</p><p>（要求一字不差）</p><p>2.（第七十期）中国共产党的性质是什么？（6 分）</p><p>答案：</p><p>中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队（1 分），</p><p>是中国特色社会主义事业的领导核心（1 分），</p><p>代表中国先进生产力的发展要求（1 分），</p><p>代表中国先进文化的前进方向（1 分），</p><p>代表中国最广大人民的根本利益（1 分）。</p><p>党的最高理想和最终目标是实现共产主义（1分）。（要求一字不差）</p><p>3.（第七十期）中国共产党的建设必须坚决实现哪五项基本要求？（6 分）</p><p>答案：</p><p>第一，坚持党的基本路线（1 分）；</p><p>第二，坚持解放思想，实事求是（1 分），与时俱进，求真务实（1 分）；</p><p>第三，坚持全心全意为人民服务（1分）；</p><p>第四，坚持民主集中制（1 分）；</p><p>第五，坚持从严管党治党（1 分）。</p><p>（要求一字不差）</p><p>4.（第七十期）社会主义核心价值体系的基本内容是什么？（4 分）</p><p>答案：</p><p>马克思主义指导思想（1 分）、</p><p>中国特色社会主义共同理想（1 分）、</p><p>以爱国主义为核心的民族精神和以改革创新为核心的时代精神（1 分）、</p><p>社会主义荣辱观（1 分）。（要求一字不差）</p><p>5.（第六十七期）天大品格的核心表达是什么？（5 分）</p><p>答案：</p><p>“兴学强国”的使命（1 分）、</p><p>“实事求是”的校训（1 分）、</p><p>“严谨治学”的校风（1 分）、</p><p>“爱国奉献”的传统（1 分）和</p><p>“矢志创新”的追求（1 分），这是天大品格的核心表达。（要求一字不差）</p><p>6.（第六十九期）现阶段我国社会的主要矛盾是什么？（2 分）</p><p>答案：</p><p>在现阶段，我国社会的主要矛盾是人民日益增长的美好生活需要（1分）和</p><p>不平衡不充分的发展（1 分）之间的矛盾。（要求一字不差）</p><p>7.（第六十九期）党的十九届五中全会提出的“四个全面”战略布局是什么？（4</p><p>分）</p><p>答案：</p><p>全面建设社会主义现代化国家（1 分）、</p><p>全面深化改革（1 分）、</p><p>全面依法治国（1 分）、</p><p>全面从严治党（1 分）。（要求一字不差）</p><p>8.（第六十七期）中国共产党成立以来，带领人民使国家实现了哪三大历史的转</p><p>变？（3 分）</p><p>答案：</p><p>从半殖民地半封建社会到民族独立、人民当家作主新社会的历史性转变（1 分），</p><p>从新民主主义革命到社会主义革命和建设的历史性转变（1 分），</p><p>从高度集中的计划经济体制到充满活力的社会主义市场经济体制、从封闭半封闭</p><p>到全方位开放的历史性转变（1 分）。</p><p>9.（第六十六期）中国共产党的思想路线是什么？（4 分）</p><p>答案：</p><p>党的思想路线是一切从实际出发（1 分），</p><p>理论联系实际（1 分），</p><p>实事求是（1 分），</p><p>在实践中检验真理和发展真理（1 分）。（要求一字不差）</p><p>10．（第六十六期）“三个代表”重要思想的内容是什么？（3 分）</p><p>答案：</p><p>中国共产党要始终代表中国先进生产力的发展要求（1 分）、</p><p>中国共产党要始终代表中国先进文化的前进方向（1 分）、</p><p>中国共产党要始终代表中国最广大人民的根本利益（1 分）。（要求一字不差）</p><p>2.中国共产党的宗旨是什么？</p><p>答案：中国共产党的宗旨是全心全意为人民服务。</p><p>3.中国共产党的指导思想是什么？</p><p>答案：党的指导思想，也称党的行动指南。中国共产党以马克思列宁主义、</p><p>毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代</p><p>中国特色社会主义思想作为自己的行动指南。</p><p>4.中国共产党在社会主义初级阶段的基本路线是什么？</p><p>答案：中国共产党在社会主义初级阶段的基本路线是：领导和团结全国各族</p><p>人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦</p><p>创业，为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p><p>5.中国共产党的政治路线是什么？</p><p>答案：政治路线是党的纲领的具体体现，它决定着党在一定历史时期行动的</p><p>方向，也决定着党的建设的方向。党在社会主义初级阶段的基本路线作为党的政</p><p>治路线，即领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，</p><p>坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强民主文明和谐美丽</p><p>的社会主义现代化强国而奋斗。</p><p>6.中国共产党的思想路线是什么？</p><p>答案：党的思想路线是一切从实际出发，理论联系实际，实事求是，在实践</p><p>中检验真理和发展真理。</p><p>7.中国共产党的群众路线是什么？</p><p>答案：中国共产党的群众路线是一切为了群众，一切依靠群众。从群众中来，</p><p>到群众中去，把党的正确主张变为群众的自觉行动。</p><p>8.中国特色社会主义理论体系是什么？</p><p>答案：中国特色社会主义理论体系，就是包括邓小平理论、“三个代表”重</p><p>要思想、科学发展观以及习近平新时代中国特色社会主义思想等重大战略思想在</p><p>内的科学理论体系。</p><p>9.科学发展观的科学内涵是什么？</p><p>答案：科学发展观，第一要义是发展，核心是以人为本，基本要求是全面协</p><p>调可持续，根本方法是统筹兼顾。</p><p>10.构建社会主义和谐社会的总要求是什么？</p><p>答案：民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和</p><p>谐相处。</p><p>11.社会主义核心价值体系的基本内容是什么？</p><p>答案：马克思主义指导思想，中国特色社会主义共同理想，以爱国主义为核</p><p>心的民族精神和以改革创新为核心的时代精神，社会主义荣辱观，这四个方面构</p><p>成社会主义核心价值体系的基本内容。</p><p>12.社会主义核心价值观的基本内容是什么？</p><p>答案：富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、</p><p>诚信、友善。</p><p>13.中国共产党的建设必须坚决实现哪五项基本要求？</p><p>答案：第一，坚持党的基本路线；第二，坚持解放思想，实事求是，与时俱</p><p>进，求真务实；第三，坚持全心全意为人民服务；第四，坚持民主集中制；第五，</p><p>坚持从严管党治党。</p><p>14.党的执政能力是什么？</p><p>答案：执政能力一般指以执政党为主体、以国家权力系统为客体的执政党执</p><p>掌国家政权的能力。党的执政能力特指中国共产党的执政能力，是指党在执政过</p><p>程中驾驭社会主义市场经济的能力、发展社会主义民主政治的能力、建设社会主</p><p>义先进文化的能力、构建社会主义和谐社会的能力、应对国际局势和处理国际事</p><p>务的能力。</p><p>15.新时期共产党员保持先进性的基本要求是什么？</p><p>答案：一是要坚持理想信念，坚定不移地为建设中国特色社会主义而奋斗；</p><p>二是要坚持勤奋学习，扎扎实实地提高实践“三个代表”重要思想的本领；三是</p><p>要坚持党的根本宗旨，始终不渝地做到立党为公、执政为民；四是要坚持勤奋工</p><p>作，兢兢业业地创造一流的工作业绩；五是要坚持遵守党的纪律，身体力行地维</p><p>护党的团结统一；六是要坚持“两个务必”，永葆共产党人的政治本色。（答出</p><p>每一小点的前半部分即可）</p><p>16.中国共产党的三大作风是什么？</p><p>答案：中国共产党的三大作风是理论联系实际的作风、和人民群众紧密联系</p><p>在一起的作风、批评和自我批评的作风。</p><p>17.中国共产党的纪律有哪些？</p><p>答案：党的纪律主要包括政治纪律、组织纪律、廉洁纪律、群众纪律、工作</p><p>纪律、生活纪律。</p><p>18.“三个代表”重要思想的内容是什么？</p><p>答案：中国共产党要始终代表中国先进生产力的发展要求、中国共产党要始</p><p>终代表中国先进文化的前进方向、中国共产党要始终代表中国最广大人民的根本</p><p>利益。</p><p>19.根据天津大学入党流程图，从具有入党意愿到成为发展对象的过程中需要完</p><p>成哪些流程？</p><p>答案：递交入党申请书、网上党校学习、结业考试通过、通过院级积极分子</p><p>党校、递交四个季度的思想汇报、参加申请人学习小组、被确定为积极分子、团</p><p>支部推优。</p><p>20.新党章总纲指出我国社会主义建设的根本任务什么?</p><p>答案：我国社会主义建设的根本任务，是进一步解放生产力，发展生产力，</p><p>逐步实现社会主义现代化，并且为此而改革生产关系和上层建筑中不适应生产力</p><p>发展的方面和环节。</p><p>21.在新世纪新时代，经济和社会发展的战略目标即“两个一百年”奋斗目标是</p><p>什么？</p><p>答案：到建党一百年时，全面建成小康社会；到新中国成立一百年时，全面</p><p>建成社会主义现代化强国。</p><p>22.中国共产党的最高纲领和现阶段最低纲领是什么？</p><p>答案：中国共产党的最高纲领是实现共产主义，现阶段最低纲领是建设有中</p><p>国特色社会主义经济、政治、文化。</p><p>23.中国共产党成立以来，带领人民使国家实现了哪三大历史的转变？</p><p>答案：从半殖民地半封建社会到民族独立、人民当家作主新社会的历史性转</p><p>变，从新民主主义革命到社会主义革命和建设的历史性转变，从高度集中的计划</p><p>经济体制到充满活力的社会主义市场经济体制、从封闭半封闭到全方位开放的历</p><p>史性转变。</p><p>24.四项基本原则的内容是什么?</p><p>答案：坚持社会主义道路、坚持人民民主专政、坚持中国共产党的领导、坚</p><p>持马克思列宁主义毛泽东思想。</p><p>25.和平共处五项原则的内容是什么？</p><p>答案：互相尊重主权及领土完整、互不侵犯、互不干涉内政、平等互利、和</p><p>平共处</p><h2 id="党课答案："><a href="#党课答案：" class="headerlink" title="党课答案："></a>党课答案：</h2><p> <a href="C:\Users\17687\Desktop\HexoBlog\source_posts\党课答案.pdf">党课答案.pdf</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;党课学习（近现代史）&quot;&gt;&lt;a href=&quot;#党课学习（近现代史）&quot; class=&quot;headerlink&quot; title=&quot;党课学习（近现代史）&quot;&gt;&lt;/a&gt;党课学习（近现代史）&lt;/h1&gt;&lt;h2 id=&quot;基础知识：&quot;&gt;&lt;a href=&quot;#基础知识：&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>思想道德与法制</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/02/05/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E5%88%B6/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/02/05/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E5%88%B6/</id>
    <published>2023-02-04T16:00:00.000Z</published>
    <updated>2023-02-26T00:46:14.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想道德与法制"><a href="#思想道德与法制" class="headerlink" title="思想道德与法制"></a>思想道德与法制</h1><p>该总结融合三个总结文档，标题后数字是被考次数，全篇手打，如果有错字错意，感谢联系我（qq：1768765226）修改回正。</p><p>（暂时更新至第三章完）</p><p>[TOC]</p><h2 id="担当复兴大任，成就时代新人"><a href="#担当复兴大任，成就时代新人" class="headerlink" title="担当复兴大任，成就时代新人"></a>担当复兴大任，成就时代新人</h2><p>（11-s2)</p><p>时间之河川流不息，每一代年轻人都要面对和回答时代的问卷。我们面临的时代，拥有广阔发展空间，承载伟大时代使命。大学阶段是我们人生发展一个重要的时期，是世界观、人生观、价值观形成的关键时期，我在复习《思想道德与法制》的时候，有一些自己的学习与体会，请允许我娓娓道来：</p><p>绪论中提到，新时代呼唤担当民族复兴大任的时代新人：立大志（崇高的理想信念，牢记使命，自信自励，“功崇惟志，业广惟勤”）、明大德（锤炼高尚品格，崇德修身，启润青春，“重莫如国，栋莫如德”）、成大才（高强本领才干，勤奋学习，全面发展“青春虚度无所成，白首衔悲亦何及”，建设学习型社会）、担大任（天下兴亡，匹夫有责的担当精神，讲求奉献，实干进取，“历尽天华成此景，人间万事出艰辛”），努力为新时代贡献青春力量，让青春在为祖国、为民族、为人民、为人类的不懈奋斗中绽放绚丽之花。</p><h2 id="领悟人生真谛，把握人生方向"><a href="#领悟人生真谛，把握人生方向" class="headerlink" title="领悟人生真谛，把握人生方向"></a>领悟人生真谛，把握人生方向</h2><h3 id="人生观是对人生的总看法"><a href="#人生观是对人生的总看法" class="headerlink" title="人生观是对人生的总看法"></a>人生观是对人生的总看法</h3><h4 id="正确认识人的本质"><a href="#正确认识人的本质" class="headerlink" title="正确认识人的本质"></a>正确认识人的本质</h4><h5 id="马克思主义关于人的本质的认识（1）"><a href="#马克思主义关于人的本质的认识（1）" class="headerlink" title="马克思主义关于人的本质的认识（1）"></a>马克思主义关于人的本质的认识（1）</h5><p>人的本质：不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和</p><h5 id="个人与社会的辩证关系"><a href="#个人与社会的辩证关系" class="headerlink" title="个人与社会的辩证关系"></a>个人与社会的辩证关系</h5><p>社会利益不是个人利益的简单相加，而是所有人利益的有机统一；社会利益体现了作为社会成员的个人的根本利益的长远利益，是个人利益得以实现的前提和基础，同时也保障着个人利益的实现。</p><h5 id="（16）人生观的主要内容：（7）"><a href="#（16）人生观的主要内容：（7）" class="headerlink" title="（16）人生观的主要内容：（7）"></a>（16）<strong>人生观的主要内容</strong>：（7）</h5><p>人生目的（核心）：人们在社会实践中关于自身行为的根本指向和人生追求；人生目的决定人生道路、人生态度；决定人们对待实际生活的态度和对人生价值的实现。</p><p>人生态度：（人生观导致）人们通过生活实践形成的对人生问题的一种相对稳定的心理倾向和精神状态；影响人们对人生目的的持守和人生价值的实现。</p><p>人生价值：人的生命及其实践活动对于社会和个人所具有的作用和意义；包含人生的自我价值和社会价值；制约人们对人生目的和人生态度的选择。</p><h6 id="（39-1）"><a href="#（39-1）" class="headerlink" title="（39-1）"></a>（39-1）</h6><ul><li>人生的个人价值和社会价值，既相互区别，又相互联系，共同构成人生价值的统一矛盾体</li><li>一方面，人生的自我价值是个体生存和发展的必要条件，人生的自我价值是实现个体为社会创造更大价值的前提</li><li>另一方面，人生的社会价值是社会存在和发展的重要条件，人生社会价值的实现是个体自我完善，全面发展的保障。</li><li>没有社会价值，人生的自我价值就无法存在</li></ul><h5 id="人生观与世界观、价值观"><a href="#人生观与世界观、价值观" class="headerlink" title="人生观与世界观、价值观"></a>人生观与世界观、价值观</h5><p>世界观是人们对生活在其中的世界以及人与世界的关系的总体看法和根本观点。</p><p>价值观是人们关于价值的根本观点，对于人生观的形成和发展有重要的引导作用。</p><h3 id="正确的人生观"><a href="#正确的人生观" class="headerlink" title="正确的人生观"></a>正确的人生观</h3><h4 id="高尚的人生追求"><a href="#高尚的人生追求" class="headerlink" title="高尚的人生追求"></a>高尚的人生追求</h4><p>白求恩：一个高尚的人，一个纯粹的人，一个有道德的人，一个脱离了低级趣味的人，一个有益于人民的人。</p><h4 id="积极进取的人生态度"><a href="#积极进取的人生态度" class="headerlink" title="积极进取的人生态度"></a>积极进取的人生态度</h4><p>认真，务实，乐观，进取</p><h4 id="（18）人生观的自我价值和社会价值"><a href="#（18）人生观的自我价值和社会价值" class="headerlink" title="（18）人生观的自我价值和社会价值"></a>（18）人生观的自我价值和社会价值</h4><h4 id="（26）人生价值的评价与实现"><a href="#（26）人生价值的评价与实现" class="headerlink" title="（26）人生价值的评价与实现"></a>（26）人生价值的评价与实现</h4><h5 id="正确评价人生价值（3）"><a href="#正确评价人生价值（3）" class="headerlink" title="正确评价人生价值（3）"></a>正确评价人生价值（3）</h5><p>看一个人的实践活动是否符合社会发展的客观规律，是否促进了历史的进步。</p><ul><li>贡献大小与尽力程度         （能力有大小，贡献须尽力）         </li><li>物质贡献与精神贡献统一</li><li>社会贡献与自身完善统一</li></ul><h5 id="人生价值的实现条件（3）"><a href="#人生价值的实现条件（3）" class="headerlink" title="人生价值的实现条件（3）"></a>人生价值的实现条件（3）</h5><ul><li>从社会客观条件</li><li>从个体自身条件</li><li>不断增强能力和本领</li></ul><h3 id="创造有意义的人生"><a href="#创造有意义的人生" class="headerlink" title="创造有意义的人生"></a>创造有意义的人生</h3><h4 id="辩证对待人生矛盾（6）"><a href="#辩证对待人生矛盾（6）" class="headerlink" title="辩证对待人生矛盾（6）"></a>辩证对待人生矛盾（6）</h4><p>得与失，苦与乐，顺与逆，生与死，荣与辱</p><p>树立正确幸福观，得失观，苦乐观，生死观，荣辱观</p><p>“塞翁失马焉知非福”“宝剑锋从磨砺出，梅花香自苦寒来”“踏平坎坷城大道，斗罢艰险又出发”“人固有一死”“</p><h4 id="（34）反对错误人生观（3）"><a href="#（34）反对错误人生观（3）" class="headerlink" title="（34）反对错误人生观（3）"></a>（34）反对错误人生观（3）</h4><p>拜金主义</p><p>享乐主义</p><p>极端个人主义</p><h4 id="成就出彩人生"><a href="#成就出彩人生" class="headerlink" title="成就出彩人生"></a>成就出彩人生</h4><p>与历史同向</p><p>与祖国同行</p><p>与人民同在</p><h2 id="追求远大理想-坚定崇高信念"><a href="#追求远大理想-坚定崇高信念" class="headerlink" title="追求远大理想 坚定崇高信念"></a>追求远大理想 坚定崇高信念</h2><h3 id="（41）什么是理想信念"><a href="#（41）什么是理想信念" class="headerlink" title="（41）什么是理想信念"></a>（41）什么是理想信念</h3><p><strong>理想信念是人类特有的精神现象。</strong>人既需要物质资料来实现生存和发展，也需要理想信念来充实精神生活。正确坚定理想信念，激励人们为一定的社会理想和生活目标而努力奋斗。</p><h4 id="理想的内涵与特征-6"><a href="#理想的内涵与特征-6" class="headerlink" title="理想的内涵与特征 6"></a>理想的内涵与特征 <strong>6</strong></h4><p>内涵：</p><p>理想是一定社会关系的目标，是一定社会关系的产物。</p><p>理想是人们在实践中形成的，有现实可能性的、对未来社会和自身发展目标的向往与追求，是人们的世界观、人生观和价值观在奋斗目标上的集中体现。</p><p>特征：<strong>超越性、实践性、时代性。</strong></p><h4 id="信念的内涵与特征-6"><a href="#信念的内涵与特征-6" class="headerlink" title="信念的内涵与特征 6"></a>信念的内涵与特征 <strong>6</strong></h4><p>内涵：</p><p>信念是认知、情感和意识的邮寄统一体，为人们矢志不渝、百折不挠地向往与追求理想目标，提供强大的精神动力。人类特有的精神现象，信念是人们在一定的认识基础上确立的对某种思想或事物坚信不疑并身体力行的精神状态。</p><p>（心有所信，方能远行）</p><p>特征：<strong>执着性、支撑性、多样性。</strong></p><p>*（志之所趋无远勿届穷山距海不能限也志之所向无坚不入锐兵固甲不能御也）</p><h5 id="理想和信念的关系："><a href="#理想和信念的关系：" class="headerlink" title="理想和信念的关系："></a>理想和信念的关系：</h5><ul><li>理想和信念总是相互依存；理想是信念所指的对象，信念是理想实现的保障</li><li>离开理想这个人们确信和追求的目标，信念无从产生，离开信念这种对奋斗目标的执着向往和追求理想寸步难行。</li><li>理想和信念难以分割的紧密联系在一起。</li></ul><h4 id="（！）为什么理想信念是精神之钙？（理想信念的作用）-4"><a href="#（！）为什么理想信念是精神之钙？（理想信念的作用）-4" class="headerlink" title="（！）为什么理想信念是精神之钙？（理想信念的作用） 4"></a>（！）为什么理想信念是精神之钙？（理想信念的作用） <strong>4</strong></h4><p><strong>理想信念是人的精神世界的核心，是人精神上的钙</strong></p><p><strong>理想指引人生方向，信念决定事业成败，理想信念是人生发展的内生动力；</strong></p><p>理想信念昭示<strong>奋斗目标</strong>，理想信念是人的思想和行为的定向器；</p><p>理想信念催生<strong>前进动力</strong>，是人不懈努力最终成就事业的动力源；</p><p>理想信念提供<strong>精神支柱</strong>，筑牢信仰之基，补足精神之钙；</p><p>理想信念提高精神境界，塑造高尚人格；</p><p>大学生只有树立崇高的理想信念，才能激发起为民族复兴和人民幸福而发奋图强的强烈责任感与使命感，掌握建设祖国、服务人民的本领。</p><h5 id="为什么理想信念提高精神境界？！"><a href="#为什么理想信念提高精神境界？！" class="headerlink" title="为什么理想信念提高精神境界？！"></a>为什么理想信念提高精神境界？！</h5><h3 id="（！）为什么要信仰马克思主义-7"><a href="#（！）为什么要信仰马克思主义-7" class="headerlink" title="（！）为什么要信仰马克思主义 7"></a>（！）为什么要信仰马克思主义 <strong>7</strong></h3><ul><li>马克思主义体现了科学性和革命性的统一</li><li>马克思主义具有鲜明的实践品格</li><li>马克思主义具有持久的生命力</li></ul><p>坚定的理想信念，必须建立在对马克思主义的坚定信仰上，建立在历史规律的深刻把握上。</p><p><strong>马克思主义是我们认识世界</strong>，改造世界的强大思想武器；</p><p>马克思主义是<strong>科学</strong>的理论，创造性地揭示了人类社会发展规律；</p><p>马克思主义是<strong>人民</strong>的理论，第一次创立了人民实现自身解放的思想体系；</p><p>马克思主义是<strong>实践</strong>的理论，指引着人们改造世界的行动；</p><p>马克思主义是<strong>不断发展</strong>的开放的理论，始终站在时代前沿；</p><p>马克思主义是党和人民事业不断发展的参天大树之根本，是党和人民不断奋进的万里长河之泉源。</p><h3 id="在实现中国梦的实践中放飞青春梦想"><a href="#在实现中国梦的实践中放飞青春梦想" class="headerlink" title="在实现中国梦的实践中放飞青春梦想"></a>在实现中国梦的实践中放飞青春梦想</h3><p>（57）<strong>（增强对实现中华民族伟大复兴的信心（从近代开始，光荣而艰巨</strong></p><h4 id="（59）理想和现实的辩证关系-3"><a href="#（59）理想和现实的辩证关系-3" class="headerlink" title="（59）理想和现实的辩证关系 3"></a>（59）理想和现实的辩证关系 <strong>3</strong></h4><ul><li><p>理想和现实对立：理想受显示的规定和约束，不能脱离现实而幻想未来；</p></li><li><p>理想和现实统一：理想是在对现实认识的基础上发展起来的。现实是理想的基础，理想是未来的实现。</p></li><li><p>实现理想：长期性、艰巨性、曲折性、艰苦奋斗</p></li></ul><p><strong>（62）</strong>*<strong>坚持个人理想与社会理想有机结合</strong></p><p><strong>个人理想是个体对于自己未来生活的向往和追求，社会理想是指社会全体成员的共同理想。</strong></p><p><strong>个人理想以社会理想为指引。</strong>追求个人理想的实践活动都是在社会中进行的；个人理想的实现，必须以社会理想的实现为前提和基础。</p><p><strong>社会理想是个人理想的汇聚和升华。</strong>摆正个人理想同社会理想的关系，社会理想归根到底要靠全体社会成员的共同努力来实现，并具体体现在每个社会成员为实现个人理想而进行的活生生地实践中。</p><p><strong>“得其大者可以兼其小”个人只有把个人理想融入国家和民族的事业中，才能最终成就一番事业</strong></p><h4 id="（！）为中国梦的实现注入青春能量-3"><a href="#（！）为中国梦的实现注入青春能量-3" class="headerlink" title="（！）为中国梦的实现注入青春能量 3"></a>（！）为中国梦的实现注入青春能量 <strong>3</strong></h4><p><strong>立鸿鹄志，做奋斗者；</strong></p><p><strong>心怀“国之大者”，敢于担当；</strong></p><p><strong>自觉躬身实践，知行合一。</strong></p><h5 id="（66-1、3）"><a href="#（66-1、3）" class="headerlink" title="（66-1、3）"></a>（66-1、3）</h5><h2 id="继承优良传统-弘扬中国精神"><a href="#继承优良传统-弘扬中国精神" class="headerlink" title="继承优良传统 弘扬中国精神"></a>继承优良传统 弘扬中国精神</h2><p><strong>以爱国主义为核心的民族精神和以改革创新为核心的时代精神</strong></p><h3 id="（73）实现中国梦必须弘扬中国精神"><a href="#（73）实现中国梦必须弘扬中国精神" class="headerlink" title="（73）实现中国梦必须弘扬中国精神"></a>（73）实现中国梦必须弘扬中国精神</h3><p><strong>中国精神是兴国强国之魂</strong>（and以下三个）</p><h4 id="凝聚民族复兴的磅礴伟力-3"><a href="#凝聚民族复兴的磅礴伟力-3" class="headerlink" title="凝聚民族复兴的磅礴伟力 3"></a>凝聚民族复兴的磅礴伟力 <strong>3</strong></h4><p>凝聚中国力量的精神纽带；激发创新创造的精神动力；推进复兴伟业的精神支柱。</p><h4 id="弘扬以爱国主义为核心的民族精神-3"><a href="#弘扬以爱国主义为核心的民族精神-3" class="headerlink" title="弘扬以爱国主义为核心的民族精神 3"></a>弘扬以爱国主义为核心的民族精神 <strong>3</strong></h4><p>民族精神：伟大创造精神；伟大奋斗精神；伟大团结精神；伟大梦想精神</p><p>爱祖国的大好河山；爱自己的骨肉同胞；爱祖国的灿烂文化；爱自己的国家</p><h4 id="弘扬以改革创新为核心的时代精神-6"><a href="#弘扬以改革创新为核心的时代精神-6" class="headerlink" title="弘扬以改革创新为核心的时代精神 6"></a>弘扬以改革创新为核心的时代精神 <strong>6</strong></h4><p>时代精神：改革创新精神</p><p>体现为突破陈规、大胆探索、敢于创造的思想观念</p><p>体现为不甘落后奋勇整下追求进步的责任感和使命感</p><p>体现为坚韧不拔、自强不息、锐意进取的精神状态</p><h3 id="（77）做新时代的忠诚爱国者-4"><a href="#（77）做新时代的忠诚爱国者-4" class="headerlink" title="（77）做新时代的忠诚爱国者 4"></a>（77）做新时代的忠诚爱国者 <strong>4</strong></h3><ul><li>坚持三爱统一；维护祖国统一和民族团结；尊重和传承中华民族历史和文化；坚持立足民族又面向世界</li></ul><p>（爱国爱党爱社会主义）</p><ul><li>爱祖国的大好河山、爱自己的骨肉同胞、爱祖国的灿烂文化、爱自己的国家</li></ul><h5 id="（95）"><a href="#（95）" class="headerlink" title="（95）"></a>（95）</h5><h5 id="（99-2、3）"><a href="#（99-2、3）" class="headerlink" title="（99-2、3）"></a>（99-2、3）</h5><h3 id="இ让改革创新成为青春远航的动力"><a href="#இ让改革创新成为青春远航的动力" class="headerlink" title="இ让改革创新成为青春远航的动力"></a>இ让改革创新成为青春远航的动力</h3><h4 id="改革开放是当代中国的显著特征-3"><a href="#改革开放是当代中国的显著特征-3" class="headerlink" title="改革开放是当代中国的显著特征 3"></a>改革开放是当代中国的显著特征 <strong>3</strong></h4><h4 id="改革创新是新时代的迫切要求-3"><a href="#改革创新是新时代的迫切要求-3" class="headerlink" title="改革创新是新时代的迫切要求 3"></a>改革创新是新时代的迫切要求 <strong>3</strong></h4><h4 id="做改革创新生力军："><a href="#做改革创新生力军：" class="headerlink" title="做改革创新生力军："></a>做改革创新生力军：</h4><h5 id="树立改革创新的自觉意识-3"><a href="#树立改革创新的自觉意识-3" class="headerlink" title="树立改革创新的自觉意识 3"></a>树立改革创新的自觉意识 <strong>3</strong></h5><ul><li>增强改革创新的责任感</li><li>梳理敢于突破陈规的意识</li><li>树立大胆探索未知领域的信心</li></ul><h5 id="增强改革创新的能力本领-3"><a href="#增强改革创新的能力本领-3" class="headerlink" title="增强改革创新的能力本领 3"></a>增强改革创新的能力本领 <strong>3</strong></h5><ul><li>夯实创新基础</li><li>培养创新思维</li><li>投身改革创新实践</li></ul><h2 id="明确价值要求-践行价值准则"><a href="#明确价值要求-践行价值准则" class="headerlink" title="明确价值要求 践行价值准则"></a>明确价值要求 践行价值准则</h2><h3 id="（115）社会主义核心价值观"><a href="#（115）社会主义核心价值观" class="headerlink" title="（115）社会主义核心价值观"></a>（115）社会主义核心价值观</h3><p>富强民主文明和谐</p><p>自由平等公正法治</p><p>爱国敬业诚信友善</p><h4 id="显著特征-10"><a href="#显著特征-10" class="headerlink" title="显著特征 10"></a>显著特征 <strong>10</strong></h4><p>人类社会发展进步；人民至上；可信真实；</p><h4 id="（125）如何培育和践行"><a href="#（125）如何培育和践行" class="headerlink" title="（125）如何培育和践行"></a>（125）如何培育和践行</h4><h5 id="扣好人生的扣子-3"><a href="#扣好人生的扣子-3" class="headerlink" title="扣好人生的扣子 3"></a>扣好人生的扣子 <strong>3</strong></h5><h5 id="把社会主义核心价值观落细落小落实-4"><a href="#把社会主义核心价值观落细落小落实-4" class="headerlink" title="把社会主义核心价值观落细落小落实 4"></a>把社会主义核心价值观落细落小落实 <strong>4</strong></h5><p>社会主义核心价值观是当代中国精神的集中体现，凝结着全体人民共同的价值追求；</p><p>xx是弘扬核心价值观的形式；发挥了社会主义核心价值观的强大凝聚力、向心力的作用</p><p>进一步增进社会团结和谐的最大公约数</p><p>勤学、修德、明辨、笃实</p><h5 id="（130-2、3）"><a href="#（130-2、3）" class="headerlink" title="（130-2、3）"></a>（130-2、3）</h5><h2 id="遵守道德规范-锤炼道德品格"><a href="#遵守道德规范-锤炼道德品格" class="headerlink" title="遵守道德规范 锤炼道德品格"></a>遵守道德规范 锤炼道德品格</h2><p>经济基础决定上层建筑</p><h3 id="社会主义道德的核心和原则"><a href="#社会主义道德的核心和原则" class="headerlink" title="社会主义道德的核心和原则"></a>社会主义道德的核心和原则</h3><h4 id="（131）坚持马克思主义道德观（冲突-gt-服从）"><a href="#（131）坚持马克思主义道德观（冲突-gt-服从）" class="headerlink" title="（131）坚持马克思主义道德观（冲突-&gt;服从）"></a>（131）坚持马克思主义道德观（冲突-&gt;服从）</h4><h5 id="道德的起源和本质-3"><a href="#道德的起源和本质-3" class="headerlink" title="道德的起源和本质 3"></a>道德的起源和本质 <strong>3</strong></h5><p><strong>起源</strong>：马克思主义认为，道德作为一种社会现象，其产生有多方面的条件，经理了一个漫长的历史过程。</p><p><strong>本质：</strong>一种特殊的社会意识形式，归根到底是由经济基础据欸的那个的，是社会经济关系的反映。</p><p><strong>本质：知行合一的</strong></p><h5 id="道德的内涵-3"><a href="#道德的内涵-3" class="headerlink" title="道德的内涵 3"></a>道德的内涵 <strong>3</strong></h5><h5 id="道德的认识功能-10"><a href="#道德的认识功能-10" class="headerlink" title="道德的认识功能 10"></a>道德的认识功能 <strong>10</strong></h5><ul><li><p>道德的认知功能是指反映社会经济关系，特别是反映社会经济关系的功效和能力。</p></li><li><p>道德的规范功能是指在正确善恶观指引下，规范社会成员在社会公共领域、职业领域、社会领域的行为，并规范个人品德的养成，引导并促进人们崇德向善。从道德的特征来说，道德和法律一样，都是通过规范人的行为发挥作用。</p></li><li><p>道德的调节功能是指道德通过评价等方式，指导和纠正人们的行为和实践活动，协调社会关系和人际关系的功效与能力。道德评价是道德调节的主要形式，社会舆论，传统习俗和人们的内心信念是道德调节赖以发挥作用的力量。</p></li></ul><p>功能、认识、规范、调节|激励、导向、教育。</p><h4 id="（139）坚持以人民为中心-——为人民服务"><a href="#（139）坚持以人民为中心-——为人民服务" class="headerlink" title="（139）坚持以人民为中心 ——为人民服务"></a>（139）坚持以人民为中心 ——为人民服务</h4><p>（社会主义道德的核心） <strong>4</strong></p><p>经济基础和人际关系的客观要求，市场健康的要求；先进性和广泛性的统一</p><h4 id="（141）坚持集体主义为原则"><a href="#（141）坚持集体主义为原则" class="headerlink" title="（141）坚持集体主义为原则"></a>（141）坚持集体主义为原则</h4><h5 id="集体主义是调节社会利益关系的基本原则-3"><a href="#集体主义是调节社会利益关系的基本原则-3" class="headerlink" title="集体主义是调节社会利益关系的基本原则 3"></a>集体主义是调节社会利益关系的基本原则 <strong>3</strong></h5><p>集体主义强调国家利益、社会整体利益和个人利益的辩证统一</p><p>强调国家、社会高于个人</p><p>重视和保障个人的正当利益</p><h5 id="层次性"><a href="#层次性" class="headerlink" title="层次性"></a>层次性</h5><h6 id="三个层次的道德要求-3"><a href="#三个层次的道德要求-3" class="headerlink" title="三个层次的道德要求 3"></a>三个层次的道德要求 <strong>3</strong></h6><h6 id="我们需要反对-3"><a href="#我们需要反对-3" class="headerlink" title="我们需要反对 3"></a>我们需要反对 <strong>3</strong></h6><h3 id="传承中华美德"><a href="#传承中华美德" class="headerlink" title="传承中华美德"></a>传承中华美德</h3><p>是人类文明发展的重要精神财富，是社会主义道德建设的源头、活水</p><h4 id="中华传统美德的基本精神-5"><a href="#中华传统美德的基本精神-5" class="headerlink" title="中华传统美德的基本精神 5"></a>中华传统美德的基本精神 <strong>5</strong></h4><ul><li>重视整体利益，强调责任奉献（公义胜私欲）（苟利国家生死以，岂因祸福避趋之）</li><li>推崇仁爱原则，注重以和为贵（己欲利而利人</li><li>注重人伦关系，重视道德义务（仁义礼智信</li><li>追求精神境界，向往理想人格（先天下之乐而乐</li><li>强调道德修养，注重道德践履（见贤思齐焉，见不贤而内省焉）</li></ul><h4 id="创造性转化和创造性发展-3"><a href="#创造性转化和创造性发展-3" class="headerlink" title="创造性转化和创造性发展 3"></a>创造性转化和创造性发展 <strong>3</strong></h4><h4 id="反对错误思潮-2"><a href="#反对错误思潮-2" class="headerlink" title="反对错误思潮 2"></a>反对错误思潮 <strong>2</strong></h4><h3 id="（！）遵守社会公德"><a href="#（！）遵守社会公德" class="headerlink" title="（！）遵守社会公德"></a>（！）遵守社会公德</h3><p>公共生活，网络生活（各种公德的地位</p><ul><li>正确使用网络工具</li><li>加强网络文明自律</li><li>营造良好网络道德环境</li></ul><h4 id="公共生活中的道德规范"><a href="#公共生活中的道德规范" class="headerlink" title="公共生活中的道德规范"></a>公共生活中的道德规范</h4><h4 id="社会主义道德的核心和原则-1"><a href="#社会主义道德的核心和原则-1" class="headerlink" title="社会主义道德的核心和原则"></a>社会主义道德的核心和原则</h4><ul><li>核心：为人民服务</li><li>原则：集体主义</li></ul><p>集体主义强调国家利益、社会整体利益和个人利益的辩证统一</p><p>集体主义强调国家历来以、社会整体利益高于个人利益</p><p>集体主义重视和保障个人的正当利益</p><h4 id="主要内容-5"><a href="#主要内容-5" class="headerlink" title="主要内容 5"></a>主要内容 <strong>5</strong></h4><h4 id="大学生应该-5"><a href="#大学生应该-5" class="headerlink" title="大学生应该 5"></a>大学生应该 <strong>5</strong></h4><p>（掌握道德修养的正确方法：</p><ul><li>学思并重</li><li>省察克治</li><li>慎独自律</li><li>知行合一</li><li>积善成德）</li></ul><h4 id="网络生活中的道德-6"><a href="#网络生活中的道德-6" class="headerlink" title="网络生活中的道德 6"></a>网络生活中的道德 <strong>6</strong></h4><ul><li>正确使用网络工具</li><li>健康进行网络交往</li><li>自觉避免沉迷网络</li><li>加强网络道德自律</li><li>积极引导网络舆论</li></ul><h2 id="（180）学习法治思想-提升法治素养（习法思：11个坚持）"><a href="#（180）学习法治思想-提升法治素养（习法思：11个坚持）" class="headerlink" title="（180）学习法治思想 提升法治素养（习法思：11个坚持）"></a>（180）学习法治思想 提升法治素养（习法思：11个坚持）</h2><h3 id="（！）法律及其历史发展"><a href="#（！）法律及其历史发展" class="headerlink" title="（！）法律及其历史发展"></a>（！）法律及其历史发展</h3><p>法律含义：由国家制定或认可，并由国家强制力保证实施的，反映由特定社会物质生活条件所决定的统治阶级意志的规范体系</p><ul><li>法律是由国家创制和试试的行为规范</li><li>法律由一定的社会物质生活条件所决定</li><li>法律是统治阶级一直的体现</li></ul><h3 id="（196）坚持法律面前人人平等（3）"><a href="#（196）坚持法律面前人人平等（3）" class="headerlink" title="（196）坚持法律面前人人平等（3）"></a>（196）坚持法律面前人人平等（3）</h3><h4 id="我国社会主义法律是党的主张和人民意志的共同体现"><a href="#我国社会主义法律是党的主张和人民意志的共同体现" class="headerlink" title="我国社会主义法律是党的主张和人民意志的共同体现"></a>我国社会主义法律是党的主张和人民意志的共同体现</h4><h4 id="是维护人民利-益和公民权利的有力武器"><a href="#是维护人民利-益和公民权利的有力武器" class="headerlink" title="是维护人民利 益和公民权利的有力武器"></a>是维护人民利 益和公民权利的有力武器</h4><h4 id="是国家机关、社会组织和全体公民的活动规则和行为准绳"><a href="#是国家机关、社会组织和全体公民的活动规则和行为准绳" class="headerlink" title="是国家机关、社会组织和全体公民的活动规则和行为准绳"></a>是国家机关、社会组织和全体公民的活动规则和行为准绳</h4><h4 id="法律的含义-3"><a href="#法律的含义-3" class="headerlink" title="法律的含义 3"></a>法律的含义 <strong>3</strong></h4><h4 id="法律的历史发展-4"><a href="#法律的历史发展-4" class="headerlink" title="法律的历史发展 4"></a>法律的历史发展 <strong>4</strong></h4><h3 id="坚持走中国特色社会主义法治道路"><a href="#坚持走中国特色社会主义法治道路" class="headerlink" title="坚持走中国特色社会主义法治道路"></a>坚持走中国特色社会主义法治道路</h3><ul><li>坚持中国共产党的领导</li><li>坚持人民主体地位</li><li>坚持法律面前人人平等</li><li>坚持依法治国和以德治国相结合</li></ul><p>两个坚持一个贯彻：</p><ul><li>坚持中国特色社会主义道路</li><li>坚持中国特色社会主义理论体系</li><li>贯彻党的基本路线</li></ul><p>实质是在坚持中国特色社会主义的道路、理论和制度基础上，贯彻党的基本路线，不断推进中国特色社会主义事业</p><p>内涵：在中国共产党的领导下，坚持和发展中国特色社会主义，实现中华民族伟大复兴、必须树立中国特色社会主义共同理想。</p><p>地位：（十八大）中国特色社会主义是改革开发以来党的全部理论和实践的主题，是党和人民历尽千辛万苦，付出巨大代价取得的根本成就。</p><h4 id="为什么要走中国特色社会主义道路-4"><a href="#为什么要走中国特色社会主义道路-4" class="headerlink" title="为什么要走中国特色社会主义道路 4"></a>为什么要走中国特色社会主义道路 <strong>4</strong></h4><ul><li>历史的必然结论</li><li>国家性质决定的</li><li>基本国情的必然选择</li></ul><h4 id="（192）坚持中国特色社会主义法治道路必须遵循的原则"><a href="#（192）坚持中国特色社会主义法治道路必须遵循的原则" class="headerlink" title="（192）坚持中国特色社会主义法治道路必须遵循的原则"></a>（192）坚持中国特色社会主义法治道路必须遵循的原则</h4><p>（中国特色社会主义法治道路特在哪里？） <strong>5</strong></p><ul><li>完备的法律规范体系</li><li>高效的法治实施体系</li><li>严密的法治监督体系</li><li>有力的法治保障</li><li>完善的党内法规体系</li></ul><h3 id="建设法治中国-4"><a href="#建设法治中国-4" class="headerlink" title="建设法治中国 4"></a>建设法治中国 <strong>4</strong></h3><h3 id="இ我国宪法的地位和基本原则"><a href="#இ我国宪法的地位和基本原则" class="headerlink" title="இ我国宪法的地位和基本原则"></a>இ我国宪法的地位和基本原则</h3><p>党的主张和人民已知的高度统一</p><p>司法机关：</p><ul><li><p>人民法院：审判</p></li><li><p>人民检察院：法监</p></li></ul><h4 id="我国宪法的地位-5"><a href="#我国宪法的地位-5" class="headerlink" title="我国宪法的地位 5"></a>我国宪法的地位 <strong>5</strong></h4><ul><li>根本法，是党和人民意志的集中体现</li><li>国家各项制度和法律法规的总依据</li><li>规定了国家的根本制度（社会主义制度）</li><li>实现了国家认同，凝聚社会共识，促进个人发展的基本准则</li></ul><h4 id="我国宪法的基本原则-13"><a href="#我国宪法的基本原则-13" class="headerlink" title="我国宪法的基本原则 13"></a>我国宪法的基本原则 <strong>13</strong></h4><ul><li>党的领导</li><li>人民当家作主</li><li>尊重和保障人权</li><li>社会主义法治</li><li>民主集中制</li></ul><h3 id="法治思维"><a href="#法治思维" class="headerlink" title="法治思维"></a>法治思维</h3><h4 id="法治思维的含义-8"><a href="#法治思维的含义-8" class="headerlink" title="法治思维的含义 8"></a>法治思维的含义 <strong>8</strong></h4><p>法律至上，权力制约，公平正义，权力保障，程序正当</p><h4 id="法治思维的基本内容-24"><a href="#法治思维的基本内容-24" class="headerlink" title="法治思维的基本内容 24"></a>法治思维的基本内容 <strong>24</strong></h4><p><img src="file:///C:\Users\17687\AppData\Local\Temp\ksohtml32508\wps4.png" alt="img"> 含义：法治思维是指以法治价值和法治精神为导向，运用法律原则，法律规则，法律方法思考和处理问题的思维模式。即依法办事。</p><p><img src="file:///C:\Users\17687\AppData\Local\Temp\ksohtml32508\wps5.png" alt="img"> 培养法治思维，必须抛弃人治思维。法治思维与人治思维的分水岭不在于有没有法律或者法律的多寡与好坏，而在于最高的权威究竟是法律还是个人。</p><p><img src="file:///C:\Users\17687\AppData\Local\Temp\ksohtml32508\wps6.png" alt="img"> 法治思维的基本内容：法律至上，权力制约，公平正义，权利保障，正当程序。</p><ul><li>法治是实现国家治理现代化的重要手段，良好的法治有助于维护国家的政治制度经济制度和社会秩序</li><li>法制建设以保障人民根本权益为出发点和落脚点</li><li>党与法：<ul><li>党的领导是中国特色社会主义最本质的特征，是社会主义法治最根本的保证</li><li>坚持党的领导是社会主义法治的根本要求，是党和国家的根本所在，命脉所在</li><li>党的领导与社会法治是一致的</li></ul></li></ul><h5 id="培养法治思维："><a href="#培养法治思维：" class="headerlink" title="培养法治思维："></a>培养法治思维：</h5><ul><li><p>学习法律知识</p></li><li><p>掌握法律方法</p></li><li><p>参与法律实践</p></li><li><p>养成守法实践</p></li><li><p>养成守法习惯</p></li><li><p>守住法律底线</p></li></ul><h3 id="法律权利与法律义务的关系"><a href="#法律权利与法律义务的关系" class="headerlink" title="法律权利与法律义务的关系"></a>法律权利与法律义务的关系</h3><ul><li><p>在社会生活中，每个人既是享受法律权利的主体，又是承担法律义务的主体。<strong>在法治国家中</strong>，不存在只享受权利的主体，也不存在只承担义务的主体。</p></li><li><p>法律权利和法律义务是相互依存的关系，法律权利的实现必须以相应法律义务的履行为条件，法律义务的设定和履行也必须以法律权利的行使为依据，不存在没有权利依据的法律义务。</p></li><li><p>法律权利和法律义务是目的与手段的关系。</p></li><li><p>有些法律权利和法律义务具有复合性的关系。</p></li><li><p>法律权利与法律义务平等，是现代法治的基本原则。</p></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><h4 id="（193-2、3）"><a href="#（193-2、3）" class="headerlink" title="（193-2、3）"></a>（193-2、3）</h4><h4 id="（194-2）坚持中共领导（1）"><a href="#（194-2）坚持中共领导（1）" class="headerlink" title="（194-2）坚持中共领导（1）"></a>（194-2）坚持中共领导（1）</h4><h4 id="（195-1）坚持人民主体地位"><a href="#（195-1）坚持人民主体地位" class="headerlink" title="（195-1）坚持人民主体地位"></a>（195-1）坚持人民主体地位</h4><h4 id="（197）依法治国、以德治国相结合"><a href="#（197）依法治国、以德治国相结合" class="headerlink" title="（197）依法治国、以德治国相结合"></a>（197）依法治国、以德治国相结合</h4><ul><li><p>正确认识法治和德治的地位。法治是治国理政的基本方式，德治是治国理政的重要方式。</p></li><li><p>正确认识法治和德治的作用。</p></li><li><p>正确认识法治和德治的实现途径。</p></li><li><p>推动法治和德治相互促进。</p></li></ul><p><img src="file:///C:\Users\17687\AppData\Local\Temp\ksohtml32508\wps2.png" alt="img"> 只有德治和法治共同发挥作用，才能让法律与道德相辅相成，法治与德治相得益彰，做到法安天下，德润人心。</p><h5 id="全面依法治国的基本格局："><a href="#全面依法治国的基本格局：" class="headerlink" title="全面依法治国的基本格局："></a>全面依法治国的基本格局：</h5><p>科学立法，公正司法，全民守法</p><h3 id="我国的根本制度-1"><a href="#我国的根本制度-1" class="headerlink" title="我国的根本制度 1"></a>我国的根本制度 <strong>1</strong></h3><p>我国的根本制度是社会主义制度。这是由中国共产党领导的人民代表大会制度、中国特色的社会主义市场经济体制、基本的社会保障制度、社会主义民主法治制度、社会主义意识形态等方面构成的一套制度体系</p><h3 id="我国的制度（我国的政体和国体）-2"><a href="#我国的制度（我国的政体和国体）-2" class="headerlink" title="我国的制度（我国的政体和国体） 2"></a>我国的制度（我国的政体和国体） <strong>2</strong></h3><p>社会主义政体和人民民主专政的国体。</p><p>国体决定政体，政体体现国体。</p><p>社会主义政体是指中国共产党领导下的人民民主制度，即人民代表大会制度。</p><p>人民民主专政的国体是指无产阶级领导的、以公共联盟为基础的人民民主专政，以保障人民群体的根本利益饿全体人民的共同利益。</p><h3 id="我国的政治制度-12"><a href="#我国的政治制度-12" class="headerlink" title="我国的政治制度 12"></a>我国的政治制度 <strong>12</strong></h3><p>包括：人民代表大会制度、多党合作和政治协商制度、民族区域自治制度、基层群众自治制度。</p><p>（第一种是中国特色社会主义最基本的政治制度。）</p><p>中国的政治制度具有独特的中国特色，包括：中国共产党的领导、人民代表大会制度、多党合作和政治协商制度、民族区域自治制度、基层群众自治制度、依法治国、公正司法、反腐倡廉等。</p><h3 id="我国的经济制度"><a href="#我国的经济制度" class="headerlink" title="我国的经济制度"></a>我国的经济制度</h3><p>基础：社会主义公有制。全民所有制和劳动群众集体所有制是我国社会主义公有制的两中基本形式。</p><p>国家在社会主义初级阶段，坚持公有制为主体，多种所有制经济共同发展的基本经济制度，坚持按劳分配为主体，多种分配方式并存的分配制度。</p><h3 id="中国特色社会主义最本质的特征-1"><a href="#中国特色社会主义最本质的特征-1" class="headerlink" title="中国特色社会主义最本质的特征 1"></a>中国特色社会主义最本质的特征 <strong>1</strong></h3><p>中国特色社会主义最本质的特征是以中国特色社会主义理论体系为指导，全面推进经济、政治、文化、社会、生态文明等方面的发展，坚持走中国特色社会主义道路。</p><h3 id="人民民主专政的本质-1"><a href="#人民民主专政的本质-1" class="headerlink" title="人民民主专政的本质 1"></a>人民民主专政的本质 <strong>1</strong></h3><p>人民民主专政的本质是工人阶级领导的、以工农联盟为基础的人民民主专政，是在保障人民群众的根本利益和全体人民的共同利益的基础上，通过各种形式的民主参与，实现人民对国家政治、经济、文化等方面的管理和管理者的监督。这种专政形式是一种阶级斗争的工具，是保证社会主义事业顺利发展和巩固社会主义政权的基础。</p><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p>二、论述分析<br>1、当代大学生的历史使命和成才目标是什么？　<br>答：人类历史表明，不同时代的青年有着不同的经历，承担着不同的历史使命。(1) 大学生在历史的起点上继往开来的历史使命。(2) 大学生与时俱进、开拓创新的历史使命。（3）大学生做文明表率的历史使命。成才目标：成为德智体美全面发展的社会主义事业的建设者和接班人，是历史发展对大学生的必然要求，是党和人民的殷切期望，也是大学生需要确立的成才目标。德是人才素质的灵魂 智是人才素质的基础　体是人才素质的条件 美是人才素质的重要内.</p><p>第一章 追求远大理想 坚定崇高信念<br>一、单项选择<br>1、“哲学家们只是用不同的方式解释世界，而问题在于改变世界。”说明（D）（重点）<br>A社会主义由空想变成科学 B社会主义的建立，深刻改变着人类历史的走向<br>C社会主义具有光明的未来 D表明了马克思主义重视实践、以改造世界为己任的基本特征<br>2、现阶段我国各族人民的共同理想是 （B）（重点）<br>A祖国统一       B建设和发展中国特色社会主义、实现中华民族伟大复兴<br>C改革开放       D改革创新<br>3、当代大学生的历史使命是（C）（重点）<br>A掌握马克思主义理论              B认真学习科学文化知识<br>C建设中国特色社会主义、实现中华民族伟大复兴  D实现自我价值<br>4、实现理想的思想基础是（B）（重点）<br>A掌握马克思主义理论          B正确认识理想与现实的关系<br>C坚定的信念              D勇于实践、艰苦奋斗<br>5、实现理想的根本途径是（D）<br>A掌握马克思主义理论          B正确认识理想与现实的关系<br>C坚定的信念              D勇于实践、艰苦奋斗<br>5、社会主义意识形态的本质体现，社会主义意识形态的核心内容和最重要的组成部分，国家文化软实力的核心内容，引领当代大学生成长成才的根本指针是（A）（重点）<br>A社会主义核心价值体系   B民族主义   C世界主义  D时代精神<br>6、当今世界时代主题仍然是（D）<br>A战争     B局部战争     C冲突    D和平与发展<br>7、人生的最高境界是（B）<br>A为革命而献身   B为理想而献身  C为祖国而献身  D为国家而献身<br>二、多项选择<br>1、确立马克思主义的科学信仰依据是 （ABC）（重点）<br>A马克思主义是科学的又是崇高的。   B马克思主义具有持久的生命力。<br>C马克思主义以改造世界为己任。    D马克思主义是方法论<br>2、马克思主义的基本原理同中国革命、建设和改革的具体实践相结合的三大理论成果有哪些？（ABD）（重点）<br>A毛泽东思想 B邓小平理论   C科学发展观  D“三个代表”重要思想<br>3、树立中国特色社会主义的共同理想应该：（BCD）（重点）<br>A坚定改革开放政策        B坚定对中国共产党的信任<br>C坚定走中国特色社会主义道路的信念 D坚定实现中华民族伟大复兴的信心<br>4、当代大学生怎样完成自己的历史使命？（CD）（重点）<br>A掌握本领  B掌握科学知识 C在新的起点上继往开来  D在现实的基础上迎接挑战<br>5、当代大学生在现实的基础上迎接哪些挑战（ABC）（重点）<br>A面临世界科技文化发展的挑战      B面临复杂多变的国际环境的挑战<br>C面临新世纪新阶段我国发展任务的挑战  D面临自我挑战。<br>6、如何实现理想信念？（ABC）（重点）<br>A立志高远与始于足下  B充分认识实现理想的长期性、艰巨性和曲折性。<br>C在实践中化理想为现实  D掌握本领，掌握科学知识。<br>7、立志高远与始于足下应做到（ABC）（重点）<br>A立志当高远  B立志做大事  C立志须躬行  D立志要坚定<br>8、在实践中化理想为现实应认识到：（ABC）（重点）<br>A正确认识理想与现实的关系是实现理想的思想基础 B坚定的信念是实现理想的重要条件<br>C勇于实践、艰苦奋斗是实现理想的根本途径    D坚定意志是实现理想的力量源泉<br>三、论述分析<br>1、学习和践行社会主义核心价值体系的重大意义。<br>答案要点：（1）建设社会主义核心价值体系，是我们党在思想文化建设上的一个重大理论创新，也是我们党深刻总结历史经验、科学分析当前形势提出的一项重大任务。（2）社会主义核心价值体系是社会主义意识形态的本质体现，它涉及经济、政治、文化、思想等社会生活的方方面面，集社会主义价值理念之大成，把我们党倡导的基本理论、思想观念和价值取向系统凝练地整合在一起，是社会主义意识形态的核心内容和最重要的组成部分，决定着社会主义意识形态的性质和方向。（3）社会主义核心价值体系也是引领当代大学生成长成才的根本指针。<br>2、分析题：“哲学家们只是用不同的方式解释世界，而问题在于改变世界。” （重点）<br>答案：（1）马克思主义以改造世界为己任。马克思主义是认识世界、改造世界的科学理论。<br>（2）在伦敦海格特公墓的马克思墓碑上，镌刻着马克思的一句名言：“哲学家们只是用不同的方式解释世界，而问题在于改变世界。”这鲜明地表明了马克思主义重视实践、以改造世界为己任的基本特征。<br>（3）一个半世纪以来，正是在马克思主义的指导下，社会主义由空想变成科学，由科学理论转变为社会实践，社会主义国家的出现和社会主义制度的建立，深刻改变着人类历史的走向。<br>（4）虽然苏东剧变使世界社会主义运动遭受了严重挫折，但是历史发展的总趋势并没有改变。特别是中国共产党人在马克思主义的指导下所探索的中国特色社会主义道路的成功实践，用无可辩驳的事实证明，社会主义具有光明的未来。同时也证明，马克思主义仍然是认识世界和改造世界的强大思想武器。<br>（5）当代大学生学习马克思主义理论，确立马克思主义的科学信仰，最重要的是学习和掌握马克思主义的世界观和方法论，把个人的成长成才与国家的富强繁荣、乃至与全人类的解放紧密联系起来，报效祖国，奉献社会，创造有价值的人生。<br>3．为什么确立马克思主义的科学信仰？ （重点） (1)马克思主义是科学的又是崇高的。 (2)马克思主义具有持久的生命力。<br>(3)马克思主义以改造世界为己任。<br>4、如何树立中国特色社会主义的共同理想?<br>答案要点：建设和发展中国特色社会主义、实现中华民族伟大复兴，是现阶段我国各族人民的共同理想。这个共同理想集中体现了我国工人、农民、知识分子和其他劳动者、爱国者的利益和愿望，是保证全体人民团结奋斗、克服困难、争取胜利的强大精神武器。(1)坚定对中国共产党的信任。中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队，是中国特色社会主义事业的领导核心。(2)坚定走中国特色社会主义道路的信念。(3)坚定实现中华民族伟大复兴的信心。<br>5、如何在实践中化理想为现实？<br>答案要点：(1)正确认识理想与现实的关系是实现理想的思想基础(2)坚定的信念是实现理想的重要条件(3)勇于实践、艰苦奋斗是实现理想的根本途径<br>第二章  继承爱国传统 弘扬民族精神<br>一、单项选择<br>1、中华民族精神的核心是（B）（重点）<br>A马克思主义  B爱国主义  C集体主义  D个人主义<br>2、一个民族赖以生存和发展的精神支柱。（B）（重点）<br>A爱国主义  B民族精神  C集体主义  D个人主义<br>3、时代精神的核心是（D）（重点）<br>A爱国主义   B民族精神  C集体主义  D改革创新<br>二、多项选择<br>4．爱国主义的时代价值有哪些？(ABCD) （重点）<br>A爱国主义是中华民族继往开来的精神支柱 B爱国主义是维护祖国统一和民族团结的纽带<br>C爱国主义是实现中华民族伟大复兴的动力 D爱国主义是个人实现人生价值的力量源泉<br>5、新时期的爱国主义的主要表现在哪几个方面？(ABCD) （重点）<br>A爱国主义与爱社会主义和拥护祖国统一的一致性B在经济全球化的背景下坚持爱国主义<br>C爱国主义与弘扬民族精神相统一        D爱国主义与弘扬时代精神相统一<br>6、对于当代大学生来说，如何把握经济全球化趋势与爱国主义的相互关系？（ABC）（重点）<br>A人有地域和信仰的不同，但报效祖国之心不应有差别B科学没有国界，但科学家有祖国<br>C经济全球化过程中要始终维护国家的主权和尊严  D经济全球化过程中要坚持世界主义<br>7、所谓民族精神，是指—个民族在长期共同生活和社会实践中形成的，为本民族大多数成员所认同的（）总和。(ABCD)<br>A价值取向  B思维方式  C道德规范  D精神气质<br>8、下隶属于民族精神的是(ABCDE) （重点）<br>A爱国主义 B团结统一  C勤劳勇敢  D自强不息  E爱好和平<br>9、时代精神的内涵(ABCD) （重点）<br>A改革创新是时代精神的核心   B改革创新是进一步解放和发展生产力的必然要求<br>C改革创新是建设社会主义创新型国家的迫切需要。<br>D改革创新是落实科学发展观、构建社会主义和谐社会的重要条件。<br>10、改革创新，包括(ABCD) （重点）<br>A理论创新  B制度创新  C科技创新  D文化创新以及其他方面的创新。</p><p>三、论述分析<br>2、如何理解爱国主义与爱社会主义的一致性？（重点）<br>在当代中国，爱国主义首先体现在对社会主义中国的热爱上，这是中华人民共和国每一个公民必须坚持的立场和态度。<br>（1）爱国主义与爱社会主义的统一是中国历史发展的必然结果。社会主义制度的建立，为祖国的繁荣发展提供了可靠的保障。社会主义制度集中代表着、体现着、实现着国家、民族和人民的根本利益。<br>（2）我国社会主义建设所取得的伟大成就有目共睹。特别是进人改革开放新时期以来，社会主义中国的面貌发生了历史性变化。中国的发展，不仅使中国人民稳步地走上了争取实现全面小康的广阔道路，而且为世界经济发展和人类文明进步作出了重大贡献。中国的历史和现实充分证明，只有社会主义才能救中国，只有改革开放才能发展中国、发展社会主义。<br>（3）社会主义是中国共产党领导广大人民群众经过流血牺牲，长期艰苦奋斗建立起来的。“没有共产党就没有新中国”，这同样是中国的历史和现实所昭示的真理。中国的历史和现实充分证明，中国共产党是高举爱国主义旗帜并躬身实践的光辉典范，是中国特色社会主义事业的坚强领导核心。爱国主义与爱社会主义、爱中国共产党、爱人民政府，具有深刻的内在一致性。<br>4、为什么在经济全球化背景下还要弘扬爱国主义？（重点）<br>(1)经济全球化是当今时代发展的重要趋势。它的发展使世界各国在经济上的联系日益紧密，同时影响到世界各国的政治和文化，对爱国主义也提出了挑战。正确认识当今时代的爱国主义，必须联系并把握经济全球化的发展趋势及其影响。<br>(2)经济全球化形势下要弘扬爱国主义<br>在经济全球化的条件下，国家仍然是民族存在的最高组织形式，是国际社会活动中的独立主体。只要国家继续存在，爱国主义就有其坚实的基础和丰富的意义。我们在参与经济全球化的过程中，必须坚定地捍卫自己国家的利益，这就更需要爱国主义的支撑。经济全球化是一把双刃剑，既是机遇，更是挑战。现实情况表明，经济全球化背景下，发展中国家不仅要面对经济方面的挑战，而且也必然要面对政治和文化上的挑战。西方发达国家利用经济、科技和军事等方面的优势，竭力输出它们的政治观、价值观、文化观和生活方式，力图主导经济全球化进程，把发展中国家纳入西方的发展模式和发展轨道。在这种情况下，更需要大力弘扬爱国主义，维护本国、本民族的利益。<br>(3)经济全球化与当代大学生的爱国主义<br>对于当代大学生来说，在如何把握经济全球化趋势与爱国主义的相互关系的问题上，需要着重树立这样一些观念。第一，人有地域和信仰的不同，但报效祖国之心不应有差别。第二，科学没有国界，但科学家有祖国。第三，经济全球化过程中要始终维护国家的主权和尊严。<br>5、如何理解大力弘扬和培育民族精神？<br>（1）中华民族精神，是在中华民族五千多年的历史发展中形成的。它既植根于我国优秀的民族文化传统之中，又同我们党领导人民在长期革命、建设和改革中形成的优良传统和时代精神结合在一起，是中华民族生生不息、发展壮大的强大精神动力。（2）建设和发展中国特色社会主义事业，是一项充满艰辛、充满创造的壮丽事业。伟大的事业需要并产生崇高的精神，崇高的精神支撑和推动着伟大的事业。面对世界范围内务种思想文化的相互激荡，我们必须大力弘扬和培育民族精神。（3）弘扬和培育民族精神，既要弘扬中国古代的民族精神，更要大力弘扬和培育近代以来中国人民在争取民族独立和人民解放、实现国家富强和人民共同富裕的历史进程中形成的伟大民族精神。中国共产党在领导人民进行革命、建设和改革的伟大实践中，形成了自己的优良传统，培育出了井冈山精神、长征精神、延安精神、抗战精神、西柏坡精神、雷锋精神、“两弹一星”精神、大庆精神、抗洪精神、抗击“非典”精神、载人航天精神、抗震救灾精神、北京奥运精神等。这些精神是中华民族长期形成的民族精神在现当代历史中震撼人心的新表现，为中华民族精神增添了富于时代精神的新内涵，使中华民族精神进入一个崭新的发展阶段。<br>6、为什么弘扬以改革创新为核心的时代精神？<br>（1）以改革创新为核心的时代精神，是当代中国人民精神风貌的集中写照，是激发社会创造活力的强大力量。建设和发展中国特色社会主义是一项前无古人的创造性事业，只有坚持解放思想、实事求是、与时俱进，牢固树立以人为本、尊重科学、崇尚和谐的观念，发扬诚实守信、团结友爱、互助奉献的风尚，确立民主法治、自由平等、公平正义的理念，增强效率意识、竞争意识、开放意识，大力弘扬以改革创新为核心的时代精神，才能使全体人民始终保持昂扬向上的精神状态，不断推进中国特色社会主义伟大事业。（2）弘扬以改革创新为核心的时代精神，必须大力推进理论创新、制度创新、科技创新、文化创新以及其他各方面的创新。（3）当代大学生要自觉投身于改革创新的伟大实践，要立足于掌握丰富的知识和过硬的本领。要养成团结协作、艰苦奋斗、脚踏实地的作风。要积极投身社会实践，深入实际，深入群众，从广阔的社会实践中提炼研究题目，在深入了解社会的基础上提出真知灼见。（4）当代大学生风华正茂，最少保守思想，敢于冲破落后的、陈腐的观念，有较丰富的文化科学知识和较高的科学素质，思维比较敏捷，最具创新潜力，是国家创新型人才的重要后备军。在已举办多届的高校“挑战杯”科技创新大赛中，大学生都展现了自己的创新才能，充分证明当代大学生是勇于创新、善于创新的群体。同学们要树立创新意识，发扬创新精神，确立与时代进步潮流相适应的思想观念、价值取向和行为方式，努力走在全社会创新的前列，努力为理论创新、制度创新、科技创新、文化创新以及其他各方面的创新作出应有的贡献。<br>第三章  领悟人生真谛 创造人生价值<br>一、单项选择<br>1、世界观就是人们对生活在其中的（）的总体看法和根本观点。（B）（重点）<br>A自然界  B世界以及人与世界的关系  C人类社会  D个人<br>2、人生观是人们在实践中形成的对于（）的根本看法。（B）（重点）<br>A自然界  B人生目的和意义  C人类社会  D个人<br>3、人的本质不是单个人所固有的抽象物，在其现实性上，它是（）的总和。(D) （重点）<br>A单个人所固有的抽象物 B类本质 C亲缘关系 D一切社会关系<br>4、人生观的核心是什么？(B) （重点）<br>A人生追求 B人生目的  C人生态度  D人生价值<br>5、人生态度，是指人们通过（）形成的对人生问题的一种稳定的心理倾向和基本意愿。（C）<br>A思想过程 B思维  C生活实践  D价值评价<br>6、科学高尚的人生观是(A) （重点）<br>A为人民服务人生观 B实现自我 C个人主义 D集体主义<br>7、人生价值是是人的生活实践对于社会和个人所具有的作用和意义。人生价值就是人们从（）角度考虑人生问题的根据。(B)<br>A思想  B价值 C权利   D义务<br>8、衡量人生的社会价值的标准是（D）。（重点）<br>A个体对自身所作的贡献 B个体自我实现 C个体经济收入D个体对社会和他人所作的贡献<br>9、自我价值，是个体的人生活动对自己的生存和发展所具有的价值，表现为(A) （重点）<br>A对自身物质和精神需要的满足程度 B个体经济收入 C个体思想价值D个体对社会的贡献<br>10、人生价值的标准是 (C) （重点）<br>A个体经济收入 B个体对自身的贡献 C以他对社会所作的贡献为标准D个体思想价值<br>11、人生价值评价的根本尺度(A) （重点）<br>A是看一个人的人生活动是否符合社会发展的客观规律，是否通过实践促进了历史的进步<br>B个体对自身所作的贡献  C个体经济收入 D个体思想价值。<br>12、社会评价一个人的人生价值的普遍标准是(C)  与第8、10题一致<br>A个体经济收入 B个体对自身所作的贡献 C劳动以及通过劳动对社会和他人作出的贡献<br>D个体思想价值<br>13、作为社会评价人生价值的基本尺度是(A)<br>A劳动和贡献的尺度 B个体经济收入 C个体对自身所作的贡献 D个体思想价值<br>14、保持身心健康的关键环节。(A) （重点）<br>A协调身心关系以及身心与外部环境的关系以保证人自身系统的健康和活力<br>B保持身体健康  C保持心理健康  D坚持科学人生观<br>15、处理个人与他人的关系的关键是(D) （重点）<br>A处理好个人与个人的利益关系   B处理好个人与个人的思想关系<br>C处理好个人与他人的思想关系   D处理好个人与他人的利益关系<br>16、个人与社会的关系，归根到底是(A) （重点）<br>A个人利益与社会整体利益的关系   B个人利益与个人利益的关系<br>C社会整体利益与社会整体利益的关系 D个人与社会思想关系<br>17、人与自然关系的协调，最终取决于（D）<br>A人与自然关系的协调 B人与社会关系的协调 C人与自我关系的协调D人与人关系的协调。<br>18、人的本质属性是(A) （重点）<br>A社会属性  B自然属性  C类属性  D种属性<br>19、应当成为我们时代最崇高的精神的是(A) （重点）<br>A全心全意为人民服务的精神，毫不利己、专门利人的精神  B唯我独行<br>C个人主义                       D利己主义<br>20、人生价值的最基本内容是(A) （重点）<br>A人生的社会价值 B人生的群体价值 C人生的个体价值 D人生的个人价值<br>21、（）决定了人生的社会价值是人生价值的最基本内容。B（重点）<br>A人的自然属性 B人的社会性  C人的结构性  D人的思维性<br>22、在我们今天所处的社会主义社会中，衡量人生的价值，标准就在于看一个人（A）<br>A是否以自己的劳动和聪明才智为中国特色社会主义真诚奉献，为人民群众尽心尽力服务。<br>B是否以自己的劳动和聪明才智为自我奉献，为自我尽心尽力服务。<br>C是否以自己的劳动和聪明才智为个别人真诚奉献，为个别人尽心尽力服务。自我<br>D是否以自己的劳动和聪明才智为敌人真诚奉献，为敌人尽心尽力服务。<br>23、（）是人生价值真正的源头活水，是实现人生价值的必由之路A（重点）<br>A社会实践  B学习  C教育    D思想<br>24、人与自然关系的协调，最终取决于（）人与人关系的协调。（重点）<br>A人与人  B人与自然界  C人与动物    D人与思想<br>二、多项选择<br>1、人生观是人们在实践中形成的对人生目的和意义的根本看法，决定着人们（ABC）。<br>A实践活动的目标 B人生道路的方向 C对待生活的态度  D人的心理（重点）<br>2、世界观和人生观是紧密联系(CD)<br>A世界观和人生观是一样的 B人生观决定世界观，有什么样的人生观，就有什么样的世界观<br>C世界观决定人生观，有什么样的世界观，就有什么样的人生观<br>D人生观又对世界观的巩固、发展和变化起着重要的作用<br>3、人生观主要是通过哪几个方面体现出来的？(BCD) （重点）<br>A人生追求 B人生目的 C人生态度  D人生价值<br>4、人生目的的作用(BCD) （重点）<br>A人生目的决定人生心理  B人生目的决定人生道路<br>C人生目的决定人生态度  D人生目的决定人生价值标准<br>5、下列属于错误的人生观：(ABC) （重点）<br>A庸碌无为的人生观 B及时行乐的低俗、庸碌和沉沦的人生观<br>C看破红尘的消极悲观的人生观<br>D满怀希望和激情，热爱生活，珍视生命，勇敢坚强地战胜困难并开拓人生新境界的人生观。<br>6、确立积极进取的人生态度就要 (BC) （重点）<br>A世界观紧密联系人生观    B辨证处理人生态度与人生观关系<br>C端正人生态度       D端正世界观<br>7、在人生实践中会遇到各种各样的矛盾和困难，端正人生态度需要(ABCD)（重点）<br>A人生须认真 B人生当务实 C人生应乐观  D人生要进取。<br>8、树立正确的人生观，要坚决抵制哪些错误人生观的影响(ABC)。（重点）<br>A拜金主义人生观 B享乐主义人生观 C个人主义人生观 D为人民服务的人生观<br>9、人生价值内在地包含（）了两个方面(AB) （重点）<br>A人生的自我价值 B人生的社会价值 C人生的思想价值 D人生的经济价值<br>10、自我价值和社会价值，共同构成人生价值的矛盾统一体。下列正确的是(CD) （重点）<br>A人生只有自我价值 B人生只有社会价值 C人生的自我价值是个体生存和发展的必要条件<br>D人生的社会价值是实现人生自我价值的基础<br>11、科学评价人生价值，需要掌握恰当的评价方法，做到以下坚持：(ABCD) （重点）<br>A坚持能力有大小与贡献须尽力相统一  B坚持物质贡献与精神贡献相统一<br>C坚持完善自身与贡献社会相统一    D坚持动机与效果相统一<br>12、人生价值实现的社会条件。(AB) （重点）<br>A实现人生价值要从社会客观条件出发 B人生价值目标要与社会主义核心价值体系相一致<br>C提高自身的能力          D坚守岗位作贡献<br>13、人生价值实现的个人条件。(ABCD)<br>A实现人生价值要从个体自身条件出发 B不断提高自身的能力，增强实现人生价值的本领<br>C立足于现实，坚守岗位作贡献    D实现人生价值要有自强不息的精神<br>14、对于大学生而言，在实践中创造有价值的人生具有特殊的要求。(CD) （重点）<br>A走与领导相结合的道路         B走与社会文化相结合的道路<br>C走与人民群众相结合的道路       D走与社会实践相结合的道路<br>15、科学对待人生环境的作用(ABCD) （重点）<br>A促进自我身心的和谐         B促进个人与他人的和谐<br>C促进个人与社会的和谐        D促进入与自然的和谐<br>16、保持心理健康的途径和方法主要有：(ABCD) （重点）<br>A树立正确的世界观、人生观、价值观   B掌握应对心理问题的科学方法<br>C合理调控情绪             D投入到学习、工作中去<br>17、促进个人与他人的和谐应坚持的原则。(ABCD) （重点）<br>A平等原则  B诚信原则  C宽容原则  D互助原则<br>18、正确认识和处理竞争与合作的关系。(BCD)<br>A竞争是竞争；合作是合作 B正确认识竞争C正确认识合作D正确处理好竞争与合作的关系<br>19、促进个人与社会的和谐应当正确认识(ABCD) （重点）<br>A个体性与社会性的统一关系         B个人需要与社会需要的统一关系<br>C个人利益与社会利益的统一关系   D享受个人权利与承担社会责任的统一关系<br>29、促进入与自然的和谐应该(BCD) （重点）<br>A自然为上     B正确认识人对自然的依存关系<br>C科学把握人对自然的改造活动      D深入理解人与自然的关系<br>三、论述分析<br>1、如何理解世界观与人生观辨证关系<br>（1）世界观就是人们对生活在其中的世界以及人与世界的关系的总体看法和根本观点。人生观是世界观的重要组成部分，是人们在实践中形成的对于人生目的和意义的根本看法，它决定着人们实践活动的目标、人生道路的方向和对待生活的态度。（2）世界观和人生观是紧密联系在一起的。（3）一方面，世界观决定人生观，有什么样的世界观，就有什么样的人生观。正确的世界观，是正确的人生观的基础，人们对人生意义的正确理解，需要建立在对世界发展客观规律正确认识的基础之上。在这个意义上可以说，人生观从属于世界观，没有正确的世界观，也就不可能有正确的人生观。只有树立了马克思主义的世界观，才能树立马克思主义的人生观。（4）另一方面，人生观又对世界观的巩固、发展和变化起着重要的作用。如果一个人的人生观发生变化，往往会导致世界观发生变化。现实生活说明，一个人即使曾经树立起了正确的世界观，但在人生实践中，如果经不起拜金主义、享乐主义和极端个人主义等腐朽人生观的侵蚀，放弃了为人民服务的人生观，那么，正确的世界观必然也会丧失。<br>2、如何用科学高尚的人生观指引人生？（重点）<br>（1）一个树立了为人民服务人生观的人，就能对人生的目的有更为深刻的理解，时时处处为人民着想，助人为乐，造福人民，成为受人民群众欢迎的人。<br>（2）一个树立了为人民服务人生观的人，就能以正确的人生态度对待人生、对待生活，始终对祖国和人民具有高度责任感，在服务人民、奉献社会中实现自己的人生价值。<br>（3）树立为人民服务的人生观，要坚决抵制各种错误人生观的影响。反对拜金主义人生观、<br>反对享乐主义人生观、反对个人主义人生观。<br>3、如何理解人生价值的标准是他对社会所作的贡献？<br>（1）人的社会性决定了人生的社会价值是人生价值的最基本内容。（2）一个人的生活具有什么样的价值，从根本上说是由社会所规定的，而社会对于一个人的价值评判，也主要是以他对社会所作的贡献为标准。（3）个体对社会和他人的生存和发展贡献越大，其人生的社会价值也就越大；反之，人生的社会价值就越小。如果个体的人生活动对社会和他人的生存和发展不仅没有贡献，反而起到某种反作用，那么，这种人生的社会价值就表现为负价值。<br>4、如何理解人生价值评价的根本尺度？<br>（1）人生价值评价的根本尺度，是看一个人的人生活动是否符合社会发展的客观规律，是否通过实践促进了历史的进步。（2）劳动以及通过劳动对社会和他人作出的贡献，是社会评价一个人的人生价值的普遍标准。一个人对社会和他人所作的贡献越大，他在社会中获得的人生价值的评价就越高。劳动和贡献的尺度作为社会评价人生价值的基本尺度，正是对人生价值评价根本尺度的一种具体化。（3）在我们今天所处的社会主义社会中，衡量人生的价值，标准就在于看一个人是否以自己的劳动和聪明才智为中国特色社会主义真诚奉献，为人民群众尽心尽力服务。<br>5、人生目的在人生实践中具有重要的作用。<br> (1)人生目的决定人生道路 一方面，人生目的规定了人生活动的大方向，对人们所从事的具体活动起着定向的作用。另一方面，人生目的又是人生行为的动力源泉。(2)人生目的决定人生态度。(3)人生目的决定人生价值标准。<br>6、人生价值的评价<br>比较客观、公正、准确地评价社会成员人生价值的大小，除了要掌握科学的标准外，还需要掌握恰当的评价方法，做到以下四个坚持：第一，坚持能力有大小与贡献须尽力相统一。第二，坚持物质贡献与精神贡献相统一。第三，坚持完善自身与贡献社会相统一。第四，坚持动机与效果相统一。<br>7、人生价值实现的条件<br>(1)人生价值实现的社会条件。第一，实现人生价值要从社会客观条件出发。第二，人生价值目标要与社会主义核心价值体系相一致。(2)人生价值实现的个人条件。第一，实现人生价值要从个体自身条件出发。第二，不断提高自身的能力，增强实现人生价值的本领。第三，立足于现实，坚守岗位作贡献。第四，实现人生价值要有自强不息的精神。<br>8、在实践中创造有价值的人生<br>对于大学生而言，在实践中创造有价值的人生具有特殊的要求。 (1)走与人民群众相结合的道路。(2)走与社会实践相结合的道路。<br>9、如何科学对待人生环境（重点）<br>（1）促进自我身心的和谐（2）促进个人与他人的和谐（3）促进个人与社会的和谐（4）促进入与自然的和谐<br>10、如何促进个人与他人的和谐。<br>个人与他人的关系，在本质上是社会关系尤其是社会利益关系的表现形式。人类要生存，首先必须满足各种需要。任何需要都是一定主体在一定的生产关系的基础上，在一定的客观条件下，对一定对象的需要，都必然通过一定的社会关系才能实现。因此，处理个人与他人的关系，关键是要处理好个人与他人的利益关系。(1)促进个人与他人的和谐应坚持的原则。第一，平等原则。第二，诚信原则。第三，宽容原则。第四，互助原则。(2)正确认识和处理竞争与合作的关系。第一，正确认识竞争。第二，正确认识合作。<br>11、促进个人与社会的和谐<br>（1）正确认识个体性与社会性的统一关系。(2)正确认识个人需要与社会需要的统一关系。(3)正确认识个人利益与社会利益的统一关系。(4)正确认识享受个人权利与承担社会责任的统一关系。<br>第四章 加强道德修养 锤炼道德品质<br>一、单项选择(ABCD)<br>1、道德的起源的第一个历史前提是(A) （重点）<br>A劳动      B社会关系     C思想     D上帝<br>2、道德的本质是(D) （重点）<br>A道德是一种特殊的社会意识形式  B道德是一种特殊的思想形式<br>C道德是绝对精神的反映  D归根到底是由经济基础决定的，是社会经济关系的反映<br>3、道德最突出也是最重要的社会功能。（B）（重点）<br>A认识功能   B调节功能   C导向功能  D激励功能、辩护功能、沟通功能<br>4、道德调节的主要形式(A) （重点）<br>A道德评价  B社会舆论    C传统习惯   D人们的内心信念<br>5、人类道德发展的历史过程与（）的发展进程大体一致。(B)<br>A社会政治   B社会生产方式    C文化发展  D社会思想意识<br>6、宋代的范仲淹在《岳阳楼记》中提出“先天下之忧而忧，后天下之乐而乐”，《尚书》也有“以公灭私，民其允怀”的思想，《诗经》已经提出“夙夜在公”。以上主要反映了中华民族优良道德传统 (A)<br>A注重整体利益、国家利益和民族利益，强调对社会、民族、国家的责任意识和奉献精神。<br>B推崇“仁爱”原则，追求人际和谐。  C倡导言行一致，强调恪守诚信。<br>D重视道德践履，强调修养的重要性。<br>7、孔子强调“己所不欲，勿施于人”，“己欲立而立人，己欲达而达人”，“孝悌也者，其为仁之本与”。孟子也强调“老吾老以及人之老，幼吾幼以及人之幼”。“亲亲而仁民，仁民而爱物”。荀子则强调“仁者自爱”。墨子从人和人之间的相互尊重和功利原则的角度，提出“兼相爱，交相利”的思想。以上主要反映了中华民族优良道德传统 (B)<br>A注重整体利益、国家利益和民族利益，强调对社会、民族、国家的责任意识和奉献精神。<br>B推崇“仁爱”原则，追求人际和谐。  C倡导言行一致，强调恪守诚信。<br>D重视道德践履，强调修养的重要性。<br>8、孔子提出“人而无信，不知其可也”的思想，而且认为“民无信不立”。荀子“与朋友交，言而有信”；“信近于义，言可复也”。以上主要反映了中华民族优良道德传统（C）<br>A注重整体利益、国家利益和民族利益，强调对社会、民族、国家的责任意识和奉献精神。<br>B推崇“仁爱”原则，追求人际和谐。C倡导言行一致，强调恪守诚信。<br>D重视道德践履，强调修养的重要性。<br>9、孔子说，“仁远乎哉?我欲仁，斯仁至矣”，“有能一日用其力于仁矣乎?我未见力不足者”， “见贤思齐焉，见不贤而内自省也”，“吾日三省吾身”。苟子认为，“道虽迩，不行不至；事虽小，不为不成”。墨家强调“察色修身”和“以身戴行”。以上主要反映了中华民族优良道德传统（D）<br>A注重整体利益、国家利益和民族利益，强调对社会、民族、国家的责任意识和奉献精神。<br>B推崇“仁爱”原则，追求人际和谐。  C倡导言行一致，强调恪守诚信。<br>D重视道德践履，强调修养的重要性，倡导道德主体要在完善自身中发挥自己的能动作用<br>10、社会主义道德建设的核心是(A) （重点）<br>A为人民服务  B集体主义  C个人主义  D社会主义核心价值体系<br>11、社会主义道德建设的原则是(B) （重点）<br>A为人民服务  B集体主义  C个人主义  D社会主义核心价值体系<br>12、当代中国社会最基本的价值取向和行为准则是(C) （重点）<br>A为人民服务 B集体主义  C社会主义荣辱观  D社会主义核心价值体系<br>二、多项选择(ABCD)<br>1、道德的起源条件有(ABCD)<br>A社会关系的形成是道德赖以产生的客观条件。<br>B人类自我意识的形成与发展是道德产生的主观条件。<br>C道德产生所需要的主客观条件是统一于生产实践的。劳动创造了人和人类社会，劳动是人类道德起源的第一个历史前提。<br>D随着人类文明时代的开始，道德逐渐从风俗习惯中分化出来，成为一种相对独立的社会意识形式。<br>2、道德的本质是社会经济关系的反映。具体体现(ABCD) （重点）<br>A社会经济关系的性质决定着各种道德体系的性质。<br>B社会经济关系所表现出来的利益决定着各种道德的基本原则和主要规范。<br>C在阶级社会中，社会经济关系主要表现为阶级关系，因此，道德也必然带有阶级属性。<br>D社会经济关系的变化必然引起道德的变化。<br>3、在道德的功能系统中，主要的功能是(AB) （重点）<br>A认识功能  B调节功能  C导向功能  D激励功能、辩护功能、沟通功能<br>4、下列属于道德的功能的(ABCDEF)<br>A认识功能 B调节功能 C导向功能 D激励功能 E辩护功能 F沟通功能<br>5、道德的历史发展形态有(ABCDE)<br>A原始社会的道德 B奴隶社会的道德 C封建社会的道德 D资本主义社会的道德<br>E社会主义社会的道德和共产主义道德<br>6、人类道德进步的主要表现是：(ABCD)<br>A道德在社会生活中所起的作用越来越重要，对于促进社会和谐与人的全面发展的作用越来越突出   B道德调控的范围不断扩大，调控的手段或方式不断丰富、更加科学合理<br>C道德的发展和进步成为衡量社会文明程度的重要尺度<br>D社会主义道德和共产主义道德，是人类道德发展合乎规律的必然产物，是人类道德发展史上的一种崭新类型的道德，是对人类道德传统的批判继承，并必然随着社会的进步和实践的发展而与时俱进。<br>7、继承和弘扬中华民族优良道德传统有哪些重大意义(ABC) （重点）<br>A继承和弘扬中华民族优良道德传统是社会主义现代化建设的客观需要<br>B继承和弘扬中华民族优良道德传统是加强社会主义道德建设的内在要求<br>C继承和弘扬中华民族优良道德传统是个人健康成长的重要条件<br>D 继承和弘扬中华民族优良道德传统是反对全盘西化的条件<br>8、中华民族优良道德传统的主要内容有(ABCDEF)<br>A注重整体利益、国家利益和民族利益，强调对社会、民族、国家的责任意识和奉献精神。<br>B推崇“仁爱”原则，追求人际和谐    C讲求谦敬礼让，强调克骄防矜<br>D倡导言行一致，强调恪守诚信E追求精神境界，把道德理想实现看做是一种高层次的需要<br>F重视道德践履，强调修养的重要性，倡导道德主体要在完善自身中发挥自己的能动作用。<br>9、在对待传统道德的问题上，要反对下列错误思潮。(AB) （重点）<br>A文化复古主义思潮 B历史虚无主义思潮 C世界主义思潮 D民族主义思潮<br>10、社会主义道德建设要以为人民服务为核心，原因是(CD) （重点）<br>A为人民服务是马克思主义的要求  B为人民服务是社会主义文化要求<br>C为人民服务是社会主义经济基础和人际关系的客观要求<br>D为人民服务是社会主义市场经济健康发展的要求<br>11、集体主义为原则基本内涵主要有(ABC) （重点）<br>A社会主义集体主义强调集体利益和个人利益的辩证统一。<br>B社会主义集体主义强调集体利益高于个人利益。<br>C社会主义集体主义强调重视和保障个人的正当利益。<br>D个人利益与集体利益一致。<br>12、社会主义荣辱观体现了社会主义道德建设的客观要求主要体现(BCD) （重点）<br>A社会主义荣辱观反映传统文化。<br>B社会主义荣辱观反映了社会主义道德的本质要求。<br>C社会主义荣辱观指明了社会主义道德建设的方向。<br>D（社会主义荣辱观是引领社会风尚的一面旗帜。三、论述分析<br>1、什么是道德的社会作用？有哪些表现？<br>道德功能的发挥和实现所产生的社会影响及实际效果，就是道德的社会作用。道德的社会作用主要表现在：（1）道德能够影响经济基础的形成、巩固和发展；（2）道德是影响社会生产力发展的一种重要的精神力量；（3）道德对其他社会意识形态的存在和发展有着重大的影响；（4）道德通过调整人们之间的关系维护社会秩序和稳定；（5）道德是提高人的精神境界、促进人的自我完善、推动人的全面发展的内在动力；（6）在阶级社会中，道德是阶级斗争的重要工具。（7）在看到道德具有重大的社会作用的同时，也必须看到道德发挥作用的性质并不都是一样的。道德发挥作用的性质与社会发展的不同历史阶段相联系，由道德所反映的经济基础、代表的阶级利益所决定。只有反映先进生产力发展要求和进步阶级利益的道德，才会对社会的发展和人的素质的提高产生积极的推动作用，否则，就不利于甚至阻碍社会的发展和人的素质的提高。<br>2、如何正确对待中华民族道德传统（重点）<br>（1）中华民族的道德传统是一个矛盾体，具有鲜明的两重性。属于精华的部分，表现出积极、革新、进步的一面；属于糟粕的部分，则表现出消极、保守、落后的一面。<br>（2）正确对待中华民族道德传统，要坚持马克思主义的立场、观点和方法，既不能全盘肯定、全面照搬，也不能全盘否定、全面抛弃。<br>（3）要按照是否有利于推动中国特色社会主义的建设事业，是否有利于建设和形成中国特色社会主义的道德体系，是否有利于维护广大人民群众的根本利益，是否有利于培养社会主义“四有”新人的标准，做好取舍和创造性的转化工作。<br>（4）要通过分析、鉴别、取舍和改造，剔除那些带有明显的阶级和时代局限性的成分，继承和弘扬优良的道德传统，特别是那些反映普遍性、共同性和一般性道德要求，对我们今天的道德实践仍然具有借鉴意义的积极内容。<br>（5）在对待传统道德的问题上，要反对两种错误思潮。一种是文化复古主义思潮。另一种是历史虚无主义思潮。<br>3、在社会主义市场经济条件下如何进行社会主义道德建设？<br>（1）我国社会主义的道德建设，应当建立在社会主义初级阶段，以公有制为主体、多种所有制经济共同发展的基本经济制度之上，反映这一基本经济制度的要求，为坚持和完善这一基本经济制度服务。（2）在这一基本经济制度上实行的社会主义市场经济体制，以市场为配置资源的基础性手段的经济运行机制，对道德建设提出了新的要求。社会主义道德建设既有与社会主义市场经济相适应的现实要求，也有为社会主义市场经济体制的建立和完善提供道德价值导向的重要任务。（3）社会主义市场经济是社会主义条件下的市场经济。一方面，现代市场经济的共同属性和一般规律，是我国社会主义市场经济必须遵循的。另一方面，社会主义市场经济是同社会主义基本制度结合在一起的，是同社会主义精神文明结合在一起的，它要体现社会主义基本制度的要求，充分发挥社会主义的优越性。市场经济可以和不同的经济制度与政治制度相结合。要把市场经济和社会主义制度有机结合起来，离不开社会主义先进文化和社会主义道德体系。加快社会主义道德文化建设，有助于保证市场经济沿着社会主义轨道有序健康的发展。（4）实践证明，发展社会主义市场经济有利于解放和发展社会主义社会的生产力，增强社会主义国家的综合国力，提高人民的生活水平，也有利于增强人们的自立意识、竞争意识、效率意识、民主法制意识和开拓创新意识，调动人们的积极性和创造性，推动社会的道德进步。（5）市场自身的弱点和消极方面，如趋利性、自发性等也会反映到道德生活中来，反映到人与人的关系上，容易诱发拜金主义、享乐主义、极端个人主义等消极现象，这些因素都会干扰社会主义的道德建设，阻碍社会主义市场经济的健康发展。物质贫乏不是社会主义，精神空虚也不是社会主义。任何时候都不能以牺牲精神文明和道德建设为代价换取经济的一时发展。（6）要把发展社会生产力同提高全民族文明素质结合起来，坚持物质文明和精神文明两手抓，实行依法治国和以德治国相结合。适应新的形势和要求，建立和完善与社会主义市场经济相适应、与社会主义法律规范相协调、与中华民族传统美德相承接的社会主义思想道德体系，确立全体社会成员共同遵循的价值导向和行为准则。提高全民族的道德素质、全社会的文明程度，已成为当前全面建设小康社会、构建社会主义和谐社会的一项紧迫任务，也是大学生在成长成才过程中必须面对的重要课题。（7）把握社会主义市场经济对道德建设提出的新要求，要坚持公民承担社会责任与社会尊重个人合法权益相一致，先进性要求与广泛性要求相结合，着力培养与社会主义市场经济相适应的道德观念，为社会主义市场经济的发展提供良好的道德环境和有力的道义支撑。（8）要正确处理竞争与协作、自主与监督、效率与公平、先富与共富、经济效益与社会效益等关系。要正确认识和运用物质利益原则，树立正确的义利观，既要鼓励人们通过诚实劳动、合法经营去获得正当的个人利益，也要大张旗鼓地褒奖见利思义、见得思义，反对见利忘义、唯利是图，形成把国家和人民利益放在首位而又充分尊重公民个人合法利益的社会主义义利观。要正确发挥社会主义道德对市场经济的价值导向作用，形成和完善与社会主义市场经济相适应的道德规范，发挥市场经济的积极效应，避免市场经济的消极效应，促进和保障社会主义市场经济体制健康发展。<br>4、为什么宣传和弘扬共产主义道德？<br>（1）社会主义道德和共产主义道德在本质上是同一类型的道德，社会主义道德是共产主义道德在现阶段的具体体现。社会主义初级阶段的道德建设，不仅要适应现阶段经济关系的需要，而且要引导人们向更高的道德目标前进。（2）共产主义道德不仅是人类的道德理想，而且深深植根于中国革命的历史实践和中国特色社会主义的实践中，表现为大公无私、公而忘私，毫不利己、专门利人，艰苦奋斗、无私奉献，全心全意为人民服务。（3）中国共产党历来高度重视弘扬共产主义道德，并根据不同历史时期所处的不同环境和任务的要求，开展共产主义道德的宣传和教育，使之成为广大党员干部的强大动力和精神支柱。（4）在长期革命、建设和改革的实践中，在发展社会主义市场经济的条件下，不断涌现出许多具有共产主义思想道德的先进人物，而且，对这些先进人物的广泛宣传和深入学习，已经在全社会产生了很好的效果。（5）社会主义初级阶段的道德建设，要把先进性要求与广泛性要求结合起来。离开现实的道德状况，只谈共产主义道德的崇高理想，就会脱离实际；忘记共产主义道德的远大理想，只谈道德的基本要求和最低要求，就会失去前进的方向。<br>7、道德的本质<br>道德作为一种特殊的社会意识形式，归根到底是由经济基础决定的，是社会经济关系的反映。<br>首先，社会经济关系的性质决定着各种道德体系的性质。其次，社会经济关系所表现出来的利益决定着各种道德的基本原则和主要规范。再次，在阶级社会中，社会经济关系主要表现为阶级关系，因此，道德也必然带有阶级属性。最后，社会经济关系的变化必然引起道德的变化。道德对社会经济关系的反映不是消极被动的，而是以能动的方式来把握世界，引导和规范人们的社会实践活动。<br>8、继承和弘扬中华民族优良道德传统的重大意义<br>(1)继承和弘扬中华民族优良道德传统是社会主义现代化建设的客观需要<br>(2)继承和弘扬中华民族优良道德传统是加强社会主义道德建设的内在要求<br>(3)继承和弘扬中华民族优良道德传统是个人健康成长的重要条件<br>9、中华民族优良道德传统的主要内容<br>(1)注重整体利益、国家利益和民族利益，强调对社会、民族、国家的责任意识和奉献精神。 (2)推崇“仁爱”原则，追求人际和谐(3)讲求谦敬礼让，强调克骄防矜(4)倡导言行一致，强调恪守诚信(5)追求精神境界，把道德理想的实现看做是一种高层次的需要(6)重视道德践履，强调修养的重要性，倡导道德主体要在完善自身中发挥自己的能动作用<br>10、社会主义道德建设要以为人民服务为核心？<br>道德建设的核心，即道德建设的灵魂.在构建社会主义和谐社会的过程中，提出社会主义道德建设以为人民服务为核心，具有深刻的理论依据和坚实的实践基础。第一，为人民服务是社会主义经济基础和人际关系的客观要求。第二，为人民服务是社会主义市场经济健康发展的要求。<br>11、社会主义道德建设要以集体主义为原则？<br>在社会主义道德体系中，集体主义原则是指导人们行为选择的主导性原则。这是社会主义经济、政治、文化、社会建设的必然要求。生产资料公有制占主体地位的社会主义基本经济制度，为集体主义的实施创造了经济前提；以工人阶级为领导阶级、以共产党为执政党的人民当家作主的国体、政体，为集体主义的实施创造了政治前提；以中国特色社会主义理论体系为指导的社会主义先进文化，为集体主义的实施创造了文化前提。总之，在社会主义社会，人民当家作主，国家利益、集体利益和个人利益根本上的一致性，使得集体主义应当而且能够在全社会范围内贯彻实施。长期以来，集体主义已经成为调节国家、集体和个人三者利益关系的最重要的原则。发展社会主义市场经济，是同社会主义基本制度有机结合的，从这个意义上讲，集体主义不但与社会主义市场经济相契合，而且也正是发展和完善社会主义市场经济的客观要求。社会主义集体主义原则的根本思想，就是正确处理集体利益和个人利益的关系。第一，社会主义集体主义强调集体利益和个人利益的辩证统一。第二，社会主义集体主义强调集体利益高于个人利益。第三，社会主义集体主义强调重视和保障个人的正当利益。</p><p>第七章：遵守行为规范，锤炼高尚品格</p><p>一、单项选择<br>1、社会交往和公共生活中应当遵守的最基本的道德规范是(A) （重点）<br>A社会公德 B法律 C技术规范 D职业道德<br>2、社会公德最基本的要求是(D) （重点）<br>A文明礼貌 B助人为乐 C爱护公物 D遵纪守法<br>4、法律最首要的作用是(A) （重点）<br>A指引作用  B预测作用  C评价作用  D强制作用<br>二、多项选择<br>1、当代社会公共生活的特征主要表现在以下几个方面：(ABCD) （重点）<br>A活动范围的广泛性。B活动内容的公开性。C活动方式的多样性。D交往对象的复杂性。<br>2、在当代社会，维护公共秩序对经济社会健康发展有以下重要意义(ABCD) （重点）<br>A有序的公共生活是构建和谐社会的重要条件<br>B有序的公共生活是经济社会健康发展的必要前提<br>C有序的公共生活是提高社会成员生活质量的基本保证<br>D有序的公共生活是国家现代化和文明程度的重要标志<br>3、维护社会秩序的基本手段有(CD) （重点）<br>A技术 B文化 C道德 D法律<br>4、社会公德的基本特点主要表现为：(ABCD) （重点）<br>A继承性。 B基础性。 C广泛性。D简明性。<br>5、社会公德在各种关系中具体表现是(ABC)<br>A在人与人之间关系的层面上，社会公德主要体现为举止文明、尊重他人；<br>B在人与社会之间关系的层面上，社会公德主要体现为爱护公物、维护公共秩序；<br>C在人与自然之间关系的层面上，社会公德主要体现为热爱自然、保护环境。<br>D社会公德在各种关系中体现为诚信。<br>6、社会公德的主要内容(ABCDE)<br>A文明礼貌 B助人为乐 C爱护公物 D保护环境 E遵纪守法<br>9、公共生活中法律规范作用有(ABCDE)<br>A指引作用 B预测作用 C评价作用 D强制作用 E教育作用<br>10、法律的教育作用的实现主要有(ABC)<br>A法律作出规定，通过人们对法律的了解和学习，发挥教育作用；<br>B法律通过对各种违法犯罪行为的制裁，使违法犯罪者和一般社会成员受到教育；<br>C法律通过对各种先进人物、模范行为的嘉奖与鼓励，为人们树立良好的法律上的行为楷模。<br>D示范作用。<br>11、下列属于公共生活中的法律规范的是(ABCDE)<br>A《治安管理处罚法》B《集会游行<em><strong><strong>法》C《环境保护法》D《道路交通安全法》<br>E《维护互联网安全的决定》<br>12、《治安管理处罚法》的基本原则有(ABC) （重点）<br>A治安管理处罚必须以事实为依据，与违反治安管理行为的性质、情节以及社会危害程度相当；<br>B实施治安管理处罚，应当公开、公正，尊重和保障人权，保护公民的人格尊严；<br>C办理治安案件应当坚持教育与处罚相结合的原则。<br>D平等原则。<br>13 、《集会游行</strong></strong></em>法》的基本原则(BCD) （重点）<br>A公民随便游行原则。B政府依法保障原则。C权利义务一致原则。D和平进行原则。<br>14、《环境保护法》基本原则(ABC)<br>A经济建设与环境保护协调发展原则。B预防为主、防治结合、综合整治原则。<br>C谁污染谁治理、谁开发谁保护原则。D环境自我维护。<br>15、《道路交通安全法》的基本原则(CD) （重点）<br>A右侧通行 B左侧通行 C依法管理原则 D以人为本、与民方便原则<br>16、《维护互联网安全的决定》的基本原则(ABC) （重点）<br>A促进网络发展与加强监管相结合的原则。<br>B信息自由与社会公共利益有机结合的原则。<br>C与现代网络发展相适应、与传统法律规范相协调的原则。<br>D网络绝对自由。</p><p>第七章第三节<br>一、单项选择(ABCD)<br>4、婚姻家庭的本质是（）(B) （重点）<br>A自然属性 B社会属性 C自然属性与社会属性 D智力结合<br>5、家庭关系的核心是（），（重点）<br>A夫妻关系 B父母子女 C兄弟姊妹  D祖孙关系<br>二、多项选择(ABCD)<br>15、恋爱中的道德要求主要体现在(BCD) （重点）<br>A男女不平等。B尊重人格平等。C自觉承担责任。D文明相亲相爱。<br>16、家庭美德的基本规范(ABCDE)<br>A尊老爱幼。B男女平等。C夫妻和睦。D勤俭持家。E邻里团结。<br>17、婚姻法的基本原则(ABCDEF)<br>A婚姻自由B一夫一妻C男女平等D保护妇女、老人和儿童的合法权益E实行计划生育；<br>F夫妻互相忠实、互相尊重，家庭成员间敬老爱幼、互相帮助。<br>18、结婚的必备条件有三个(ABC) （重点）<br>A必须男女双方完全自愿。B必须达到法定婚龄。《婚姻法》规定，结婚年龄，男不得早于22周岁，女不得早于20周岁。晚婚晚育应予鼓励。<br>C必须符合一夫一妻制。D婚姻大事父母做主。<br>19、结婚的禁止条件：(BC)<br>A禁止年龄差距过大。B禁止直系血亲和三代以内旁系血亲结婚。<br>C禁止患有医学上认为不应当结婚的疾病的人结婚。D不同种族间的通婚。<br>20、家庭关系包括(ABC)<br>A夫妻关系、B父母子女关系C其他家庭成员关系，祖父母、外祖父母与孙子女、外孙子女之间，兄弟姐妹之间的权利义务关系。   D姨舅关系<br>21、离婚的原则(BC) （重点）<br>A名门不允许离婚。B保障离婚自由。C反对轻率离婚。D离婚不能复婚。<br>22、离婚有两种方式：(AB) （重点）<br>A协议离婚。B诉讼离婚。C强迫离婚。D指定离婚。<br>23、夫妻关系包括;( AB ) （重点）<br>A人身关系 B财产关系 C思想关系 D价值关系<br>三、论述分析(ABCD)<br>6、恋爱中的道德要求主要体现 第一，尊重人格平等。第二，自觉承担责任。第三，文明相亲相爱。<br>第七章 法律<br>一、单项选择(ABCD)<br>1.法律是由国家制定或认可并以国家强制力保证实施的，反映由（）所决定的统治阶级意志的规范体系。(D) （重点）<br>A社会的思想发展条件。B社会的物质发展条件。C政治发展条件。D特定社会物质生活条件。<br>2、决定法律本质、内容和发展方向的根本因素是(A) （重点）<br>A物质资料的生产方式。B地理环境。C人口。D社会状况。<br>3、我国社会主义法律体系核心是(A) （重点）<br>A宪法  B宪法及宪法相关法 C民法商法  D行政法<br>4、依法治国的根本保证是(D) （重点）<br>A法律制度的保障  B自我意识的自觉性。C与时俱进修改政策。D党的领导<br>二、多项选择(ABCD)<br>1.法律的本质体现在(ABC) （重点）<br>A法律是由国家创制并保证实施的行为规范。B法律是统治阶级意志的体现。<br>C法律由社会物质生活条件决定。D法律是根据历史传统产生的。<br>2、国家创制法律规范的方式主要有(CD) （重点）<br>A约定。B同意。C制定。D认可。<br>3、在阶级社会中，法律是统治阶级意志的体现。下列正确的是(ACD)<br>A法律所体现的是统治阶级的阶级意志，即统治阶级的整体意志.<br>B是个别统治者的意志，是统治者个人意志的简单相加。<br>C统治阶级不仅迫使被统治阶级服从和遵守法律，而且要求统治阶级的成员也遵守法律。<br>D法律所体现的统治阶级意志，并不是统治阶级意志的全部，而仅仅是上升为国家意志的那部分意志。<br>4、社会物质生活条件包括 (ABC)<br>A物质资料的生产方式。B地理环境。C人口。D社会状况。<br>5、我国社会主义法律的本质体现(ABC) （重点）<br>A从法律所体现的意志来看，体现了阶级性与人民性的统一。<br>B从法律的实质内容来看，具有鲜明的科学性和先进性。<br>C从法律的社会作用来看，是中国特色社会主义事业顺利发展，和谐社会建设的法律保障。<br>D道德的反映。<br>6、我国社会主义法律的科学性和先进性主要体现在(BCD)<br>A 本身的主观性。<br>B我国社会主义法律坚持了辩证唯物主义和历史唯物主义的世界观和方法论。<br>C我国社会主义法律善于借鉴我国传统法和外国法的成功经验。前人和他人的成功经验，实际上是客观规律的反映，因而对这些成功经验的吸收，就是对规律性认识的吸收。<br>D我国社会主义法律的立法体制、立法程序和立法技术，适应时*****展而不断改革与创新，使立法的质量和水平不断提高。<br>7、我国社会主义法律的运行包括(ABCD) （重点）<br>A法律制定(立法)B法律遵守(守法)C法律执行(执法)D法律适用(司法)<br>8、法律制定的程序有(ABCD) （重点）<br>A法律案的提出，B法律案的审议，C法律案的表决，D法律的公布。<br>9、依法办事包括(AB) （重点）<br>A依法享有并行使权利B依法承担并履行义务C自主行为D依约定行为<br>10、在形成并完善中国特色社会主义法律体系过程中应当把握的原则(ABCD)<br>A不能用西方的法律体系来套我们的法律体系。<br>B行政法规和地方性法规都是法律体系的重要组成部分。<br>C要区分法律手段和其他调整手段的关系，需要用法律调整的才通过立法来规范，以更好地发挥法制的功能和作用。<br>D我们的法律体系是动态的、开放的、发展的，本身就有一个与时俱进的问题，需要适应客观形势的发展变化，不断加以完善。<br>11、社会主义法治观念有(ABC) （重点）<br>A自由平等观念B公平正义观念C权利义务观念D民主法制观念<br>12、自由平等观念最为核心的内容包括(AB) （重点）<br>A依法享有和行使自由的观念 B法律面前人人平等观念 C绝对自由 D机会、结果平等<br>13、法律面前人人平等观念包括(CD)<br>A绝对平等。B思想意识一律平等。C公民在守法上一律平等。D公民在适用法律上一律平等。<br>14、法律上公平正义观念包括(AB)<br>A坚持立法公正与执法公正并重。B坚持实体公正与程序公正并重。<br>C思想意识上公平正义。D绝对的公平正义。<br>15、执法公正包括(ABC)<br>A坚持合法合理原则B坚持及时高效的原则C坚持程序公正的原财D坚持弱者优先的原财<br>18、法律上的证据与一般的事实有什么不同(ABC)<br>A证据要具有合法性。B证据要具有客观性。C证据要具有关联性。D证据要符合主观逻辑。<br>20、培养法律思维方式的途径有(ABC) （重点）<br>A学习法律知识。学习和掌握基本的法律知识，是培养法律思维方式的前提。<br>B掌握法律方法。C参与法律实践。D人生下来就有法律思维。<br>24、法律是统治阶级意志的体现。（AB）<br>A 法律所体现的是统治阶级的阶级意志，即统治阶级的整体意志，而不是个别统治者的意志，也不是统治者个人意志的简单相加。<br>B法律所体现的统治阶级意志，并不是统治阶级意志的全部，而仅仅是上升为国家意志的那部分意志。C个体个人的意志综合。D各团体的共同意志。<br>三、论述分析<br>1、我国社会主义法律体系主要包括哪些？<br>(1)宪法及宪法相关法(2)民法商法(3)行政法(4)经济法(5)社会法(6)刑法(7)诉讼与非诉讼程序法<br>7、什么是权利义务观念？（如何理解权利义务观念？）参考课本P162 权利与义务的关系<br>正确的法律权利与义务观念，包括正确理解法律权利与法律义务的性质，把握法律权利与法律义务的关系，懂得如何适当行使法律权利，正确履行法律义务。(1)法律权利与法律义务的性质 法律权利和法律义务是一对关系密切的概念，应当从两者的相互联系中去理解它们各自的性质。可以从三个方面理解法律权利和法律义务的性质。从来源来看，法律权利和法律义务一般都来源于法律的明文规定，或者法律虽未明文规定，但可以从法律的规定中推导出来。后一类法律权利和法律义务通常被称为默示的或推定的权利和义务。从基本内容来看，法律权利意味着人们可以依法作或不作一定行为，可以依法要求他人作或不作一定行为。法律通过规定权利，使人们获得某种合法的利益或自由。法律义务包括作为义务和不作为义务两种。从范围来看，法律权利和法律义务都有明确的界限。首先，法律规定的权利和义务的种类及范围，受社会物质生活条件、政治文明程度以及文化发展水平制约，以社会承受能力为限度。其次，每项法律权利和法律义务都有法定界限。无论是行使权利，还是履行义务，都应当在法定界限内进行。(2)法律权利与法律义务的关系 从法律的历史和实践来看，法律权利与法律义务之间存在多方面的复杂关系。一般说来，可以把法律权利与法律义务的关系概括为结构上的相关关系、总量上的等值关系、功能上的互补关系等三个方面。一是结构上的相关关系。法律权利和法律义务是对立统一的。法律权利与法律义务，一个是表征利益，另一个是表征负担；一个是主动的，另一个是被动的。就此而言，它们是法律这一事物中两个分离的、相反的成分和因素，是两个互相排斥的对立面。同时，法律权利和法律义务又相互依存、相互贯通。两者都不可能孤立存在与发展，一方的存在和发展都必须以另一方的存在和发展为条件。它们相互渗透、相互包含，而且在一定条件下相互转化。正如马克思所说，没有无义务的权利，也没有无权利的义务。二是总量上的等值关系。法律权利和法律义务在总量上是等值的。首先，一个社会的法律权利总量和法律义务总量是相等的。在一个社会中，无论法律权利和法律义务怎样分配，不管每个社会成员实际享有的法律权利和承担的法律义务怎样不均衡，也不管规定权利与规定义务的法条数量是否相等，法律权利与法律义务在总量上总是等值或等额的。其次，在具体法律关系中，法律权利与法律义务互相包含。法律权利的范围就是法律义务的界限，同样，法律义务的范围就是法律权利的界限。三是功能上的互补关系。法律权利和法律义务各有其独特的、总体上又是相互补充的功能。法律权利以其特有的利益导向和激励机制而更有助于实现人的自由。法律义务以其强制某些积极行为发生、防范某些消极行为出现的特有约束机制而更有助于建立社会秩序。由于自由和秩序都是社会的基本价值目标，因而法律权利和法律义务对一个社会来说是缺一不可的。<br>\11. 论法律的一般含义（重点）<br>第一，法律是由国家创制并保证实施的行为规范。国家创制法律规范的方式主要有两种：一是制定。二是认可。<br>法律不但由国家制定或认可，而且由国家保证实施。<br>第二，法律是统治阶级意志的体现。<br>首先，法律所体现的是统治阶级的阶级意志，即统治阶级的整体意志，而不是个别统治者的意志，也不是统治者个人意志的简单相加。<br>其次，法律所体现的统治阶级意志，并不是统治阶级意志的全部，而仅仅是上升为国家意志的那部分意志。<br>第三，法律由社会物质生活条件决定。<br>社会物质生活条件是指与人类生存相关的物质资料的生产方式、地理环境和人口等。其中，物质资料的生产方式既是决定社会面貌、性质和发展的根本因素，也是决定法律本质、内容和发展方向的根本因素。<br>综合以上三个方面，可以将法律定义为：法律是由国家制定或认可并以国家强制力保证实施的，反映由特定社会物质生活条件所决定的统治阶级意志的规范体系。</p><p>第八章  法律<br>一、单项选择<br>2、我国经济制度的基础是(D)<br>A全民和劳动群众集体所有制B多种所有制经济共同发展C私营经济D社会主义公有制<br>3、国民经济中的主导力量，控制着国家的经济命脉，决定国民经济的社会主义性质的是(D)<br>A全民所有制和劳动群众集体所有制B多种所有制经济共同发展<br>C私营经济           D全民所有制经济即国有经济。<br>3、我国公民的最高法律义务是(C) （重点）<br>A遵守宪法和法律B保卫祖国、依法服兵役和参加民兵组织<br>C维护国家统一和全国各民族团结  D依法纳税<br>4、中华人民共和国最高国家权力机关是(B) （重点）<br>A全国人民代表大会常务委员会B全国人民代表大会C国务院D<br>5、最高国家权力机关的执行机关，最高国家行政机关是(A) （重点）<br>A中华人民共和国国务院即中央人民政府B国家主席C主席D最高法院院长。<br>6、全国武装力量的最高领导机关是(C) （重点）<br>A中华人民共和国国务院即中央人民政府B国家主席C中央军事委员会D最高法院院长。<br>7、民法是调整（）主体的公民之间、法人之间以及公民和法人之间的财产关系和人身关系的法律规范的总和。(C) （重点）<br>A不平等  B不同层次  C平等  D差异<br>19、我国行政法的基本原则(B)<br>A行政人员自主原则  B依法行政或行政法治原则，可分解为行政合法性原则和行政合理性原则等。<br>C行政首长自主原则  D灵活性原则。<br>20、国家权力机关的执行机关是(A) （重点）<br>A国家行政机关 B国家司法机关 C国家检察机关 D国家公安机关<br>23、犯罪客体指我国刑法所保护的而为犯罪行为所危害的()(C) （重点）<br>A人   B物     C社会关系     D利益<br>24、民事诉讼简易程序，是简化了的普通程序，是基层人民法院及其派出法庭审理（）所运用的一种独立的简便易行的诉讼程序。(A) A简单民事案件 B所有民事案件  C复杂民事案件 D一般民事案件<br>27、行政诉讼是指公民、法人和其他组织认为（）具体行政行为侵犯其合法权益，依法向人民法院提起诉讼，并由人民法院进行审理和裁判的一种诉讼活动。(B)<br>A公民B行政机关或行政机关工作人员C法人D其他组织<br>37、下列属于诉讼内调解是（D）<br>A自我调解 B人民调解 C行政调解  D司法调解<br>38、我国宪法的修改由全国人民代表大会常务委员会或者1／5以上的全国人民代表大会代表提议，并由全国人民代表大会以全体代表的（）以上的多数通过，而普通法律则只需要全国人民代表大会以全体代表的过半数通过。(A)<br>A2／3  B4&#x2F;5  C1&#x2F;2  D5&#x2F;6<br>39、人民当家作主最有效、最广泛的途径是（A）<br>A基层群众自治 B人民代表大会 C言论出版自由  D民族区域自治<br>40、公司是企业法人，有独立的法人财产，享有法人财产权，以其（）对公司的债务承担责任。（A）<br>A全部财产B注册资金C先由全部财产赔偿，不足由股东个人财产赔偿D部分财产<br>二、多项选择(ABCD)<br>1、宪法的特征有哪些？(ABC) （重点）<br>A在内容上，宪法规定国家生活中最根本最重要的方面。B在效力上，宪法的法律效力最高。<br>C在制定和修改程序上，宪法比其他法律更为严格。D我国宪法没有制裁条款。<br>2、宪法的基本原则有哪些？(ABCDE) （重点）<br>A党的领导原则。B人民主权原则。人民当家作主是社会主义民主政治的本质和核心。<br>C公民权利原则。D法治原则。<br>E民主集中制原则。<br>3、依法治国的根本要求是(ABCD) （重点）<br>A有法可依 B有法必依 C执法必严 D违法必究<br>4、国家制度是一个国家的统治阶级通过宪法、法律规定的有关（）方面的制度的总称。 (CD) （重点）<br>A国家政策B国家权力C国家性质D国家形式<br>5、我国的国家制度包括(ABCDE)<br>A人民民主专政制度；B人民代表大会制度；<br>C中国共产党领导的多党合作和政治协商制度；D民族区域自治制度；<br>E基层群众自治制度；F基本经济制度等。<br>6、爱国统一战线具体包括以下范围的联盟(BC)<br>A海外华侨。<br>B我国大陆范围内，由全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者所组成的政治联盟。<br>C广泛地团结台湾同胞、港澳同胞和国外侨胞，以拥护祖国统一为基础的政治联盟。<br>D支持中国建设的外国人。<br>7、目前我国爱国统一战线的任务是(BCD)<br>A团结全世界无产者实现共产主义。B为社会主义现代化建设服务，<br>C为实现祖国统一大业服务，D为维护世界和平服务。<br>8、为什么我国选择人民代表大会制度？(ABCD)<br>A人民代表大会制度是我们党把马克思主义基本原理同中国具体实际相结合的伟大创造。<br>B人民代表大会制度是近代以来中国社会发展的必然选择。<br>C人民代表大会制度是中国共产党带领全国各族人民长期奋斗的重要成果。<br>D人民代表大会制度反映了全国各族人民的共同利益和共同愿望。<br>9、我国人民代表大会制度有哪些优越性？(ABCD)<br>A人民代表大会制度保障了人民当家作主。<br>B人民代表大会制度有利于调动人民群众建设社会主义的积极性、主动性、创造性。<br>C人民代表大会制度保证了国家机关协调高效运转。<br>D人民代表大会制度有利于维护国家统一和民族团结。<br>10、我国的基本经济制度是(ABC) （重点）<br>A我国社会主义经济制度的基础是生产资料的社会主义公有制，即全民所有制和劳动群众集体所有制。<br>B社会主义公有制消灭人剥削人的制度，实行各尽所能、按劳分配的原则。<br>C国家在社会主义初级阶段，坚持公有制为主体、多种所有制经济共同发展的基本经济制度，坚持按劳分配为主体、多种分配方式并存的分配制度。<br>D生产资料的社会主义私有制。<br>11、我国社会主义公有制的基本形式是(CD) （重点）<br>A私有经济。B多种经济形式。C全民所有制。D劳动群众集体所有制。<br>12、我国公民的基本权利中的政治权利和自由包括(CD) （重点）<br>A宗教信仰自由。B人身自由。C选举权和被选举权。D政治自由。<br>13、人身自由权包括(ABC) （重点）<br>A人格尊严B住宅不受侵犯<br>C通信自由和通信秘密受法律保护等与公民个人生活有关的权利和自由。D任意行为。<br>14、社会经济权包括(ABCD) （重点）<br>A财产权。B劳动权。C休息权。D物质帮助权。<br>15、我国的国家机构有(ABCDEF)<br>A全国人民代表大会 B中华人民共和国主席 C国务院 D中央军事委员会<br>E地方各级人民代表大会和地方各级人民政府、民族自治地方的自治机关<br>F人民法院与人民检察院。<br>16、下列属于全国人民代表大会和全国人民代表大会常务委员会的职权的是(ABCD) （重点）<br>A行使国家立法权。  B选举、决定和罢免国家机关领导人。<br>C决定国家重大事项。 D监督其他国家机关的工作等。<br>20、专门人民法院包括(ABC)<br>A军事法院B海事法院C铁路运输法院D农业法院<br>25、民法基本原则主要有：(ABCDE)<br>A平等原则。B自愿原则。C公平原则。D诚实信用原则。E禁止权利滥用原则。<br>26、我国的民事主体有(ABC) （重点）<br>A公民(自然人)B法人C其他组织D无民事责任能力的人<br>79、我国《刑法》所规定的刑罚体系由(AB) （重点）<br>A主刑B附加刑C精神刑D肉体刑<br>80、主刑是指对犯罪分子独立适用的主要刑罚方法，包括(ABCD) （重点）<br>A管制B拘役C有期徒刑D无期徒刑与死刑<br>81、附加刑是指补充主刑适用的刑罚方法。它既可以作为主刑的附加刑，也可以独立适用。《刑法》规定的附加刑有(ABCD) （重点）<br>A罚金B剥夺政治权利C没收财产D适用于犯罪的外国人的驱逐出境<br>82、我国的程序法律制度主要包括(BCD)<br>A商事诉讼法律制度B民事诉讼法律制度C行政诉讼法律制度D刑事诉讼法律制度<br>112、我国宪法的修改可以由（）提议，（A B）（重点）<br>A全国人民代表大会常务委员会B1／5以上的全国人民代表大会代表C国务院D<br>113、人民主权原则在宪法中的表现是多方面的。（ABCD）<br>A宪法通过确认我国人民民主专政的国体，保障了广大人民群众在国家中的主人翁地位；<br>B通过确认以公有制为主体、多种所有制经济共同发展的基本经济制度，为人民当家作主奠定了经济基础；<br>C通过确认人民代表大会制度的政体，为人民当家作主提供了组织保障；<br>D通过确认广大人民依照法律规定，通过各种途径和形式，管理国家事务，管理经济和文化事业，管理社会事务的权利，把人民当家作主贯彻于国家和社会生活各个领域。</p><p>1、我国的人民民主专政制度是怎样的？<br>人民民主专政是我国的国体。国体即国家性质，是国家的阶级本质，是指社会各阶级在国家生活中的地位和作用。我国《宪法》第1条规定：“中华人民共和国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。”爱国统一战线是人民民主专政的重要保障。这个统一战线具体包括两个范围的联盟：一是我国大陆范围内，由全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者所组成的政治联盟；二是广泛地团结台湾同胞、港澳同胞和国外侨胞，以拥护祖国统一为基础的政治联盟。<br>4、如何理解民族区域自治制度？<br>民族区域自治制度是我国为解决民族问题，处理民族关系，实现民族平等、民族团结、各民族共同繁荣发展而建立的基本政治制度。根据《宪法》和《民族区域自治法》的规定，民族区域自治是在国家统一领导下，各少数民族聚居的地方实行区域自治，设立自治机关，行使自治权；各民族自治地方都是中华人民共和国不可分离的部分，各民族自治地方的自治机关都是中央统一领导下的地方政权机关；民族区域自治必须以少数民族聚居区为基础，是民族自治与区域自治的结合；民族自治地方的自治机关行使宪法规定的地方国家机关的职权，同时依照宪法和法律规定的权限行使自治权，根据本地方实际情况贯彻执行国家的法律、政策。<br>5、如何理解基层群众自治制度？<br>党的十七大报告将基层群众自治制度与人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度并列，纳入中国特色社会主义政治制度范畴。基层群众自治制度是城乡基层群众在党的领导下，依法直接行使民主权利，管理基层公共事务和公益事业，实行自我管理、自我服务、自我教育、自我监督的一项重要政治制度。基层群众自治是基层民主的主要实现形式，是人民当家作主最有效、最广泛的途径，其目的就是要把城乡社区建设成为管理有序、服务完善、文明祥和的社会生活共同体。我国已经建立了农村村民委员会、城市居民委员会等基层群众自治组织。<br>我国《宪法》以及《城市居民委员会组织法》、《村民委员会组织法》等法律为基层群众自治制度奠定了法律基础。<br>6、我国公民的基本权利有哪些？<br>第一，平等权。第二，政治权利和自由。一是选举权和被选举权。二是政治自由。政治自由主要是指公民表达自己政治意愿的自由。我国《宪法》规定：“中华人民共和国公民有言论、出版、集会、结社、游行、*****的自由。”第三，宗教信仰自由。<br>第四，人身自由权。人格尊严、住宅不受侵犯、通信自由和通信秘密受法律保护等与公民个人生活有关的权利和自由。<br>第五，批评、建议、申诉、控告、检举权和取得国家赔偿权。第六，社会经济权。一是财产权，二是劳动权，三是休息权，四是物质帮助权。第七，文化教育权。公民的文化教育权包括受教育权以及进行科学研究、文学艺术创作和其他文化活动的自由。<br>第八，特定主体权利。我国《宪法》对特定主体设置专条，给予特定保护。这些特定主体具体是指妇女、离退休人员、军烈属、母亲、儿童、老人、青少年、华侨等。<br>7、我国公民的基本义务有哪些？<br>第一，维护国家统一和全国各民族团结。国家的统一和民族的团结是我国社会安定和谐的前提和保证，是我国公民的最高法律义务。第二，遵守宪法和法律。我国《宪法》规定：“中华人民共和国公民必须遵守宪法和法律，保守国家秘密，爱护公共财产，遵守劳动纪律，遵守公共秩序，尊重社会公德。”第三，维护祖国的安全、荣誉和利益。第四，保卫祖国、依法服兵役和参加民兵组织。第五，依法纳税。第六，其他义务。除上述义务外，我国《宪法》还规定，夫妻双方有实行计划生育的义务，父母有抚养教育未成年子女的义务，成年子女有赡养扶助父母的义务。<br>11、人民代表大会制度在实践中显示出强大的生命力和巨大的优越性：<br>第一，人民代表大会制度保障了人民当家作主。第二，人民代表大会制度有利于调动人民群众建设社会主义的积极性、主动性、创造性。第三，人民代表大会制度保证了国家机关协调高效运转。第四，人民代表大会制度有利于维护国家统一和民族团结。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思想道德与法制&quot;&gt;&lt;a href=&quot;#思想道德与法制&quot; class=&quot;headerlink&quot; title=&quot;思想道德与法制&quot;&gt;&lt;/a&gt;思想道德与法制&lt;/h1&gt;&lt;p&gt;该总结融合三个总结文档，标题后数字是被考次数，全篇手打，如果有错字错意，感谢联系我（qq：17687</summary>
      
    
    
    
    
    <category term="思想道德与法制 思修" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E5%88%B6-%E6%80%9D%E4%BF%AE/"/>
    
  </entry>
  
  <entry>
    <title>离散数学复习</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2023/02/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2023/02/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-02-02T16:00:00.000Z</published>
    <updated>2023-03-07T13:58:06.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散数学复习"><a href="#离散数学复习" class="headerlink" title="离散数学复习"></a>离散数学复习</h1><p>[TOC]</p><h2 id="数理逻辑"><a href="#数理逻辑" class="headerlink" title="数理逻辑"></a>数理逻辑</h2><h3 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h3><h4 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h4><p>（1）原子命题（不包含任何联结词）；（2）复合命题；</p><h4 id="命题标识符"><a href="#命题标识符" class="headerlink" title="命题标识符"></a>命题标识符</h4><p>（A，Ai，[12]）（1）确定—&gt;命题常量；（2）不确定—&gt;命题变元（不是命题）（标题原子命题，可称为原子变元）；</p><h4 id="联结词"><a href="#联结词" class="headerlink" title="联结词"></a>联结词</h4><table><thead><tr><th>联结词</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>合取（可兼或）</td><td>∧</td><td>析取</td><td>∨</td></tr><tr><td>否定</td><td>¬</td><td>（一元运算）</td><td></td></tr><tr><td>条件（前件&#x2F;前提，后件）</td><td>⇒</td><td>双条件</td><td>↔&#x2F;iff</td></tr><tr><td>不可间或&#x2F;异或</td><td><strong>⊽</strong></td><td></td><td></td></tr><tr><td>条件否定</td><td><img src="C:\Users\17687\Desktop\HexoBlog\assets\7ce0a65c91daf4b5972fa52d074653e.png" alt="7ce0a65c91daf4b5972fa52d074653e"></td><td></td><td></td></tr><tr><td>与非</td><td><img src="C:\Users\17687\Desktop\HexoBlog\assets\98c600051d233f4993d2eb270045a71.png" alt="98c600051d233f4993d2eb270045a71"></td><td>或非</td><td><img src="C:\Users\17687\Desktop\HexoBlog\assets\56f7c78d0b8aa08fd6acb475e23859d.png" alt="56f7c78d0b8aa08fd6acb475e23859d"></td></tr></tbody></table><p>优先顺序：否定，合取，析取，条件，双条件；</p><p>表1-4.8</p><table><thead><tr><th align="center">命题定律</th><th>表达式</th><th>序号</th></tr></thead><tbody><tr><td align="center">对合律</td><td>¬¬P⇔P</td><td>1</td></tr><tr><td align="center">幂等律</td><td>P∨P⇔P,P∧P⇔P</td><td>2</td></tr><tr><td align="center">结合律</td><td>(P∨Q)∨R⇔P∨(Q∨R)</td><td>3</td></tr><tr><td align="center">交换律</td><td>P∨Q⇔Q∨P</td><td>4</td></tr><tr><td align="center">分配律</td><td>P∨(Q∧R)⇔(P∨Q)∧(P∨R)</td><td>5</td></tr><tr><td align="center">吸收律</td><td>(P∨Q)∧P⇔P;(P∧Q)∨P⇔P</td><td>6</td></tr><tr><td align="center">德摩根律</td><td>¬(P∨Q)⇔¬P∧¬Q</td><td>7</td></tr><tr><td align="center">同一律</td><td>P∨F⇔P</td><td>8</td></tr><tr><td align="center">零律</td><td>P∨T⇔T</td><td>9</td></tr><tr><td align="center">否定律</td><td>P∨¬P⇔T;P∧¬P⇔F</td><td>10</td></tr></tbody></table><h4 id="命题公式："><a href="#命题公式：" class="headerlink" title="命题公式："></a>命题公式：</h4><h5 id="重言式-x2F-永真式；矛盾式-x2F-永假式；可满足式；"><a href="#重言式-x2F-永真式；矛盾式-x2F-永假式；可满足式；" class="headerlink" title="重言式&#x2F;永真式；矛盾式&#x2F;永假式；可满足式；"></a>重言式&#x2F;永真式；矛盾式&#x2F;永假式；可满足式；</h5><p>判断方法：（1）真值表；（2）等值演算法；</p><h5 id="蕴含式（⇒）："><a href="#蕴含式（⇒）：" class="headerlink" title="蕴含式（⇒）："></a>蕴含式（⇒）：</h5><p>要证P⇒Q，即证P—&gt;Q是重言式，或证其逆反式是重言式即可。</p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\2fe8326492bf454414a0039df658692.png" alt="2fe8326492bf454414a0039df658692"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\8922aaf5d2d66c0595421ed13ed0b71.png" alt="8922aaf5d2d66c0595421ed13ed0b71"></p><h5 id="对偶式："><a href="#对偶式：" class="headerlink" title="对偶式："></a>对偶式：</h5><p>反过来</p><h5 id="泛式：（合取范式，析取范式，主范式（小项-x2F-布尔合取）（主析取范式）（大项）（主合取范式））"><a href="#泛式：（合取范式，析取范式，主范式（小项-x2F-布尔合取）（主析取范式）（大项）（主合取范式））" class="headerlink" title="泛式：（合取范式，析取范式，主范式（小项&#x2F;布尔合取）（主析取范式）（大项）（主合取范式））"></a>泛式：（合取范式，析取范式，主范式（小项&#x2F;布尔合取）（主析取范式）（大项）（主合取范式））</h5><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\c97026723b705cf3df18948f76f55b6.png" alt="c97026723b705cf3df18948f76f55b6"></p><h3 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h3><h5 id="客体-x2F-个体："><a href="#客体-x2F-个体：" class="headerlink" title="客体&#x2F;个体："></a>客体&#x2F;个体：</h5><p>可以独立存在的具体事务或抽象概念</p><h5 id="客体常元："><a href="#客体常元：" class="headerlink" title="客体常元："></a>客体常元：</h5><p>表示具体或特定的客体abc</p><h5 id="客体变元："><a href="#客体变元：" class="headerlink" title="客体变元："></a>客体变元：</h5><p>表示抽象或泛指的客体xyz</p><h5 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h5><h5 id="谓词表达式"><a href="#谓词表达式" class="headerlink" title="谓词表达式"></a>谓词表达式</h5><h5 id="个体域（在命题函数中，命题变元的论述范围）"><a href="#个体域（在命题函数中，命题变元的论述范围）" class="headerlink" title="个体域（在命题函数中，命题变元的论述范围）"></a>个体域（在命题函数中，命题变元的论述范围）</h5><h5 id="全总个体域（个体域综合在一起，作为论述范围的域，称为全总个体域）"><a href="#全总个体域（个体域综合在一起，作为论述范围的域，称为全总个体域）" class="headerlink" title="全总个体域（个体域综合在一起，作为论述范围的域，称为全总个体域）"></a>全总个体域（个体域综合在一起，作为论述范围的域，称为全总个体域）</h5><p>量词（全称，特称</p><h5 id="特性谓词（"><a href="#特性谓词（" class="headerlink" title="特性谓词（"></a>特性谓词（</h5><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\c2dc3629cc0f89ddd7302a37f2a8bc8.png" alt="c2dc3629cc0f89ddd7302a37f2a8bc8"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\592239fae5a4c57173645914d8bc0b3.png" alt="592239fae5a4c57173645914d8bc0b3"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\e171874b6686da023ecf9ef5e1660e3.png"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\806551d7585fd837e57951bf281ae63.png" alt="32925e2a606376dfc8de0ed354d9a66"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\750320eb62ff65c2f7702ad9b83282e.png" alt="750320eb62ff65c2f7702ad9b83282e"></p><h5 id="谓词公式："><a href="#谓词公式：" class="headerlink" title="谓词公式："></a>谓词公式：</h5><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\0a2068ea8480b5677cf9d7975914cf9.png" alt="0a2068ea8480b5677cf9d7975914cf9"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\1d9d396230d9df121826d59bbfdc92d.png" alt="1d9d396230d9df121826d59bbfdc92d"></p><h5 id="变元约束（指导变元-x2F-作用变元，作用域-x2F-量词辖域，约束变元，自由变元，代入规则"><a href="#变元约束（指导变元-x2F-作用变元，作用域-x2F-量词辖域，约束变元，自由变元，代入规则" class="headerlink" title="变元约束（指导变元&#x2F;作用变元，作用域&#x2F;量词辖域，约束变元，自由变元，代入规则"></a>变元约束（指导变元&#x2F;作用变元，作用域&#x2F;量词辖域，约束变元，自由变元，代入规则</h5><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\30142e27c294883fded59937def532b.png" alt="30142e27c294883fded59937def532b"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\68bbc8aca956eeb51e7f76252ca0b5b.png" alt="68bbc8aca956eeb51e7f76252ca0b5b"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\450ed9d6621d37248c10229e686bf0c.png" alt="450ed9d6621d37248c10229e686bf0c"></p><p>约束换辖域，自由全代换</p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\90ca12404cd07f16df76ff55189c3b8.png" alt="90ca12404cd07f16df76ff55189c3b8"></p><h4 id="谓词演算等价式与蕴含式"><a href="#谓词演算等价式与蕴含式" class="headerlink" title="谓词演算等价式与蕴含式"></a>谓词演算等价式与蕴含式</h4><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\5f806084057fafefcc925c60ac78e07.png" alt="5f806084057fafefcc925c60ac78e07"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\699b9d7ea086c1483d2258a7eebb660.png" alt="699b9d7ea086c1483d2258a7eebb660"></p><h5 id="量词辖域的扩张和收缩"><a href="#量词辖域的扩张和收缩" class="headerlink" title="量词辖域的扩张和收缩"></a>量词辖域的扩张和收缩</h5><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\395095185fc510b17596a19376490bf.png" alt="395095185fc510b17596a19376490bf"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\6bfae34ce0208d402bdb6aec4427263.png" alt="6bfae34ce0208d402bdb6aec4427263"></p><h5 id="量词与命题联结词之间的一些等价式"><a href="#量词与命题联结词之间的一些等价式" class="headerlink" title="量词与命题联结词之间的一些等价式"></a>量词与命题联结词之间的一些等价式</h5><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\e2702f15fd2b33dac1d06a7b853ded2.png" alt="e2702f15fd2b33dac1d06a7b853ded2"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\59f16e11bd5fa6018ef5f5aa52cedcc.png" alt="59f16e11bd5fa6018ef5f5aa52cedcc"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\3ab478d2dd741894f563e2ed124ca04.png" alt="3ab478d2dd741894f563e2ed124ca04"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\4b22050289f8812381e570b295ef9dd.png" alt="4b22050289f8812381e570b295ef9dd"></p><h4 id="前束范式"><a href="#前束范式" class="headerlink" title="前束范式"></a>前束范式</h4><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\86d083ce01e15fa6429965c58468f70.png" alt="86d083ce01e15fa6429965c58468f70"></p><h5 id="前束合取范式"><a href="#前束合取范式" class="headerlink" title="前束合取范式"></a>前束合取范式</h5><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\ec41bd94fcfb65543ad767ee6d358ac.png" alt="ec41bd94fcfb65543ad767ee6d358ac"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\e1846e5ce0209b49dff00823f845a23.png" alt="e1846e5ce0209b49dff00823f845a23"></p><h5 id="前束析取范式"><a href="#前束析取范式" class="headerlink" title="前束析取范式"></a>前束析取范式</h5><h4 id="谓词演算的推理理论"><a href="#谓词演算的推理理论" class="headerlink" title="谓词演算的推理理论"></a>谓词演算的推理理论</h4><p>在谓词逻辑中，如果A1∧A2∧…∧An→B是逻辑有效式，则称B是A1,  A2, …，An的有效结论，记作A1∧A2∧…∧AnBAB 当且仅当 AB是重言式</p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\5efa3a2a8bf14f6f69514c6f2599d7a.png" alt="5efa3a2a8bf14f6f69514c6f2599d7a"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\ac71caf027a916bb14a7572fc7f83d3.png" alt="ac71caf027a916bb14a7572fc7f83d3"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\4d0c8929c739e3097cf8d511c50184b.png" alt="4d0c8929c739e3097cf8d511c50184b"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\26f56ee34b46bca6c4a2e25724bfcb6.png" alt="26f56ee34b46bca6c4a2e25724bfcb6"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\assets\c2fedbb490e59083c226dd8d25fd44f.png" alt="c2fedbb490e59083c226dd8d25fd44f"></p><h2 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h2><h3 id="集合与关系"><a href="#集合与关系" class="headerlink" title="集合与关系"></a>集合与关系</h3><p>集合分类</p><h5 id="集合悖论与公理："><a href="#集合悖论与公理：" class="headerlink" title="集合悖论与公理："></a>集合悖论与公理：</h5><p>外延公理（相等），空集存在公理，子集公理模式</p><p>交集，并集，差运算（相对补），绝对补运算，对称差运算，幂运算，</p><p>证明：</p><h4 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h4><h5 id="序偶"><a href="#序偶" class="headerlink" title="序偶"></a>序偶</h5><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积<img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\b8276bfd37377f02f950de8ea9ceef5.png" alt="b8276bfd37377f02f950de8ea9ceef5"></h5><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\e5b14c5a452599a408dcec2fb3465c6.png" alt="e5b14c5a452599a408dcec2fb3465c6"></p><h5 id="空关系，全域关系，恒等关系"><a href="#空关系，全域关系，恒等关系" class="headerlink" title="空关系，全域关系，恒等关系"></a>空关系，全域关系，恒等关系</h5><h4 id="关系运算："><a href="#关系运算：" class="headerlink" title="关系运算："></a>关系运算：</h4><p>dom定义域，ran值域，fld&#x3D;dom U ran域；</p><h5 id="逆运算"><a href="#逆运算" class="headerlink" title="逆运算"></a>逆运算</h5><p>每个序偶交换位置，逆关系</p><h4 id="交叉划分与加细"><a href="#交叉划分与加细" class="headerlink" title="交叉划分与加细"></a>交叉划分与加细</h4><h5 id="等价关系，商集"><a href="#等价关系，商集" class="headerlink" title="等价关系，商集"></a>等价关系，商集<img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\aa319fb4d78c26eb3fa6932744e0fb1.png" alt="aa319fb4d78c26eb3fa6932744e0fb1"></h5><p>等价：对称</p><p>偏序：反对称性</p><p>盖住：2，4，8，8没盖住2</p><p>全序关系</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h2 id="代数系统"><a href="#代数系统" class="headerlink" title="代数系统"></a>代数系统</h2><h3 id="代数结构"><a href="#代数结构" class="headerlink" title="代数结构"></a>代数结构</h3><p><strong>闭运算</strong>：运算结果在原来的集合R种</p><p><strong>n元运算</strong>：从A^n到B的映射</p><p><strong>代数系统：</strong>一个非空集合A连同若干个定义在该集合上的运算所组成的系统就称为一个代数系统，记作：&lt;A,f1,…fk&gt;.</p><p><strong>吸收律</strong></p><p><strong>运算等幂</strong>：如果对于任意的x属于A，都有x*x&#x3D;x，则称运算*是等幂的或称满足等幂律。</p><p><strong>幺元，零元</strong>：（幺元e，零元；幺元不一定是1，也可能是0；<img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\e54ccd76645ac8565bd79789939186f.png" alt="e54ccd76645ac8565bd79789939186f"></p><p><strong>逆元</strong>：b*a&#x3D;e</p><p><strong>且每个元素的逆元是唯一的</strong></p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\d67526c09597edb597d8754baf5dc32.png" alt="d67526c09597edb597d8754baf5dc32"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\097386cda1ddad029b37fa82d7bef83.png" alt="097386cda1ddad029b37fa82d7bef83"></p><p>难以理解：</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\d6133f1ac1cb3ac335e9c1278604c3b.png" alt="d6133f1ac1cb3ac335e9c1278604c3b"></p><h5 id="类群：（广群》半群》独异点》群）"><a href="#类群：（广群》半群》独异点》群）" class="headerlink" title="类群：（广群》半群》独异点》群）"></a>类群：（广群》半群》独异点》群）</h5><p><strong>广群</strong>：（非空，二元，封闭）<img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\1e566683720f24b6438827f1be736df.png" alt="1e566683720f24b6438827f1be736df"></p><p><strong>半群</strong>：封闭、可结合、eg：</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\10d5b7503524ff7dfc1cd056bcf9794.png" alt="10d5b7503524ff7dfc1cd056bcf9794"></p><p><strong>子半群</strong>：&lt;S,*&gt;是半群，&lt;B,*&gt;是半群，且B属于S，则后者为前者的子半群</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\171918138c93b7a5f8e271f0999afc8.png" alt="171918138c93b7a5f8e271f0999afc8"></p><p><strong>独异点</strong>：含有幺元的半群称为独异点（封闭、可结合、有幺元）</p><p>含有独异点的运算表种任何两行或者两列都是不相同的</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\a42ea1f086135a10d63b357756b53ca.png" alt="a42ea1f086135a10d63b357756b53ca"></p><p><strong>群</strong>：封闭、可结合、幺元e、每个元素都存在它的逆元</p><p><strong>不可能有零元</strong>，唯一等幂元-幺元e、满足消去律、a*x&#x3D;b、每行&#x2F;列都是G的置换</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\661ef82f43b10eb5e976b5f7ef3dcd2.png" alt="661ef82f43b10eb5e976b5f7ef3dcd2"></p><p><strong>有限群、无限群：</strong></p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\f88c83d61ca003cd974604a933ff7d7.png" alt="f88c83d61ca003cd974604a933ff7d7"></p><p><strong>置换</strong>：一一对应</p><p><strong>等幂元：</strong> 代数系统&lt;G,*&gt;中，a属于G，a*a&#x3D;a，称a为等幂元；</p><p>群中除幺元e外，不可能有任何别的等幂元</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\8561f9c48069632fcc6f347199dbcef.png" alt="8561f9c48069632fcc6f347199dbcef"></p><p><strong>平凡子群</strong>：S&#x3D;{e}或者S&#x3D;G</p><p><strong>阿贝尔群&#x2F;交换群</strong>：</p><p><strong>循环群</strong>：设&lt;G,*&gt;若在G中存在一个元素a **使得G中的任意元素都由a的幂组成，则称该群为循环群，元素a称为循环群G生成元.</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\fc28187b313cb6b6e66b57bd71af910.png" alt="fc28187b313cb6b6e66b57bd71af910"></p><p><strong>群中元素的阶</strong>：设a为群G的一个元素，使得a^n&#x3D;e的最小正整数n，叫做元素a的阶</p><p>如果这样 的n不存在，则称a的阶为无限&#x2F;称是0；</p><p>元素a的阶常用|a|表示</p><p>有限群中每个元素的阶均有限</p><p><strong>任何一个循环群必是阿贝尔群</strong>；****</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\262419da2aa5bfa1f5e12f7e393cbdf.png" alt="262419da2aa5bfa1f5e12f7e393cbdf"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\d08facad1091c19b1b379d7b09422dd.png" alt="d08facad1091c19b1b379d7b09422dd"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\a236f24c7b2f27c514d4f6d976460de.png" alt="a236f24c7b2f27c514d4f6d976460de"></p><h5 id="陪集"><a href="#陪集" class="headerlink" title="陪集"></a>陪集</h5><p>![46661851cec5abc3adb1102bf386244](C:\Users\17687\AppData\Local\Temp\WeChat Files\46661851cec5abc3adb1102bf386244.png)</p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\6cad1241b324ba07194021e14bd8516.png" alt="6cad1241b324ba07194021e14bd8516"></p><p><strong>看不懂！</strong></p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\8cf8544a220dd6ed3ef35194e960690.png" alt="8cf8544a220dd6ed3ef35194e960690"></p><p>关系是序偶的集合。</p><h4 id="序偶："><a href="#序偶：" class="headerlink" title="序偶："></a>序偶：</h4><p>次序不能随意调换</p><h4 id="关系及其表示："><a href="#关系及其表示：" class="headerlink" title="关系及其表示："></a>关系及其表示：</h4><p>关系是序偶得集合，xRy，x<del>R</del>y</p><h4 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h4><p>质数阶群必是循环群</p><p>证明循环群： - 定义  - 生成一个  - 同构思想</p><h3 id="格与布尔代数"><a href="#格与布尔代数" class="headerlink" title="格与布尔代数"></a><strong>格与布尔代数</strong></h3><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h3><p>无向图，有向图；点，边，特殊的图；顶点的度；补图与自补图；子图，生成子图和导出子图；图的同构</p><h3 id="路："><a href="#路：" class="headerlink" title="路："></a>路：</h3><ul><li>回路，长度；</li><li>边不同 - 迹；结点不同 - 通路&#x2F;圈</li><li>两点间的最短路的长度：两点间的距离</li><li>图中任意两点间的距离的最大值 ，称为图的直径</li></ul><h3 id="无向图连通性："><a href="#无向图连通性：" class="headerlink" title="无向图连通性："></a>无向图连通性：</h3><p>两结点连通关系是一个等价关系（自反对称，传递</p><p>可以划分出若干个等价类</p><p>每个等价类中的结点中都是互相连通的，而等价类之间的结点互不连通</p><p>每一个等价类的点导出子图，称为原图的一个连通分支，图的连通分支数记为W（G）</p><p><strong>只有一个连通分支的图，称为连通图</strong></p><h5 id="连通程度："><a href="#连通程度：" class="headerlink" title="连通程度："></a>连通程度：</h5><p><strong>点割集</strong>  <strong>割点</strong></p><p><strong>点连通度（或连通度）</strong></p><ul><li>G不完全图，min{|V1||V1是G的点割集}；</li><li>G完全图：p-1；</li><li>G不连通，k&#x3D;0；</li></ul><p><strong>边割集</strong>   <strong>割边（桥</strong></p><p><strong>边连通度</strong></p><ul><li>非平凡图，min</li><li>平凡图 0</li><li>不连通，0</li></ul><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20230307162819212.png" alt="image-20230307162819212"></p><p>割点每条路都得经过</p><h5 id="有向图的连通性"><a href="#有向图的连通性" class="headerlink" title="有向图的连通性"></a>有向图的连通性</h5><p><strong>可达</strong>  <strong>相互可达</strong></p><p><strong>弱连通</strong> 基图为连通图</p><p> <strong>单连通</strong> 任意两点可达</p><p> <strong>强连通</strong>：任意两点相互可达</p><p> <strong>强连通分支</strong>  <strong>弱连通分支</strong> （子图们）</p><h3 id="连通性计算：割点的应用及求法"><a href="#连通性计算：割点的应用及求法" class="headerlink" title="连通性计算：割点的应用及求法"></a>连通性计算：割点的应用及求法</h3><p><strong>结构洞</strong>（割点是结构洞的典型情况）</p><p>Tarjan算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">index = 0          // 全局索引计数器</span><br><span class="line">stack = []         // 存储当前访问路径上的所有节点</span><br><span class="line">scc_list = []      // 存储所有强连通分量</span><br><span class="line"></span><br><span class="line">function tarjan(u):</span><br><span class="line">    u.index = index        // 为当前节点设置全局索引</span><br><span class="line">    u.lowlink = index      // 初始时，当前节点的 lowlink 值等于索引值</span><br><span class="line">    index = index + 1      // 索引值自增</span><br><span class="line"></span><br><span class="line">    stack.push(u)          // 将当前节点压入栈中</span><br><span class="line"></span><br><span class="line">    for each v in neighbors of u:</span><br><span class="line">        if v.index is undefined:       // 如果 v 还没有被访问过</span><br><span class="line">            tarjan(v)                  // 递归访问 v</span><br><span class="line">            u.lowlink = min(u.lowlink, v.lowlink)   // 更新当前节点的 lowlink 值</span><br><span class="line">        else if v is in stack:         // 如果 v 在当前访问路径上</span><br><span class="line">            u.lowlink = min(u.lowlink, v.index)     // 更新当前节点的 lowlink 值</span><br><span class="line"></span><br><span class="line">    if u.lowlink == u.index:          // 如果当前节点是强连通分量的根节点</span><br><span class="line">        scc = []                      // 新建一个强连通分量</span><br><span class="line">        while True:</span><br><span class="line">            v = stack.pop()           // 从栈中弹出节点</span><br><span class="line">            scc.add(v)                // 将节点加入当前强连通分量</span><br><span class="line">            if v == u:</span><br><span class="line">                break               // 找到当前强连通分量中的所有节点</span><br><span class="line">        scc_list.add(scc)            // 将当前强连通分量加入列表中</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="领接矩阵："><a href="#领接矩阵：" class="headerlink" title="领接矩阵："></a>领接矩阵：</h3><p>求n步从a到b的方法数（求指定长度的路的数目</p><h3 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h3><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\060b60a575cca6b53d6538268e0577c.png" alt="060b60a575cca6b53d6538268e0577c"></p><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\8cf8544a220dd6ed3ef35194e960690.png" alt="8cf8544a220dd6ed3ef35194e960690"></p><h5 id="关联矩阵的应用：结点的合并（边收缩）"><a href="#关联矩阵的应用：结点的合并（边收缩）" class="headerlink" title="关联矩阵的应用：结点的合并（边收缩）"></a>关联矩阵的应用：结点的合并（边收缩）</h5><p>r阶连通图的关联矩阵的秩为r-1</p><h3 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h3><p>欧拉路：通过途中所有边一次且仅一次的迹</p><p>半欧拉图：具有欧拉路而无欧拉回路的图</p><p>欧拉回路：通过途中所有边一次且仅一次的闭迹</p><p>欧拉图：具有欧拉回路的图</p><h5 id="判断："><a href="#判断：" class="headerlink" title="判断："></a>判断：</h5><ul><li>所有顶点的度数都是偶数（边不重复</li><li>有且仅有两个奇度结点（一个出度大一一个入度大一）</li><li>由若干个不重边的圈组成</li><li>Fleury算法：<ul><li>任取一个起点v</li><li>设已经过的边的集合为E‘，则按照以下原则选择下一条边e：</li></ul></li></ul><h3 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h3><p>哈密尔顿路：一条经过G的每一个结点恰好一次的路</p><p>半哈密尔顿图：具有哈密尔顿路的图</p><p>哈密尔顿回路：一条经过图G的每一个结点恰好一次的回路</p><p>哈密尔顿图：具有哈密尔顿回路的图</p><ul><li>若G具有哈密尔顿回路，则对于结点集V的每一个非空子集S均有W（G-S）&lt;&#x3D;|S|成立，其中W（G-S）是G-S中连通分支数</li><li>哈密尔顿图的必要条件</li><li>逆否命题是判断非哈密尔顿图的充分条件</li><li>半哈密尔顿图充分条件：对于n阶图，如果G的每一对结点的度数之和都不小于n-1,那么G中有一条哈密尔顿通路</li><li>哈密尔顿图充分条件：对于n阶图，如果G的每一对结点的度数之和不小于n，那么G为一哈密尔顿图</li></ul><h3 id="平面图："><a href="#平面图：" class="headerlink" title="平面图："></a>平面图：</h3><ul><li>所有面的次数之和为边数的二倍</li><li>v-e+r&#x3D;p+1（vertex，edge，面，连通分支数）</li><li>v&gt;&#x3D;3,e&lt;&#x3D;3v-6;</li></ul><h3 id="同胚："><a href="#同胚：" class="headerlink" title="同胚："></a>同胚：</h3><p>插入 删除 </p><p>库拉图斯基定理</p><h3 id="图的着色："><a href="#图的着色：" class="headerlink" title="图的着色："></a>图的着色：</h3><h5 id="对偶图"><a href="#对偶图" class="headerlink" title="对偶图"></a>对偶图</h5><h5 id="韦尔奇着色法"><a href="#韦尔奇着色法" class="headerlink" title="韦尔奇着色法"></a>韦尔奇着色法</h5><p>对于v个结点，e条边的简单连通平面图，若v&gt;&#x3D;3，则e&lt;&#x3D;3v-6</p><p>G为至少3个结点的连通平面图，G中必有一个结点u，deg（u）&lt;&#x3D;5</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>数，森林，平凡树，树叶，分支点，</p><p>生成树，树枝，弦</p><ul><li><p>生成树：破圈法，避圈法</p></li><li><p>找到所有生成树：利用关联矩阵穷举连通图中的生成树</p></li><li><p>Kruskal算法</p></li></ul><p>二叉树：中序遍历，前序遍历，后序遍历</p><p>中缀，前缀（波兰）后缀（逆波兰）</p><p>Huffman算法<img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\babcf0e293d6d0e6224fc660590ee69.png" alt="babcf0e293d6d0e6224fc660590ee69"></p><h2 id="重点：（代数系统后面）"><a href="#重点：（代数系统后面）" class="headerlink" title="重点：（代数系统后面）"></a>重点：（代数系统后面）</h2><p><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\6d9231b2d8e2538297d2e504901f348.png" alt="6d9231b2d8e2538297d2e504901f348"><img src="C:\Users\17687\Desktop\HexoBlog\source_posts\lisan\0d80313c6e25b3482f47e1d2745433b.png" alt="0d80313c6e25b3482f47e1d2745433b"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;离散数学复习&quot;&gt;&lt;a href=&quot;#离散数学复习&quot; class=&quot;headerlink&quot; title=&quot;离散数学复习&quot;&gt;&lt;/a&gt;离散数学复习&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;数理逻辑&quot;&gt;&lt;a href=&quot;#数理逻辑&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
